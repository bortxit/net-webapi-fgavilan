Sección 1: Fundamentos de Web API y HTTP
	1. Introducción
		-Web Api: Aplicaciones web las cuales estan supuestas a ser utilizadas de forma remota usando el protocolo HTTP. Los clientes del 
		 web api son los que hacen peticiones: desktop, movil...
	
	2. Que es un API?
		-Los programas pueden comunicarse entre si porque exponen una API o interfaz de programacion de aplicaciones.
		-Una toma de corriente. En una misma toma peudes conectar una tostadora, un cargador de mv...Es que interactuca como una interfaz que deja pasar corriente a cualquier aparato.
		-Un conjunto de aparatos pueden usar el mismo enchufe para funcionar.
		-Enchufe es API y los aparatos son clientes de API.
		-Web API: Cojunto de interfaces definidas las cuales permiten a un conjunto de aplicaciones externas consumir el software de la aplicación web.
		-Un Web API expone un conjunto de funciones de una app web los cuales consumidos por web apps, moviles....
		-Un API permite que dos aplicaciones completamente distintas puedan comunicarse entre si. Una app de android hecha en Kotlin puede comunicarse con una app web
		 de C# hecha con api.
		-Permite realizar abstracciones que es que permite facilitar el uso de un software sin necesitar saber como funciona internamente.
		 basta con usar las funciones que el API expone.
		-No hay que ser ingeniero electrico ni saber como funciona para enchufar una tostadora a un enchufe, basta con usar el api para poder consumirlas.
		-La Web API se puede evr como un conjunto de funciones de nuestra app web, las cuales pueden ser consumidas por otras apps a distancia.
	
	3. ¿Qué es REST?
		-Es Representational State Transfer.
		-Es un estilo de construir servicios web los cuales se adhieren a un conjunto de principios establecidos.
		-Hay un cnjunto de condicioens que un Web API debe tener para decir que implementa REST.Cuando un Web API respeta estas condicioens, se le llama RESTFUL.
		-Cuando se consume un web api es porque se quiere acceder a sus recursos. En este caso hace referencia a entidades que se quiere consumir de un Web API.
		-Si tenemos un web api que nos permite trabajar con el sistema de una biblioteca, un recuirso es exponer el listado de libros o empelados.
		-Una idea relacionada con rets es la de utlizar metodos http sobre una URL para ejecutar diferentes funcioens de web api: 
			-https://miWebApi.com/api/usuario => Si se hace http get se obtiene lista de usuarios. Si se hace post, se ejecuta crear un usuario.
			 A esto se le llama HTTP CRUD porque se peude crear leer, crear, borrar y actualizar información consumiendo un webapi, utilizando HTTP.
		-No es suficiente para decir que un webapi es restful.
		-Se hablara de los metodos HTTP.
		
		-Nos concentramos en las condiciones que hacen que un webapi sea restful.
		-La ventaja de respetar esas condiciones es que se tienen beneficios añadidos como un software que pueda responder a cambios de requerimientos de negocio de una forma eficiente.
		-No todos los webapis que se hagan tienen que ser restful.
		-REST es una guia para desarrollar webapis. No se tiene que seguir al pie de la letra.
		
		-Seis condiciones de REST:
			1) Arquitectura cliente-servidor.
				-Nos habla de la separacion ente un cliente y un servidor o proveedor.
				-En en caso de los webapis, el servidor es un servidor web. El cliente puede hacer cualquier software.
				-El servidor es un servidor web en el caso de los webapis.
				-El cliente cualquier software capaz de comunicarse usando HTTP con servidor web, app de celular, app de escritorio...
				-Con este pricnipio, se asegura la separacion de responsabilidades entre el servicio de webAPI y los clienets que consumen dicho servicio.
				 Asi WebAPI puede evolucionar en el servidor y eso no tiene que afcetar clientes de nuestro servicio.
			
			2) Interfaz Uniforme: La idea es tener una forma estandarizada de transmisión de la información. Asi forma universal de usar webAPIs comunes.
			   Si sabes consumir un webAPi que no cueste consumir otros.
			   Subcondiciones:
				-Identificación de recurso: Se usan URLs para identificafr recursos: listado de libros....
				-Manipulación de recursos usandorepresentacioens: Si cliente tiene forma de acceder a unr ecurso (URL), con eso se peude modificar el recurso. Se usaran para esto peticiones HTTP.
				-Mensajes autodescriptivos: Todos los mensajes son completos.Indican la informacio necesaria para ser trabajados por el servidor de forma satisfactoria. Peticiones HTTP al servidor.
				 Algo que mensaje puede indicar es el formato en el que queremos la info del servidor con media-types: son identificadores de formato para indicar la forma
				 den que queremos que se nos de la info: json, xml....
				 Cliente tiene poder de pedir info en formato que desea, es servidor responsable de satisfacer la peticion del cliente.
				 Si al peticion del cliente no es razonable, servidor no tiene porque satisfacer.
				 Si se quiere listado de libros de webapi y se quiere en formato img, no tiene sentido y webapi no tiene porque satisfacer esa demanda. 
				 Si es razonable que pida en formato json.
				-HATEOAS: Info que da web api debe incluir links para seguir explorando e4cursos de webapi.
					-Si se pide listado de libros de webapi, estaria bien que cada libro link para ver detalles.
			
			3) Protocolos en estado
				-Cada una de las peticiones realizadas a la web api tiene toda la info necesaria para que la peticion sea resuelta de forma satisfactoria.
				-Si webapi requiere que clientee ste autenticado para acceder y manipular recursos, este debe incluir en solicitud al servidor algun tipo info que lo identifique de forma unica.
				
			4) Cache
				-Las respuestas del webapi deben de indicar cuando se deben guardar en cache.
				-Cuando se habla de cache, se refiere a que cliente puede guardar el recurso dado por una url de forma local, que en subsiguientes peticiones no tenga que ser pedido al webapi sino que
				 se pueda consumir la version local ya que disminuye el tiempo de respuesta que deben esperar clientes de la app. No todo en cache porque pone en riesgo a clientes de trabajar con data desactualizada.
			
			5) Sistema de capas
				-El servicio del servidor debe tener un sistema de capas, donde su evolución sea completamente transaparente para el cliente.
				-Si el servicio usa balanceador de carga, los clienets no tienen porque tener presente este detalle.
				
			6) Codigo en demanda
				-El servicio web tiene la opcion de enviar codigo fuente el cual se va aejecutar en el cliente.
	
	4. Métodos HTTP
		-Manipulacioens a recuross una vez que tengamos URL, eso se realiza usando metodos HTTP. 
		-Los métodos HTTP son un mecanismo del protocolo HTTP los cuales nos permiten expresar la acción la cual queremos ejercer sobre un recurso.
		-Si se tiene un recurso localizado en una URL, si se quiere obtener usuarios se puede hacer una http get a esa URL y si se quiere insertar un post.
		-Los metodos permiten expresar la accion que se quiere hacer sobre un recurso.
		-Como rporgamador, definimos que sucedera en un webapi cuando cliente use un metodo http sobre un recurso.
		-Ademas, se puede definir si metodo http no es permitidosobre un recurso.
		-GET: pedir dtaos del servidor.Se coloca URL en navegador y se presiona enter, navegador manda peticion httpget para indicar a server que queremos obtener info de un recurso.
		 Las representaciones de recuros peuden ser un documento html, xml, json...
		-HEAD: no trae cuerpo de repsuesta, solo cabecera. Se tiee info de tipo de contenido, localidad, status....Es info acerca del mensaje.
		-POST. Enviar info del servodor a traves del cuerpo de la peticion HTTP. Con info que se manda a servidor este puede realizar operacion y dar repsuesta a cliente. 
		 uso comun es insertar info al webapi en BBDD.
		-PUT igual que POST pero tambien para actualizar info en bbdd. Si recurso al que se le hace PUT no existe, puede crearlo en lugar de actualziarlo. 
		 Normalemente no es asi sino, que si se quiere actualziar recurso que noe xiste, se devuelve no encontrado.
		-DELETE: Sirve para decir que se quiere borrar recurso.
		-hay uchos metodos para asociar con lectura, insercion, modificacion y borrado de info.
		-A webapis que utilizan estos metodos para reralizar estos metodos sobre bbdd, se les llama HTTP CRUD.
		-En modelo de madurez de Richardson es modelo madurez nivel 2.
		-PATCH: se usa para realziar actualziacioens parciales a un recurso.
		 Ventaja es que es rapido comparado con PUT, implementacion mas dificil.
		-Habra clase para procesar peticiones para un recurso y esa clase tendra funciones y segun el metodo http usado, se ejecuta una de las funcioens de la clase.
		
	5. Anatomía de una petición HTTP
		-Con webapis, la comunicacion entre nuestros clientes y webapi, se va a realizar usando peticiones http.
		-Una peticio http es un mensaje que manda una computadora  a otra usando protocolo http.
		 Esa peticion hacen clientes de webapihacia neustro webapi. Cuando webapi recibe peticion la procesa y retorna una respuesta que es respuesta HTTP.
		-Los clientes y webapi se comunican usando respuestas y peticioens HTTP.
		-Esos mensajes tienen una estructura:
			-Linea de peticion:
				-Se coloca el metodo HTTP as usar, la URI de la peticion y protocolo a usar. Es decir: METODO-HTTP URI PROTOCOLO-HTTP.
				-URI es direciciondonde se encuentra el recurso, PROTOCOLO-HTTP es el protocolo a usar. Hay avrias versiones del protocolo. Lo normal es el protocolo 1.1
				-Ejemplo de linea de peiticon: GET/api/autores HTTP/1.1 => metodo get, se lee recurso en api y luego protocolo a usar.
				-La segunda parte de una peticion http es la cabecera 
			
			-Cabecera de la peticiones	
				-Es donde se encuentran las cavbeceras. Son metadatos que se mandan en peticion para brindar info sobre la peticion.
				-Cada cabecera se especifica con un nomnbre, luego dos puntos y seguido por valor de una cabecera => Host: en.wikipedia.org.
				-El nombre de la cabacera es host y lo otro es su valor. La cabecera host indica dominio de servidor.
				-Otra cabecera => Cache-control: no-cache. Puede haber multiples cabeceras.
				-Ejemplo de petición http con su linea de peticion y cabecera:
					GET/api/autores HTTP/1.1
					Host: wn.wikipedia.org
					Cache-Control: no-cache
					
					Se ve que primera linea es la linea de peticion y devajo de esta se encuentra la cabecera de la peticion que se compone de varias
					cabeceras individuales: Host y cache control que son cabeceras estandar que ya tienen un proposito definido. Se tiene liberatd de usar nuestras
					propias cabeceras como cuando necesitamos expresar uestra propia metadata de nuestra peticion. Lo unico que se necesita es mandarl en la cabecera de la peticion HTTP.
			
			-Cuerpo de la peticion.
				-Es donde se coloca informacion adicional que se va a enviar al servidor. Se tieen libertad de colocar virtualmente lo que se quiera: nombre y usuario, respuestas a una encuesta....
				-El cuerpo respresenta el cntenido perse que se quiere transmitir.
				-Peticiones get no usan cuerpo porque no se tiende a enviar datos complejos a la hora de leer información del servidor.
				-En post si se suele usar cuerpo para colocar lo que se quiere enviar.
				-Ejemplo Hola: Sirve para mandar lo que sea el cuerpo, desde un saludo hasta informacion mas esttructurada.
					Aqui se tiene info en formato json que representa el cuerpo de la peticion
					{
						"Nombre": "Felipe Gavilan·,
						"Edad": 999
					}
					
		-Ejemplo: Se va a ver peticion HTTP con sus tres partes:
			POST/api/autores HTTP/1.1
			Host: miWebApi.com
			Content-Type: application/json
			Cache-Control: no-cache
			
			{
				"Nombre": "Felipe Gavilan·,
				"Edad": 999
			}
			
			La peticion es post a un recurso /apoi/autores.
			Hay una cabecera compuesta de tres cabeceras.
			Finalmente, cuerpo de peticion.
			
		-Respuesta HTTP: Cuando el cliente nos envia un peticion HTTP, el servidor debe de responder con una respuesta HTTP.
		 la respuesta tiene su propia estructura.
		 La respuesta HTTP tiene su propia estrcutura: Linea de estatus, cabecera y cuerpo.
		 
		-En la linea de estatus nos indica el estatus de la peticion, es decir, si fue exitosa, error o si se requiere accion.
		-La cebecera es un conjunto de acbeceras igual que cabecera de peticion. El servidor peude mandar tantas cabeceras como queire. 
		-El servidor puede mandar un cuerpo con data que desee. e3s opcional y es fundamental a la hora de usar paginas web, ya que es a traves del cuerpo donde se recibe el HTML 
		 de una pagina web que se quiere ver en el navegador.
		
		Ejemplo:
		HTTP/1.1 200 OK
		Date: thu, 03 Jan 2019...
		Server: gws
		Accept-ranges: bytes
		Content-Length: 68894
		Content-Type: text/html; charset=UTF-8
		
		<!doctype html></html>
		
	
	6. Códigos de status HTTP
		-Cuando se hace peticion HTTP a servidor, recibimos respuesta HTTP. 
		-Entre la informacion recibida, esta el codigo estatus de la respuesta. El codigo es un numero que indica el rdo de la oepracion.
		-Son numeros de 3 digitos y un nombre. El primer digito indica la categoria del status.
		-Existen 5 categorias:
			-1xx informacional
			-2xx exitoso
			-3xx redireccion
			-4xx error del cliente
			-5xx error del servidor
			
		-Ademas de tres digitos, tienen nombre: 404 Not Foudn de no encontrado. Asi cuandos e recibe codigo de status se recibe un nombre.
		-En conversaciones normales hablaspor cdoigo, es decir, 404.
		
		-1xx Respuestas Informativas
			-Cuando se manda una peticion HTTP al servidor, el servidor verifica si procesa la solicitud y de ser asi, devuelve resopuetsaal cliente de que va a sser procesada y que debe
			 esperar respuesta final. Quizas la respuesta llega en unos segundos, es respuesta temporal y no final (intermedi).
			-Algunos ejemplos son: 100 Continue quiere decir que cabecera ha sido recibida y que el cliente deberia enviar el cuerpo de la peticion a continuacion si aplica.
			 Es eficiente de intercambnio de paquetes porque da oportunidad al servidor de denegar una epticion http sin tener que recibir y procesar todo el cuerpo de la peticion.
			-Ademas, desde el punto de vista de la seguridad de la info del usuario, el servidor puede detectar si conexion va a ser insegura. Es decir, usa HTTP y no HTTPS y peude denegar 
			 peticion sin que el cliente envie sus datos, enviando el cuerpo de la peticion sobre una conexion insegura.
			-101 Switching protocol que es cambiando protocolos. Esta respuesta se da cuando cliente pide un cambio de protocolo y servidor esta de acuerdo con la demanda.
			 Un ejemplo de esto es cuando el cliente pide al servidor actualizar la conexion para usar websockets.
		
		-2xx Exitoso
			-Ejemplos son: 200 OK. Significa que oepracion exitosa. Por ejemplo, si se hace una peticion get sobre un recurso un 200 ok, es que el recurso ha sido devuelto en la respuesta.
			-201 Created: la peticion se ha completado. Resultado de la creacion de nuevo recurso. Es respuesta exitos, especifica que debemos retornar cuando peticion resulta en crar nuevo recurso.
			Por ejemplo, que envie nuevo libre y sea insertar en BBDD.
			-202 Accepted: Peticion ha sido aceptada para ser procesada pero el procesamiento no ha acabado. Se sua para largos procesos en los que usuario no espera un rdo inmediato, sino
			 que en el futuro se le va a indicar dicho rdo. Por ejemplo en envio de correos masivos, se peude indicar que se quiere mandar un correo a miles de sus clientes.
			 Esto no es necesariamente que se hace de una vez sino que el servidor reciba epticion, devuelva 202 y ene l futuro puede hacer envio masivo de correos.
			-204 No Content: Significa que no hay contenido. La peticion ha sido realizada con exito y no se va a retornar un cuerpo en respuesta.
			 El servidor solo debe enviar la linea de respuesta y la cabecera de la respuesta.
			
		-3xx Redirección
			-Esta categoría de codigo de status indica que el cliente toem acciones adicionales cpara completar peticion. En ocasiones, esta accion ocurre de forma automatica sin que el usuario tenga que hacer nada.
			-301 Move permanently: Se usa para indicar una redireccion permanente de la URL. Cualquier link que apunte aesta URL debe ser actualizado por la nueva URL correcta.
			 Dicha URL correcta, la devuelve el servidor en cabecera location.
			-302: Found. Indica que el recurso solicitado se encuentra en una diferente URI de forma temporal dado que nueva location es temporal se necesita que el cliente siga haciendo la peticion
			 a la URL original en elfuturo.
		
		-4xx Error del cliente
			-Esta categoria indica que el cliente ha cometido algun error a la hora de hacer la peticion. La naturaleza del errores determinada por el codigo de status.
			-Algunos ejemplos de codigos de status:
			-400 Bad request: el servidor no puede finalizar la peticion por error del cliente, es un error generico. Lo normal es que en el cuerpo de la respuesta se coloque una explicacion de que
			 fue lo que salio mal para que el cliente peuda corregirlo e intentar peticion de nuevo. Si el usuario llega a formulario y campo nombre es obligatorio y no lo llena y le da a enviar, o normal es que servidor
			 devbuelva error 400 y el cuerpo indique que campo nombre es requerido
			-401 Unauthorized: Esto quiere decir que usuario necesia loggearse en nuestro sistema para poder realizar accion que quiere.
			-403 Forbidden. Se envia cuando el usuario a pesar de estar autenticado, el mismo no tiene permisos suficientes para realziar accion que queire.
			-404 Not Found: recurso no ha podido ser encontrado.
			-405 mehtod Not Allowed: El emtodo no esta disponible para recurso solicitado: put, delete, get....
			-408 Request Timeout: A la peticion se le acabo el tiempo. El servidor tuvo timeout procesando. Esto es cuando peticion tarda mas tiempo del permitido.
		
		-5xx Error del servidor
			-Esta categoria indica que el servidor ha fallado en satisfacer la peticion. Estos errores son difernetes a errores indicados en categoria 4 porque en categoria 4 se entiende que el error
			 es del usuario pero en la 5, el problema radica en servidor.
			-500 Internal Server Error: Esto es error generico que puede ser cualquier cosa. Si codigo de api da error porque no peude conectarse a BBDD, pues error 500
			 se sirve al cliente dado que no es su culpa que nuestra api haya percdido comunicacion con bbdd.
			-503 Server Unavailable: el servidor no disponible en estos momentos. Puede ocurrir que app de error y no sube,
			
				
	7. Resumen
		-Se ha visto fundamento de webapi y http. Se ve que api es abstraccion que permite usar un sistema sin tener que entenderlo ointernamente.
		-Un webapi sirve para permitir a cleintes usar servicio web a distancia usando protocolo HTTP.
		-REST significa transferencia de estado representacional y es un estandar que declara 6 ppios que prometen tener webapi que siga buenas practicas.
		-peticion HTTP: linea de peticion, cabecera y cuerpo.
		-Los metodo http indican la accion que se quiere hacer sobre un recurso.
		-Los codigos de status HTTP permiten indicar el resultado de la peticion del cliente. Con ese codigo se peude decir si peticion exitosa, si ha habido error del cliente...
			
			
Seccion 2: Configurando el ambiente
	9. Introducción
		-Es importante conocer el stack de desarrollo que se va a usar y se debe preparar el entorno de desarrollo.
		-Se habla de .net, C#, asp.net core. Luego se instalaran herramientas.
		
	10. ¿Qué es .NET?
		-.NET es una plataforma de desarrollo que sirve para desarrollar distitnos tipos de aplicaciones. Esas apps podran correr en Linux, Windows, entre otros.
		-Se peudend esarrollar apps de escritorio, web, juegos, celulares....
		-Es improtante destacar que noe s elnguaje de programacion sino que es un entorno en el que se peuede ejecutar disittntos tipos de apps.
		-Lenguaje de prorgamacion para .NET: C#, F# y Visual basic.
		-El mas popular es C#. Es lenguaje multiparadigma y es especialmente conocido por ser orientado a objetos, igual que Visual Basic. F# es lenguaje funcional.
		-.NET creado por Microsoft en 2002 para correr en Windows. La idea era framework que asistiera a la hora de hacer apps.
		-Este framework se encarga de cosas como manejos de memoria etc.
		-Permite escribir code en disitntos lenguajes que peuden comunicarse entre si.
		-Se peude llaamr code de visual basic desde C#.
		-.NET llego hasta la version 4.8. Un cambio de vision en mcirosoft llego a conclusion que debia abrrise, no debia ser framework exclusico de Windows
		 sino que multiplataforma y mas rapido y ligero.  Por eso en 2014 aparece .NET Core.
		-A la version vieja se le llama .NET Framework y llego hasta version 4.8- .NET Core es la version nueva y salio en 2016 en version 1.
		 Año a año salieron versiones .NET Core 2 y 3. Para evitar confusiones ya que .NEt Framework llego a la version 4.8, para no confundir con .NEt Core 4, saltaron 4 y se fueron al 5.
		 Ya que .NET Framework no llego a la version 5, los genios del marketing de Microsoft dejaron de llamarle Core y simplemente le llamaron .NET 5 y salen versiones. En noviembre de cada año sale una version
		 nueva. El calendario es predecible de neuvas versiones. 
		-.NET Framework es la version vieja que solo corre en Windows. .NET Core corre en difernetes SO. A partir de version 5, se llama .NET 5 y no .NET Core 5.
		
	11. ¿Qué es C#?
		-En .NET se peuden usar varios lenguajes como C#, F# y Visual basic.
		-Es un lenguaje multiparadigma y fue creado por Microsoft en el año 2000. Aunque podemos usar diferenets lenguajes en .NET, el mas usado es este.
		-Lenguaje es parecido a Java y C++.
		-Con C# se pueden crear app web, moviles que corran en Android y IOS, se peuden crear app interactivas con Blazor, se peuden hacer app de escritorios...
		-Se peude prorgamar para un mundo de apps.
		-Que sea multiparadigma significa que permite disitntos paradigmas como lenguaje orientado a objetos y funcional.
		-Es un lenguaje fuertemente tipado. Eso queire decir que reglas de lenguaje pueden ser enforzadas en tiempo de compilacion. Si escribes codigo no valido en C# te daras cuenta en seguida.
		-En lo que respecta a la programacion orientada a objetos, C# es basado en clases. Gran parte del tiempo que se desarrollen apps basadas en C#, estaremos trabajando en clase. COn clases
		 se vana  poder encapsular partes de aplicaciones en unidades que contienen datos y comportamientos. Se va a poder modelar el comportamiento de nuestros programas en clases que inetractuan entre si.
		 Habra clases que se vana a necargar de procesar peticiones HTTP, clases que vana a trabajar con acceso a BBDD, otras se encargan de logica de negocio como calculo de impuestos.
		-Asi,  se tiene app organizada y mas facil de desarrollar.
		-En lo que respecta a paradigma funcional, C# permite trabajar con funciones de priemra clase que se refiere a que se peuden realziar operaciones como pasar funcioens como params a 
		 otras funciones, retornar funciones como rdo a otras funciones, asignar funciones a variables e incluso trabajar con funciones anonimas.
		-Un uso practico que se peude dar a la programacion funcional de C# es LINQ View y expresioens lambda. De esta forma, usando el paradigma funcional, se peuden consultar bbdd, apoyandonos en una libreria 
		 llamada Entity Framework.
		-C# es lenguaje amplio. Se usara ara desarrollar webapi y para ello se usara asp.net core.
	
	12. Introduccion a ASP.NET Core.
		-Es un framework para desarrollar aplicaciones web.
		-Este es multiplataforma lo que quiere decir que puede correr en diferentes SO como Windows, Linux o MACOS.
		-ASP significa Active Server Pages. La diea es que es tecnologia para desarrollar sitios web dinamicos y contenido variara dependiendo de factores.
		-En nuestor caso, se trabaja con webapis. la mision de ASP.NET Core es ponernoslo facil en lo que respecta a funcionalidades comunes de distintas
		 apps webs. Es decir es framework  que ofrece suficiente funcionalidad para no tener que estar reinventando la rueda con cada app que hagamos.
		 ASP.NET Core viene con sistema de ruteo que permite indicar que funcion se quiere usar ante peticion HTTP.
		-Tambien tiene sistema de usuarios que permite registrar usuarios en nuestras app.
		-Viene con sistema de inyeccion de dependencias que nos permite aplicar principios de desarrollo de software como principio de inversion de dependencias
		 donde se puede hacer que clases dependan de abstarcciones y no de tipos concretos.
		-Otra cosa importante es la velocidad. A medida que .NET va mejorando, se introducen mejoras, a veces por el simple hecho de actualizar web api a nueva version, 
		 y sin realizar cambios de codigo, obtienes webapi mas rapido.
		-Es importante separar ASP.NET de ASP.NET Core. Esto es igual que la diferencia entre .NEt Framework y .NET Core.
	
	13. Controladores y Minimal APIs
		-Para crear webapis, hay dos opciones: usar controladores o minimal APIs.
		-Se comienza hablando de controladores. 
		-Un webapi permite obtener clientes que se comuniquen con api a traves de una peticion HTTP. Al recibir dicha peticion, nuestar app, tiene que ejecutar alguna funcion.
		-A esa funcion se le llama accion. Una accion en C# es un metodo de C# que maneja peticiones HTTP.
		-Luego, la clase que contiene los metodos de accion es un controlador.
		-Por tanto, un controlador se encarga de agrupar metodos de accion. los agrupa de forma logica. En webapi de peliculas se peude tener un controlador de actores qe agrupa acciones
		 relacionadas con actores. Crear actor, borrar actor....
		-Controlador permite definir logica global que aplicara a acada accion. Por ejemplo, si es necesario que clien6te este registrado en app para acceder a las acciones del controlador,
		 pues se puede colocar esa configuracion en un solo lugar a nivel del controlador.
		-Se muestra un controlador de ejemplo, WeatherForecastController que se crea por defecto en nuevas apps de webapi.
		-Encima de este hay configuracion de rutas que indica a que ruta hay que hacerle las peticiones HTTP para ejecutarse las funciones de este controlador.
		-Hay atbto llamado API Controller que realzia serie de configuraciones por defecto en nuestro webapi.
		-Se uede evr que como cualquier clase, hay constructor en el que se esta iyectando un ILogger que basicamente nos permitehacer loggin en nuestra app.
		-Hay un metodo get() al que se le llama accion y lo que hace es responder a una peticion HTTP realizada sobre nuestro webapi.
		-Es decir, si cliente hace petoicion a webapi, en este caso hacia la ruta de ForecastController, si esa peticion es de tipo HTTP,
		 pues se espera que se ejecute esa funcion. Esa accion responde a accion GET porque se tiene atrubuto HTTPGet decorandola.
		 Se peuden Tener otras funciones y metodos.
		 Se puede tener emtodo put, delete...
		 Asi como se tiene WeatherForecastController, se podria tener un GeneroController para generos de peliculas etc.
		 En GeneroController se tendran acciones relacionadas con entidad de Genero.
		 Asi es como se organiza unwebapi basado en controladore.
		
		
		MINIMAL APIs.
		-Permiten construir webapis con menos code y mas rapido.
		-No se trabaja directamente con controladores, sino que se trabaja directamente con acciones o endpoints.
		-En el caso de minimal apis se llaman endpoints.
		-Se coloca lo que se quiera que suceda ante una peticion http a un endpoiint justo al lado.
		-Son versiones minimalistas de webapis, es decir, remueven las cosas que no son esenciales.
		-Menos poderosos que los controladores pero mas rapidos y eficientes.
		-Se ve ejemplo y se tiene funcion de mapget que permite configurar endpoint que va a responder una peticion HTTP get. La ruta de esa peticion es /weatherforecast que es el mismo caso que los controladores.
		-Al lado se tiene parametro que es expresion Lambda y tiene el cuerpo del endpoint y es lo que se va a ejecutar cuando se reciba una peticion httpget hacia la ruta.
		-No se tiene que construir una clase con su controlador y tal.
		-Es mas rapido en terminos de velocidad. Los controaldores tienen mas funcionalidades y son mas poderosos.
		
	14. Instalando .NET
		-Para trabajar con ello, hay que instalarlo.
		-Hay que ir a dotnet y descargar.
		-Se instala la version mas reciente de .NET. Se puede instalar en Windows, Linux, distitnas arquietctruas y distintos SO. Para ver opciones se pincha en All .NET 9.0 Downloads.
		-Se coge SDK *64 de Windows.
		-Windoews + R; cmd; dotnet --version.
	
	15. Instalando el EF CORE CLI
		-Se instala el Entity Framework CLI. Es decir, herramienta de linea de comandos de Entity Framework Core.
		-Independiente a usar VS o VS Code, se necesita para cuando se vaya a publicar webapi en PROD para aplicar las migraciones en ls BBDD de PROD.
		-Se busca en google EF CORE CLI, se pincha primer link y se instala herramienta para interactuiar con entity framework core desde linea de comandos.
		
		
	16. Instalando Visual Studio
		-Disponible para Windows. Se coge la version Community que es gratis y permite hacer de todo.
		-Aparece Workloads que son herramientas que vamos a tener disponible spara poder trabajar.
		-Esto hace referencia a tecnologias con las que vamos a querer trabajar: Python, Node JS....
		-Nosotros usaremos ASP.NET Core, Azure, .NET desktop para winforms etc....
		-Luego ya instalar.
	
	17. Instalando Visual Studio Code
		-Se instala version de Windows.
		
	18. Instalando SQL Server
		-Se instala SQL Server developer edition.
		-SQL Serve es el motor de BBDD que se va a usar en este curso.
		-La edicion de desarrolaldor o developer edition es una edicion completa para hacer desarrollos y aprender con esa version.
		-Con edicion competa se refiere a que trae todas las caracteristicas que tien version profesional de SQL Server solo que esta creada para ser utilizada en un entorno de desarrollo.
		-Ahora es lña version Express o Developer...
		-Se instala SQl Server Management Studio (SSMS) que sirve para voisualizar BBDD, poder hacer querys etc.
		-SQl Server hace que las bbdd funcionen, el otro lo que hace es interactuar con bbdd.
		-En la conexoin hay que darle a Trust Server Certificate por ser maquina local y confias.
		
	19. Instalando Postman
		-Es un cliente para realizar peticiones HTTP de forma sencilla. Se va a usar Postman y Swagger.
		-Se puede hacer el tipo de peticion que se quiera PUT, GET, DELETE...
		-Hay que ir a Settings y desactivado el Send no-cache header porque se quiere usar cache y descativar SSL certificate verification porque permite relajar las reglas de seguridad para no necesitar certificado SSL
		 valido para la app.
		 
	20. Creando el WebAPI con VS
		-Se le da a crear nuevo proyecto y hay que buscar empty => ASP.NET Core Empty.
		-Se le llama HolaMundoWebAPI.
		-Se selecciona .NET 9 y se crea.
		
	21. Creando el Web API con VS Code
		-Se crea carpeta donde se quiere crear proyecto.
		-Se pulsa Shift + Boton derecho para abrir una ventana de powershell.
		-Se pone el comando dotnet new list para que liste los tipos de proyecto que puedo crear con dotnet cli.
		-Se queire crear ASPN.NET Core Empty porque se quiere crear desde cero el webapi.
		-Hay un shortname que indica que hay que poner "dotnet new web".
		-Se añade -o de output para asignar nombre a mi webapi y colocar en una carpeta.
		-dotnet new web -o HolaMundoWebAPI.
		-Se hace cd a esa carpeta y se abre Visual Studio con "code .".
		-Se pueden usar extensiones que son como plugins que son aditamentos que se pueden agregar a VS Code para trabajar con una tecnologia.
		-Para trabajar con C#, extensiones de C#.
		-Se instala C# dev kit.
		
	22. Explorando el Web API - Soluciones y proyectos
		-Se va a explorar los archivos de la app.
		-Se va al Explorador de soluciones. Se va a ver el proeycto de HolaMundoWebAPi. E sun archivo de extension csproj.
		-Es un fichero de configuracion de un proyecto.
		-Un proyecto es un grupo de archivos que van a ser compilados a algo que se le va a poder dar uso.
		-Por ejemplo, proeycto es WebAPI, app de escritorio, de consola....o libreria de clases.
		-Una libreria de clases es un proyecto que sirve para compartir codigo entre difernetes proyectos.
		-En un csproj tiene configuraciones de nuestro proyecto. por ejemplo, esta hecho para .NET9.
		-Tambien dice que utilizamos tipos de referencia No Nulos.
		-Estos ayudan a evitar errores de referencia No Nulos.
		-Abajo habra paquetes nuggets instalados que son como librerias de clases es proyecto que permite compartir codigo para que sea reutilizado.
		 Es parecido. Es libreria de clases que descargamos para utilizarla en nuestro proyecto.
		 Osea es com de internet que lo descargas y reutilizas en proyecto. A traves de paquete nugget puedes descargar proyectos 
		 de Microsoft o personas individuales y usar el code que nos proveen
		-Encima de este fichero esta la solucoin que es un conjunto de proyectos relacionados entre si.
		-Se puede tener una solucion que peude tener varios proyectos: proyecto de MAUI, proyecto de webapi...Esos estaran relacionados bajo una solucion.
		-Un proyecto es un cnjunto de archivos que podemos compilar para darles uso como una app web y solucione s cjto de proeyctos.
	
	23. ¿Qué es Nullable?
		-Eso es una configuracion que se llama tipo de referencia no nulo que basicamente nos obliga a ser explicitos acerca 
		 de la naturaleza de los tipos de referencia de nuesta app. Es decir, que no se pueda asignar Nulo asi libremente, sino que
		 se tenga que indicar cuando un tipo der eferencia puede contener nulo.
		-En C# hay dos tipos de dato que son los tipos de valor y tipos de referencia.
		-Un tipo de valor es cuando la variable contiene la instancia del tipo. Es cuando se tiene una varuiable => int edad y en esa variable esta numero 99. Y eso es porque int, el tipo entero, 
		 es ejemplo de tipo de valor.
		-En un tipo de referencia es cuando la variable contiene una referencia a la instancia del tipo.
		-Por ejemplo, string nombre = "Felipe";
		-Esto es un ejemplo de tipo de referencia.
		-Los string son como tal un tipo de referencia.
		-Quiere decir que la variable no contiene el valor Felipe sino una referencia a ese valor que se encuentra en un lugar en memoria.
		-Como eso es un tipo de referencia es que apunta a un lugar en memoria. Que pasa si borro la referencia hacia donde apunta el nombre?
		 Si se pone nombre = null; no pasa nada y no apunta a ningun lugar. En un tipo de valor no se peude decir esto porque al no ser un tipo der eferencia, 
		 no puedo asignar nulo porque no es un valor, es la carencia d euna referencia. Es decir, no se le puede asignar un null porque es unn tipo de valor.
		-Se tiene advertencia y es referencia a esta configuracion del proyecto. puedo tener un nombre que es un string que es un tipo de referencia
		 lo que quiere decir que no contiene un valor en si sino una referencia a un valor en un lugar en memoria.
		 Ahora, no se ah dicho que este string en algun momento opodria contener nulo y es peligroso.
		 nombre.toUpper() da error en tiempo de ejecucion por que es nulo y nulo.toUpper() va a dar error de referencia nulo.
		 porque se esta esta intentando aplicar toUpper a la nada.
		-Lo que el tipo de referencia no nulo configura es que yo tenga que ser explicito a la hora de declarar un tipo de referencia que peude contener nulo.
		-Habriaque poner string ? nombre = "Felipe". Deja de aparecer advertencia porque estas siendo explicito a la hora de indicar que variable nombre puede conteenr nulo
		 a pesar de ser tipo de referencia podria contener nulo.
		-Los tipos de referencia no nulom obligan a ser explicitos cuando hay tiponde referencia que peude contener nulo.
		-Eso no quiere decir que no de error pero se esta siendo explicito a la hora de decir que esa variable podria ser nula.
		-Esa advertencia es para tener cuidado y programar de forma mas robusta. Es una sugerencia o una ayuda.
		-Sino gusta tener que estar poniendo ?, sencillamente se cambia <Nullable> a disable para eliminar la configuracion de referencia no nulo.
		-Es mejro enable porque ayuda a programar de forma mas responsable.
		
	24. Using Implícitos
		-permiten evitar tener ciertas directivas using en nuestros archivos de C#.
		-La clase program no tiene ninguna directiva using.
		-Funciona lo de la declaracion del builder porque los using implicitos son directivas using que estan implicitas en las clases de C#.
		-Si se pone a disable entonces aparecen errores y hay que darle a control + punto para usar el using.
		-Es mas comodo si hay using implicitos para no colocar code sin necesidad.
		-Se devuelve a enable y se ve que es parte de una configuracion que permite usar los tipos de dicho namespace de manera impiicita sin tener que usar el using de forma explicita.
		
	25. Archivo LaunchSettings
		-Es un fichero que permite colocar configuraciones respecto al lanzamiento de la app.
		-Estas configuraciones son para el entorno dev, en prod no se usa.
		-Se tienem dos perfiels: http y https.
		-En la ejecucion se tienen esos perfiles.
		-Hay un launchbrowser para lanzar el navegador.
		-Cuando se corra app, se corre el navegador.
		-Se abre una consola y un navegador. Si se pone a false, no se lanza el navegador, sale la consola.
		-La URL es 7089 y viene de un profile. Se esta configurando en apllicationUrl cual es la URL a la que vamos a poder acceder a nuestra app.
		-Si se quiere se peude poner 7090.
		-las variables de ambiente se peuden hacer configuraciones que no necesariamente estan en el codigo fuente.
		-En desarrollo se puede poner aqui sin tener que ponerlo en el codigo fuente.
		-Ahora se tiene esto: "ASPNETCORE_ENVIRONMENT": "Development".  Con esto se simula que estas en desarrollo.
	
	26. Clase Program
		-Es sencilla, pequeña y tiene minimo para correr webapi.
		-Se comienza creando una app web que en asp.net core significa que es un cnjunto de configuracioens acerca de rutas, piplines, http...Lo que se necesita para poder teenr una app web la cual pueda 
		 recibir peticiones http y dar respuesta.
		-Se coloca eso en una app builder y se hace builder.Build() para construir app web.
		-Antes de esto se tiene el area de servicio (inicio del area de servicio).
		-Entre el builder y app, se configura el servicio. Un servicio es una clase que peude reusarse en ASP.NET Core y se configura desde aqui.
		-Con ello, se permite no repetir code y tener un area donde tenemos principales configuraciones de nuestra app.
		-La clase program se divide en varias partes.
		
		-Otra es el el area de los middlewares.
		 Va despues del builder.Build().
		
		-Un middleware es el conjunto de procesos que vamos a correr cada vez que recibamos epticion HTTP en nuestra app.
		-Se tiene el mapGet que es que si recibimos una peticion get hacia root de la app, se devuelve Hola Mundo!
		-Quiere decir que cuando se hace peticion get, hacia el root de la app, se ejecuta la funcion y devuelve ese string. Eso se conoce como minimal api porque no se sua un controlador.
		-La clase program esta configurada para unproyecto de Minimal APi donde con minimo codigo podemos tener una web API funcionando.
		-Esta clase es el punto de entrada de nuestro web api donde se construye la app web se tiene area de servicios y area de middlewares dknde se construiran funciones que peudan nterceptar
		 y procesar las peticiones HTTP que vayan al Web API.
		 
	27. Archivos AppSettings
		-Son dos ficheros el normal y el development.
		-Esos ficheros tienen como proveedores de informacion.
		-Un proveedor de configuracion es una fuente de datos que nuestra app peude usar para rapido acceso a datos de configuracion.
		-Este tipo de archivos es importante porque ayudan a evitar tener datos de configuracion  hardcodeados en el codigo de C#.
		-Es un fichero json con configuraciones. Es un archivo de texto plano en formato json.
		-El de Development es igual.
		-Aqui se peuden meter configuraciones que no se quiere que esten en el codigo de C# porque es compilado y una vez compilado no puede ser editado .
		-Yo tendria que modificar code fuente, vovler a compilar y mandar ficheros a prod para poder actualizar el code. No se quiere porque ha datos que se quiere colocar en fichero de texto
		 plano de tipo json y que aplicacion simplemente tome.
		-Se va a ver ejemplo. Un ejemplo es una cadena de conexion que es un string que contiene ubicacion de BBDD, el nombre de la bbdd, credenciales para autenticarme....
		 Tiene todo para oder usar una BBDD.
		-Tipicamente se tiene BBDD para pruebas y una de PROD que es datos reales y son BBDD separadas.
		-Por eso, son conexioens distintas.Se tendra un connectioString para desarrollo y otro para PROD.
		-Por eso se tiene dos ficheros de appsettings. El appsetting.development.json, es el fichero que contiene coinfiguraciones de la app para desarrollo.
		-El otro es para prod.
		-Se mete en el de development => "cadenaDeConexion": "Esta es una cadena para mi BD de desarrollo",
		-Se mete lo mismo para el json de prod => "cadenaDeConexion": "Esta es una cadena para mi BD de prod",
		-Si se quiere obtener el valor de la cadenaDeConexion desde Program => var cadenaDeConexion = builder.Configuration.GetValue<string>("cadenaDeConexion") (para provvedores de configuracion.
		-Se puede meter esto en el code.
		-Si se quiere probar en prod lo que saldria, se usa variable de abiente en launchSettings.json:
			"https": {
			  "commandName": "Project",
			  "dotnetRunMessages": true,
			  "launchBrowser": true,
			  "applicationUrl": "https://localhost:7288;http://localhost:5139",
			  "environmentVariables": {
				"ASPNETCORE_ENVIRONMENT": "Production"
			  }
			}
			
		-Se ha visto que desde que se pone que estamos en rpod, se usa proveedor de configuracion de produccion. Sin tener que cambiar nada con respecto a program,
		 solo cambiando variable de ambiente se ha seleccionado un proveedor de config u otro. Ademas, si se cambia el string, no se ha modificado C# y se tiene nuevo valor. Se toca solo proveedores de configuracion.
		 Se puede sin tener que compilar la app, se peudan ver cambios ahi.
		 
	28. Resumen
		-Se instala .NET, Visual Studio y otras cosas para realziar ejercicios, webapi de ejemoplo y se vio que es proyecto y solucion.
		-El fichero launchSettings permite realizar configuraciones acerca del lanzamiento de nuestra app en desarrollo.
		-Los appsettings representan proveedores de configuracion y con ellos podemos obtener datos que seran consultados por app dependiendo de app donde estemos.
		-En clase program vimos que podemos configurar middlewares y servicos.
		
Sección 3: Nuestro primer Web API
	29. Introduccion
		-Se quiere vistazo de principio a fin de elementos que intervienen a la hora de desarrollar  un webapi con asp.net core.
		-No es profunidzar en ideas sino ver etapas del ciclo de vida del desarrollo de un webapi.
		
	30. Iniciando el desarrollo del Web API
		-Se crea un webapi.
		-En VS Code se usa plantilla vacia.
		-Se llama BibliotecaAPI que tendra que ver con autores y libros.
		-Lo primero es configurar el proyecto para que sea de controladores no de minimal apis.
		-Se va a program.cs, se quita el endpoint y entre var app y builder que es el area de servicio:
		builder.Services.addControllers(); => Se agregan controladores en la app.
		-Se va al area de middlewares y se pone:
		app.MapControllers(); //cuando venga peticionj http al webapi se manda al sistema de controladores para que sea un controlador el que de respuesta a la peticion.
		Un controlador es una clase que tiene un conjunto de acciones y cada accion es ua funcion que responde a una peticion http.
		-Se crea un controlador. Se crea en el proyecto por convencion la carpeta Controllers.
		-Se crea el fichero AutoresController.cs. Se genera asi por convencion. Todo controlador acaba por la palabra Controller.
		-AutoresController tiene que hacer pensar que es un controlador que tiene que ver con autores.
		-la idea es que cualquier peticion http que tenga que ver con recurso autor, va a ser manejada por funcion o accion dentro de esta clase.
		-Se hereda de ControllerBase que es clase base que tiene funcionalidad auxiliar que permite trabajar de frma sencilla con webapi.
		-[ApiController]: Es atributo que permite indicar que este controlador se refiere a controlador de webapi. Este eprmit eautomaticamente hacer validaciones sobre data que envie el usuario,
		-[Route("")]: Se controla la ruta en la que se encuentra el controlador, es decir, a que URL tiene que ser mandada la peticion HTTP para poder llamar a una de las acciones
		 de este controlador.
		-Se va a crear una accion la cual va a responder al metodo httpget, por eso se mete como atributo. asi se tiene el controlador con su accion.
		using Microsoft.AspNetCore.Mvc;

		namespace BibliotecaAPI.Controllers
		{
			[ApiController]
			[Route("")]
			public class AutoresController: ControllerBase
			{
				[HttpGet]
				public string Get()
				{
					return "autores";
				}
			}
		}
		
		-En una app real no se mete la ruta vacia, sino "api/autores".
		
		-Imagina que ahora queires retonar un solo autor o varios y se necesita clase que represente un autor.
		-Dentro de Controller se crea la carpeta entidades. Una entidad se refiere a un recurso que tiene representacion en una bbdd. Se creara bbdd con tabla de autores.
		 Un autor representa un registro de una bbdd, se pone como una entidad.
		-Se crea carpeta Entidades dentro de Controllers. Se crea el fichero Autor.cs.
		 El required del nombre indica que para poder instanciar la clase autor, tiene que haber nombre presente. Asi garantizas que todo autor tiene un nombre.
		 Se pone required por encima de la propeidad y eso indica a asp.net core que si viene un autor, si envian autor desde un cliente, tiene que tener nombre, sino tiene nombre,
		 autor no es valido y asp.net puede rechazar la peticion.
		 
		public class Autor
		{
			public string Id { get; set; }
			[Required]
			public required string Nombre { get; set; }
		}		
			
		-[Required] esto es validacion para asp.net core y esto es de C#: public required string Nombre { get; set; }
		-Una cosa es el framework de desarrollo asp.net core y otra cosa es el lenguaje.
		 Tienen propositos diferentes.
		-Se vuelve a AutoresController y se el dice que queires reotnar un IEnumerable que es una coleccion de autores.
		-Se puede meter JSOn Viewer al navegador para ver la respuesta JSON.
	
	31. Instalando Entity Framework Core
		-Ahora se tiene una accion que devuelve data hardcodeada.
		-Se trabaja con BBDD real.
		-Se usa Entity Framework Core. E suna libreria que pone sencillo para trabajar con BBDD usando C#.
		-Se peude crear BBDD usnado C#, interactuar con ella y hacer muchas oeracioens con funcionalidades a neustro favor con codigo de C#.
		-Boton derecho en proeycto > Administrar paquetes nugget > Microsoft.EntityFrameworkCore.SqlServer.Se va a usar esto para conectar a SQL Server.
		-Este peude trabajar con difernetes mtores de bbdd como oracle, maria DB.
		-Se instala. Si fuese con dtonet cli: dotnet add package Microsoft.EntityFrameworkCore.SqlServer
		-Un paquete nugget es una libreria que se peude descaragr y permite reutilizar code. 
		-Se instala un segundo paquete: Microsoft.EntityFrameworkCore.Tools => Esto para los que usan Vsual Studio. Para otros IDEs como VS Code, Rider...se instaka el design.
		-Microsoft.EntityFrameworkCore.Tools: Este paquete lo que hace es que permite usar comandos para interactuar conEntity framework core: se peude crear ase de datos, insertar datos...
		-La de design se necesita para trabajar con bbdd relacional.
		-Tools instala or defecto Design y por eso no se instala Design.
		-Se crea el ApplicationDBContext.
		-Se crea esta carpeta y se mete esa clase.
		-Que es esto? El DB Context es la peiza central de Entity Framework Core. Es a traves de esta clase donde defino cales seran las tablas de mi BBDD.
		-Se definen otras configs como ConnectionString aunque se usa bbdd de SQL Server.
		-Es peiza central donde estan cofigs fundamentales de Entity Framework Core.
		-Se hereda de DB Context.
		-Se genera un costructor con conrtrol punto.
		-Eso permite realizar ciertas configuraciones de Entity Framework Core fuera de esta clase: el connectionstring con sql server etc que se colcoa en la clase Program.
		-Basicamente tengo que indicar que estas opciones las puedo pasar a traves del constructor de esta clase.
		-otra cosa es indicar cuales seran las tablas de BBDD. para esto prop tab DbSet<Autor> Autores...: public DbSet<Autor> Autores { get; set; }
		-Esto lo que hace es que indicas que quires que se cree una tabla en bbdd a partir de las propiedades de la clase Autor.
		-Se tiene Id y nombre y tendra estas dos cols. Id sera numero y nombre string.
		-No e snulo porque se tiene required. Se tiene autores. Es el nombre de la tabla.
		-Se crea connectionString que apunta a BBDD. Para esto se usa proveedor de configuracion como appsettings developments json.
		-Esto de connectionstring es estandar y se va a usar. Se va a SQL Management Studio para copiar y pegar el server name.
		 Integrated Security indica como nos vamos a autenticar en el servidor de BBDD. A verdadero es que se usan credenciales de  windows para autenticarme en esta instancia de SQL Server.
		 -Si se quiere user y password peus false..y se pondria User id...password....
		  TrustServerCertificate a true indica que estamos ante servidor que cnfiamos.
		  Es una maquina de desarrollo asi que se relaja. Basicamente es que no hace falat certificado valido para encriptar la conexion entre la BBDD y webapi. Esto no se hace en PROD.
		  Al publicar webapi en PROD no hay necesidad de hacer esto porque estaremos ya ante servicio en nube que tendra su certificado.
		  "ConnectionStrings": {
			  "DefaultConnection": "Server:DESKTOP-LATBQ6O\\;Database=WebAPIBibliotecaDB;Integrated Security=True;Integrated Security=True;TrustServerCertificate=True"
			},
		
		-Se va a la clase Program y se va a configurar el servicio.
		-El app debe context se coinfigura como servicio para poder reutilziar en cualquier parte de la app. Se registra el Db Context como un servicio.
		builder.Services.AddDbContext<ApplicationDbContext>(opciones => opciones.UseSqlServer("name=DefaultConnection"));
		
		-Ahi se configura el applicationdb context como un servicio y estoy configurando que usaremos sql server y le indico que el nombre del connectionString es DefaultConnection.
		-Se peude crear la BBDD y para eso se usa una migracion. Esto es un paso intermedio entre mdoificacion de tu app y la modificacion en BBDD.
		 Fuiste al DbContext y dijiste que quieres crear la tabla autores pero en code quieres ver lo que pasara en bbdd, eso es migracion. No es mas que cambios que ocurriran en bbdd pero expresados en c#.
		-Se va al package manager console que esta en Tools > Nugget PAckage Manager > package manager Console.
		-En dotnet cli el comando es: dotnet ef migrations add TablaAutores
		-Aqui en VS es Add-Migration TablaAutores. Lo segundo es el nombre de la migracion
		-En el metodo up se ve que se crea una tabla autores con sus campos y hay tabla primaria, configruada para ID.
		-Si se revierte es que hace drop table que borra tabla autores. Eso es lo que hace el emtodo down, revertir cambios.
		-Se regresa al Package manager console y se ejecuta para aplciar los cambios: Update-Database. En dotnet cli: dotnet ef database update.
		-Entity Framework lo que hace es que usa connectionString para evr si existe una db con ese nombre en ese servidor, sino existe la crea, sino la actualiza.
		-Se ve que se crea la DB, la tabla y la tabla de migraciones, se ve hsitorial de migraciones.
		
	32. Leyendo y creando recursos desde el controlador
		-Se va a crear registros. Se recibe autor a webapi por parte de cleinte y se va a usar esta data para insertar esta data en la BBDD.
		-En AutoresController, accion httppost porque esperas recibir info del cliente. Se quiere que el cliente nos mande info.
		-Se va a crear un método asincrono. La programacion asincrona sirve para trabajar de forma mas eficiente cuando se tienen operaciones I/O
		 que son oepraciones que realziamos desde nuestro sistema a sistemas externos. Se habla de webapi y bbdd.
		 la buena practica es usar programacion asincrona.
		-Se tieen que devovler Task quee s un requerimiento de la programacion asincrona.
		-En esta accion para decir que voy a recibir datos del cliente, simplemente los coloco como argumentos del metodo POST.
		[HttpPost]
		public async Task<ActionResult> Post(Autor autor) { 

		}
		
		-Se sua Entity Framework Core para insertar ese autor en la tabla de autores. Para esto se usa inyeccion de dependencias.
		-Esto se refiere a que las dependencias de esta clase pueden venir de clases externas, es decir, de la clase que invoca a AutoresController.
		-Esto se hace  a traves de servicios que hemos configrurado en neustro proeycto. En clase program se configuro applicationDbContext como un servicio.
		-Ahora se usa en AutoresController como un servicio.
		-Se crea un constructor y se le pasa por parametro ApplicationDbContext y asi obtienes una instancia del ApplicationDbContext para interactuar con base de dato.
		-Se el llama context y Control . para crear create and assign field context.
		-Se pone ctor y tab para constructor.
		-Asi se permite tener la clase ApplicationDbController como campo de la clase autores controller y asi se tiene acceso al contexto 
		 en todas las acciones de mi clase AutoresController.
		 private readonly ApplicationDbContext context;

		public AutoresController(ApplicationDbContext context)
		{
			this.context = context;
		}
		
		-Ahora se va a la peticion HTTP post.
		[HttpPost]
		public async Task<ActionResult> Post(Autor autor) {
			context.Add(autor);
		}
		
		-Esto no agrega en la tabla autores, el autor, lo que hace es que marca este objeto para que sea agregado en el futuro cuando guardemos los datos.
		-Es como que se hae una modificacion a autor como que queremos insertarlo en la tabla autores pero no lo hemos guardado. Para eso, se usa saveChanges.
		-hay que usar el operador await context.saveChangesAsync
		[HttpPost]
		public async Task<ActionResult> Post(Autor autor) {
			context.Add(autor);
			await context.SaveChangesAsync();
		}
		
		-El operador await lo que permite es lanzar esta operacion de savechanges que es mandar el query de insert para insertar la data en la tabla de autores y no quedar esperando la respuesta a esa oepracion
         sino que webapi es libre de hacer otras cosas en lo que llega esa respsuesta.
		-Esto tiene que ver con la programacion asincrona. Se usa operador await. y retun Ok;
		[HttpPost]
		public async Task<ActionResult> Post(Autor autor) {
			context.Add(autor);
			await context.SaveChangesAsync();
			return Ok();
		}
		
		-Se va a usar postman para hacer la peticion POST.
		-Se mete body, raw, json. por defecto el webapi usa el formato json para enviar datos y recibirlos.
		-WebApi espera qe el autor se lo mande en formato json y listado se mostraba en formato json en el navegador.
		-Se tiene campo nombre ye s lo que se amndará. El Id se rellena automaticamente con valor unico por SQL Server. enviar. 200 Ok.
		-Si falla es porque no esta levantada la app..
		-Si se va a la bbdd, se select 1000, y se ve que se ha insertao.
		-Se mete otro registro.
		-Nueva pestaña y se hace get. El get esta hardcodeado. Se queiren traer esos datos.
		-Se convierte el metodo.
		[HttpGet]
		//public string Get()
		public IEnumerable<Autor> Get()
		{
			return new List<Autor>
			{
				new Autor{Id = 1, Nombre = "Felipe"},
				new Autor{Id = 2, Nombre = "Claudia"}
			};

		}
		
		-A esto:
			Se mete async porque vamos a comunicarnos con bbdd y es una oepracion I/O y es buena practica usar programacion asincrona. Hay que retornar Task de algo.
			Aqui se devuelve Task de Autor. return await context.Autores.ToListAsync(). Lo ultimo es para colocar en un listado todos los autores de la tabla autores.
			Y se retorna eso hacia el cliente.
			[HttpGet]
			public async Task<IEnumerable<Autor>> Get()
			{
				return await context.Autores.ToListAsync();

			}
			
		-Se hace peticion get desde postman.
	
	33. Obteniendo un registro por Id.
		-Si enautores hubiese 100K registros, no seria viable mostrar tanta data.Por eso se eprmtie obtener un registro por su id.
		-Se va a implementar esto.
		-Para ello se hace otra peticion GET pero hay que diferenciarlo con una plantilla.
		-Se le anexa el id a la URL base. Es de tipo entero.
		 El ActionResult es el rdo de una accion. Es un tipo de dato que se peude usar como tipo de dato de salida de una accion.
		 Se peude retornar 404 o cualquier otro tipo de codigo de status HTTP o un autor.
		 se hace Get(int id) que es el que viene de la URL.
		 Se hace var autor...porque se quiere buscar el autor por id. El oeprador await porque se comnica con bbdd. 
		 FirstorDefaultAsync es el primero o el por defecto. Es el primer autor que tenga la siguiente caracteristica que su id = id
		 Sino existe devuelve autor o nulo. Si es nulo, NotFound(). Viene de Controllerbase. Es clase auxiliar que da facilidades para webapi.
		
		[HttpGet("{id:int}")] // api/autores/1
		public async Task<ActionResult<Autor>> Get(int id)
		{
			var autor =  await context.Autores.FirstOrDefaultAsync(x => x.Id == id);

			if(autor is null)
			{
				return NotFound();
			}

			return Ok(autor);

		}
		
		-Se prueba en postman: GET https://localhost:7132/api/autores/1
		
	34. Actualizando recursos
		-Se tiene a Felipe y Claudia y se queire actualizar nombre de Felipe.
		-Se representa a traves del emtodo httpput.
		-Se debe meter el id en la URl. Es para ver el autor que se quiere modificar.
		 Ese autor se pone porque se va a enviar indo en el cuerpo de la solicitud que es un autor.
		[HttpPut("{id:int}")] // api/autores/1 
		public async Task<ActionResult> Put(int id, Autor autor)
		{
			if (id != autor.Id)
			{
				return BadRequest("Los IDs deben de coincidir");
			}

			context.Update(autor);
			await context.SaveChangesAsync();
			return Ok();

		}
		
		-Se manda esto en postman:
		PUT https://localhost:7132/api/autores/1
		Cuerpo:
		{
			"id": 1,
			"Nombre": "Borja Sainz - ACTUALIZADO"
		}
		
	35. Borrando recursos
		-Metes a un autor por confusion y lo queires borrar.
		-Se usa httpdelete.
		[HttpDelete("{id:int}")] // api/autores/1 
		public async Task<ActionResult> Delete(int id)
		{
			var registrosBorrados = await context.Autores.Where(x => x.Id == id).ExecuteDeleteAsync();

			if (registrosBorrados == 0)
			{
				return NotFound();
			}

			return Ok();

		}
		
		-ExecuteDeleteAsync: retorna la cantidad regs que fueron borrados.
		-Se hace oepracion con postman.
		
	36. Creando una segunda tabla
		-Se crea la entidad libros que tiene una relacion uno a muchos con autores.
		-Eso es que aun autor le corresponden varios libros, que un autor peude escribir varios libros y un libro puede ser escrit por un unico autor.
		-Se aprende a hacer bien esta relacion para que un libro tiene autor inexsitente.
		-Se crea la clase libro:
		public class Libro
		{
			public int Id { get; set; }
			[Required]
			public required string Titulo { get; set; }
		}
		
		-Se indica que un libro tiene una relacion con tabla autores: int autoor id. Sera la llave foranea. Es una columna que representa un identificador 
		 de un registro de otra tabla. Es decir, autor.id es el id de un autor, ese AutorId siempre tiene un valor que se corresponda con un autor que exista en la tabla autores.
		 public int AutorId { get; set; }
		 
		-Se mete tambien una propeidad navegacional que es propio de entity framework y nos facilita la voda a la hora de traer la dat relacionada de una entidad.
		 Por ejemplo, tengo un libro y quiero saber el autor del libro, hay que ir a tabla autores a buscar el nombre de dicho autor y una manera facil de hacerlo 
		 es a traves de esta propiedad: public Autor? Autor { get; set; }
		
		-Es una relacion uno a muchos, a un libro le correponde un autor y a un autor varios libros.
		-Se va a la clase autor y se coloca una propeidad de navegacion que es un listado de libros. Se inicializa Listado vacio para no tener error de referencia nula si intentamos utilizar esa propeidad
		public List<Libro> Libros { get; set; } = new List<Libro>();
		
		-Se va al application db context para configurar la tabla de libros: public DbSet<Libro> Libros { get; set; }
		-Se va al package manager console para añadir nueva migracion: Add-Migration TablaLibros.
		-En constraints se ve que crea clave foranea en libros y esto obliga a que auto.id de libros se corresponda con  un id de la tabla autores y se crea indice para hacer la busqueda por autorid mas rapida.
		-Se ejecuta Update-Database.
	
	37. CRUD de Libros
		-Se crea nuevo controlador de libros. Se necesita uno nuevo porque contendra las acciones que tienen que evr con el recurso Libros.
		-Se mete estructura igual que la de autores.
		[ApiController]
		[Route("api/libros")]
		public class LibrosController : ControllerBase
		{
			private readonly ApplicationDbContext context;
			
			public LibrosController(ApplicationDbContext context) {
				this.context = context;
			}
		}
		
		-Se hace peticion httpget de libros y un libro por su id.
		-Se hace también el POST y DELETE.
		//Peticiones
		[HttpGet]
		public async Task<IEnumerable<Libro>> Get()
		{
			return await context.Libros.ToListAsync();
		}


		[HttpGet("{id:int}")] // /api/libros/1
		public async Task<ActionResult<Libro>> Get(int id)
		{
			var libro = await context.Libros.FirstOrDefaultAsync(x => x.Id == id);

			if (libro is null)
			{
				return NotFound();
			}

			return Ok(libro);
		}


		[HttpPost]
		public async Task<ActionResult> Post(Libro libro)
		{
			var existeAutor = await context.Autores.AnyAsync(x => x.Id == libro.AutorId);

			if (!existeAutor)
			{
				return BadRequest($"El autor de id {libro.AutorId} no existe");
			}

			context.Add(libro);
			await context.SaveChangesAsync();
			return Ok();
		}


		[HttpPut("{id:int}")]
		public async Task<ActionResult> Put(int id, Libro libro)
		{
			if(id != libro.Id)
			{
				return BadRequest("Los IDs deben de coincidir");
			}

			var existeAutor = await context.Autores.AnyAsync(x => x.Id == libro.AutorId);

			if (!existeAutor)
			{
				return BadRequest($"El autor de id {libro.AutorId} no existe");
			}

			context.Update(libro);
			await context.SaveChangesAsync();
			return Ok();
		}

		[HttpDelete("{id:int}")] // /api/libros/1
		public async Task<ActionResult> Delete(int id)
		{
			var registrosBorrados = await context.Libros.Where(libro => libro.Id == id).ExecuteDeleteAsync();

			if(registrosBorrados == 0)
			{
				return NotFound();
			}

			return Ok();
		}
		
		-En el post se mete si existe el autor antes de insertarlo. Anyasync se usa para obtener true or false si existe un registro que cumpla con la caracteristica de que el id = Autor.Id.
		-Para actualizar un libro tengo que asegurarme de que el autor id exista. Se mete la misma validacion que en post.
		
		-Se va a Postman y empieza con la parte de crear libros etc...
		
	38. Consultando la data relacionada
		-Se quiere consultar un libro y obtener el nombre de su autor.
		-Se monta desde postman.
		https://localhost:7132/api/libros/1
		
		-Esto aparece nulo y hay que hacer query que tome la data de la tabla de libros y la de autores.
		-Invocando una funcion se consgiue.
		-Se mete en librosController.
		-Nos metemos en la peticion get de id de libro. Se consigue poniendo el include.
		var libro = await context.Libros
			.Include(x => x.Autor)
			.FirstOrDefaultAsync(x => x.Id == id);
			
		-En postman esa peticion devovleria un error. Dice que A possible object sycle was detected. Esto es un posible ciclo de objeto fue detectado.
		-Se retorna libro y se quiere el autor ya que se recoge en la clase Libro.  Si se va a Autor hacer referencia a libro, el cual a su vez hace referencia autor, el cual
         a su vez hace referencia a libro..... hay relacion ciclica que no termina y da error el sistema y se llena el stack. 
		-Para solucionar esto:
			1) Se deben usar DTOs que son data transfer object.
			2) Solucion simple: Ignorar el ciclo detectado y no des error, da respuesta.
			   Se va a clase program y en los controller se añade el serializador de json que es el que daba error.
				builder.Services.AddControllers().AddJsonOptions(opciones => 
				opciones.JsonSerializerOptions.ReferenceHandler = ReferenceHandler.IgnoreCycles);
		-Se obtiene esto en postamn:
		{
			"id": 1,
			"titulo": "Libro 1",
			"autorId": 3,
			"autor": {
				"id": 3,
				"nombre": "Borja Sainz",
				"libros": [
					null
				]
			}
		}
		
		-Ahora se quiere que cuando obtengas autor, obtener sus libros. Esto va por autores.
		-Se va a AutoresController, solicitud httpget por id.
		-Se mete el include:
		var autor =  await context.Autores
			.Include(x => x.Libros)
			.FirstOrDefaultAsync(x => x.Id == id);
		
		-Se peuden traer libros porque se configuro esa propiedad de navegacion y eso es lo que eprmite con una sola linea de codigo traer la data relacionada.
	
	39. Resumen
		-Se hizo un webapi para tener vision general de algunos de los elementos envueltos en este 
		-Se configuro entity framework core para crear la bbdd a partir de codigo de C#.
		-Se hizo crud para permitir la manipulacion de recursos. 
		-Se vio que es bien directo consultar data relacionada usando entity framework core.
	
	
	
Sección 4: Fundamentos de ASP.NET Core y Web API
	40. Introducción al Módulo 4
		-Se dio vistazo de construccion de webapi en video anterior, ahora se va a profundizar en conceptos. se ven fundametnos de asp.net core y webapi.
	
	41. Controladores y acciones
		-La idea de tener webapi es que tendremos clienets que haran peticiones http a webapi.
		-Esas epticiones se hace a un conjunto de urls de nuestro dominios. A estas urls les llamamos rutas de nuestro webapi.
		-En estas rutas se recibe un recurso: miapi.com/autores: miapi.com seria el dominio y /autores es algun recurso relacionado con autores.
		-Normalmente, Se llama ruta a los segmentos de URL posterior al dominio, sin necesidad de mencionar todo el dominio.
		-Es decir, decimos que esta ruta es /autores.
		-Cuando se hace peticion http a ruta de nuestro webapi, tipicamente se quiere que se ejecute funcion de un controlador que se le llama accion aunque
		 tambien puede llamrse endpoint. Entonces, una accion es una funcion de un controlador que se ejecuta en respuesta a peticion http realizada a nuestra webapi.
		 Mientras que un controlador es una clase que agrupa un cjto de acciones tipicamente un controlador agrupa acciones que se relacionan con un 
		 recurso. Asi en el caso de ruta /autores, es posible que se tenga unico controlador que maneja acciones relacionadas con el recurso autores.
		 Por convencion, los contrlladores senombran concatenando una palabra como nombre de un recurso cpon palabra Controller. Asi un controlador de autores se peude llamar AutoresController.
		 Estos contrladores por convencion se colocan en una carpeta llamada Controllers.
		-Como ya se vio, se pueden usar metodos http sobre un recurso para manipularlo.
		-En asp.net eso significa que podemos configurar que accion queremos que se ejecute segun la ruta y el emtodo http usado por usuario.
	
	42. Explorando nuestro controlador
		-se tiene AutoresController. Algo tipico de cualquier controlador que no es obligatorio pero si recomendado es heredar de ControllerBase.
		-ControllerBase es una clase base que tiene un conjunto de elementos auxiliares que nos hace la vida más fácil a la hora de hacer webapis.
		-Se decora controlador con atributo ROute que se define la ruta de nuestro controlador,e s decir, la ruta a la que hay que hacerle peticiones HTTP para interactuar con acciones del controlador.
		-A veces, se pone [Route("api/[controller]")]. Esto es un placeholder que se va a sustituir por autores.
		-Es una forma de poner una variable que va a ser sustituida por el nombre del prefijo del nombre del controladores, autores.
		-Si cambia el nombre del controlador, cambia la ruta y peude haber clientes que dependen de esa ruta.
		-Felipe prefiere ser explicito y poner autores mejor que eso.
		-El atributo ApiController nos ayuda a configurar el controlador como un controlador de webapi. Es importante porque cuando se hable de validaciones, este apicontroller
		 permite que una accion a la que se le intente ingresar data incorrecta, devuelve de una vez el error, es decir, devuelve un error al cliente, un error 400 indicando reglas de validacion 
		 que no ha cumplido.
		-Se tiene n acciones: [HttpGet]. Puede haber acciones que respondan al mismo método pero se diferencian en que se pasan parametros. A lo del id se le llama plantilla.
		-Se tienen otras peticiones como [HttpPut].
		-Se puede hacer otra accion que reotrne por ejemplo el primer autor de BBDD.
		-Saltara este error: AmbiguousMatchException: The request matched multiple endpoints. Matches:
		-La peticion puede ser respondida or multiples endpoints. Los dos metodos pueden responder a la misma peticion. las dos responde al mismo metodo y misma ruta.
		 Hay que usar plantilla para hacer una combinacion y que haya diferencia en ruta entre una accion y otra: api/autores/primero
	
	43. Reglas de ruteo
		-Permiten mapear una URL con una accion. Es decir, cuando hacemos peticion http a una ruta, se quiere ejecutar una accion.
		 Para hacer configuraciones de ruteo se hace desde los controladores (ruteo por atributo) o se hace desde la clase program que se hace en MVC.
		-Aqui se va a usar el ruteo por atributo que es lo que se hace en webapi.
		-Con el route se define la ruta a traves de la cual se puede interactuar con un controlador.
		-Se ve "api/autores/. Esa configuracion hecha a nivel de controlador, la heredan todas las acciones del controlador.
		-Para interactuar con una accion se hace un GET hacia una ruta, igual POST etc...
		-Se puede hacer tb una oepracion de combinacion como ya se vio. Asi permite personalizar la ruta de una accion y diferenciar una accion de otra para evitar error de antes.
		-Se puede ignorar la ruta de api/autores.
		-Si se quiere dar una ruta personalizada a la accion de HttpGet y que ignore la ruta de route del controlador, se pone: [HttpGet("listado-de-autores"). Se ignora la peticion GET a esa ruta y saldra
		 un 405. method not allowed.
		-Se puede poner /listado-de-autores y funciona
		-Se pueden definir varias rutas para una misma accion:
		[HttpGet("/lista-de-autores")]
		[HttpGet]
		
		-Se pueden definir valores en una plantilla para buscar por ejemplo un autor por un id: [HttpGet("{id:int}")]
		-Se pueden definir varios parámetros de ruta.
		
		-Se puede hacer esto para apsar una URL y que en el apremtro1 y 2 metas lo que quieras.
		[HttpGet("{parametro1}/{parametro2}")]// api/autores/felipe/gavilan
		public ActionResult Get(string parametro1, string parametro2)
		{
			return Ok(new { parametro1, parametro2 });
		}
		
		-Si se quiere que uno de los parametros sea opcional:
		[HttpGet("{parametro1}/{parametro2}")]// api/autores/felipe/gavilan
		public ActionResult Get(string parametro1, string parametro2)
		{
			return Ok(new { parametro1, parametro2 });
		}
		
	44. Restricciones de ruta
		-Los parametros de ruta permiten definir variabels a nivel de URl que permite mayor libertad a la hora de configurar las rutas de las acciones.
		-Se ha visto que se puede colocar tipos de dato a los parametros de ruta.
		-Con el tipo de dato se restricciona mas la URL.
		-Se mete ruta por nombre.String no es tipo de dato, habría que meter alpha. Esto se llama restriccion de la variable de ruta.
		[HttpGet("{nombre:alpha})"]
		public async Task<IEnumerable<Autor>> Get(string nombre)
		{
			return await context.Autores.Where(x => x.Nombre.Contains(nombre)).ToListAsync();
		}
		
		-Se meten breakpoints. Uno en este public y otro en la petición GET ([HttpGet("{id:int}")]).
		-Se va al navegador y se ejecuta el code.
		
	45. Tipos de dato de retorno
		-Desde una accion se peude retornar un tipo especifico, ActionResult<T>, ActionResult o IActionResult.
		-ActionResult es una clase que representa todos los tipos de dato que se pueden retornar desde una accion.
		-Hay clases derivadas de ActionResult las cuales se peuden usar que se quiere retornar un tipo de dato especifico. Si se tiene una accion que siempre 
		 va a retornar un CreatedAtRowResult pues ese puede ser el tipo de dato retorno de la accion.
		-Esto es un tipo de dato retorno que representa que un recurso ha sido creeado como cuandos e crea libro o autor.
		-En lugar de usar ActionResult, se peude usar ActionResult<T>
		
		Tipo Especifico
		-Se usa cuando se retorna un tipo de dato cualquier, ya sea un string, objeto complejo o lo que sea.
		-public async Task<IEnumerable<Autor>> Get()
		 {....}
		-Se usa para acciones simples se puede usar pero el problema es que las acciones pierden versatilidad.
		
		ActionResult<T>
		-Si se tiene un método o accion que recibe un id y se quiere retornar autor al que le corresponde el ID o 404 si el autor no existe.
		-De una accion como esta no se puede decir que se quiere retornar un tipo especifico. Se tiene que usar otra opcion como ActionResult<T>
		-Permite retornar tipo especifico o ActionResult: Task<ActionResult<Autor>>.
		-Retornar 404 es retorar un StatusCodeResult que ehreda de ActionResult con codigo de Status = 404.
		-Se recibe id, buscamos autor, si es nulo se devuelve Not found, sino se devuelve el autor. Para esta versatilidad el tipo de dato de respuesta es ActionResult<T>.
		-En este caso T es Autor. Por tanto se retorna ActionResult<T>.
		-Como se esta ante metodo asincrono porque se esta con operacion I/O es buena practica usar programacion asincrona, se retorna Task<ActionResult<Autor>>
		
		IActionResult
		-Es parecido a ActionResult<T>, solo que IActionResult solo permite retornar IActionResult.
		-Si quieres retornar un tipo especifico de una accion que retorne un ActionResult, debes usar funcion Ok.
		-Se podria resultar lo que sea pero hay que devovlerlo en un Ok para poder retornarlo. Es mejor usar ActionResult<T>.
		
	46. Programación Asíncrona
		-Imagina que pides pizza por tfno para que te la entreguen en casa, te dicen que tarda 30 mins.
		-Que haces en esos 30 mins? Esperas hasta que llegue o haces otras cosas? Pues haces otras cosa mientras llega pizza.
		-Algo similar pasa cuando se usa funcion asincrona.
		-Se permite que mientras esa funcion se ejecute, nuestro servidor web en vez de quedarse esperando a que termine, mejor que se ponga a hacer otras tareas mientras la funcion se eejcuta.
		-No siempre todas las tareas se quieren hacer asincronas ya que en programacion hacer accion asincrona tiene coste de rendimiento.
		-Se recomienda en general utilizar programacion asincrona cuando se vayan a hacer oepraciones I/O.
		-Estas operaciones donde I/O es input-output son operaciones en las que nuestro software se comunica con otros sistemas. por ejemplo, si invocamos un webservice estamos haciendo operacion I/O
		 o si nos comunicamos con la BBDD.
		-La razon es simple.Dado que son sistemas externos, estos no consumen nuestrosrecuross. En vez de frisar la app, mejor liberar nuestra app para que pueda hacer otras tareas mientras el sistema externo trabaja.
		-Ya cuando el sistema externo termine, pues nos avisara y entonces se atiende al llamado.
		-Para hacer metodo asincrono, hay que usar async. Esto nos habilita para usar el oeprador await que sirve para hacer una espera asincrona.
		-No cnfundir espera. No es que se frisa. La espera es para decirle a la app que puede hacer otras cosas mientras el sistema responde.
		-Cuando sistema externo responda, se continua con ejecucion del metodo. El if(autor is null) se ejecuta cuando se finaliza la llamada a BBDD.
		-Cuando se usa async es como si se pusiese en pausa la ejecucion del metodo GET.
		-Cuando se usa programacion asincrona no podemos retornar un tipo de dato cualquiera.
		-Se debe usar una de cuatro acciones: Task, Task<t>, ValueTask, ValueTask<T>.
		-La palabra task es tarea y la diea es que emtodo asincrono representa tarea que sera ejecutada y en el futuro terminara.
		 Cuando? No se sabe porque eso ya depende en cuanto tarden los sistemas externos en respondernos.
		-Se usa Task y valueTask para configurar el tipo de dato de retorno de un emtodo asincrono.
		-Hasta ahora se ha visto Task<T> donde T es cualquier tipo de dato.
		-Por ejemplo, Task<IEnumerable<Autor>>. T es lo de dentro de Task.
		-Se tiene liberatd lo que se peude devolver de un metodo asincrono: numero, string, clase....siemrpe que se diga Task de eso.
		-Task se usa cuando tenemos un metodo asincrono que no tiene valor de retorno. Es decir, cuando no se use return.
		-Es la version asincrona deu metodo void.
		-Se puede crear autor y no devolver nada.
		
		ValueTask Y ValueTask<T>
		-Son tipos de valor y se suelen usar cuando tenemos escenarios en los cuales a veces peuden ser sincronos y a veces asincronos.
		
	47. Introducción al Model Binding
		-permite mapear datos de una petición http a parametros de una accion. Esto cubre todo tipo de params: numeros, booleanos, strings, arreglos, listas, clases de proyecto....
		-Ya se ha visto forma de mandar info a los params de una accion.
		-Se hizo usando parametros de ruta: [HttpGet("{id:int}")]
		-La idea es que a traves de la URL vamos a recibir un valor y se va a colocar en el parametro de la accion que se tiene.
		-Esos valores pueden venir de diferentes fuentes, las cuales, se pueden indicar como atributos.
		-En el caso de id, ASP.NET es inteligente para ver que se tiene el id en httpget y se va a corresponde a lo que tengo de id en public async Task<ActionResult<Autor>> Get(int id)...
		-No se tiene que indicar que va a venir de una vble de ruta o de parametro de ruta.
		-Si quiero indicar que la fuente de datos es la ruta: Get([FromRo]int id)
		-Otra forma es incluir QueryStrings. Se tiene un include para incluir los libros (.Include(x => x.Libros)). Si se quiere incluir un parámetro que indique si quiero incluir o no los libros, se haria asi:
		bool incluirLibros (Cliente puede decir verdadero o falso para ver si incluir o no lo libros).
		-Ese incluirLibros se quiere que venga de un QueryString que es un conjunto de valores que se puede incluir en la URL
		 de la siguiente forma: api/autores/id?llave=valor1&llave2=valor2....Se tiene dos queryStrings llave1 y llave2
		[HttpGet("{id:int}")] // api/autores/id?incluirLibros=true|false
		public async Task<ActionResult<Autor>> Get(int id, bool incluirLibros)
		{
			var autor = await context.Autores
				.Include(x => x.Libros)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (autor is null)
			{
				return NotFound();
			}

			return Ok(autor);
		}
		
		-Para indicar que se quiere obtener ese valor de incluirLibros se hace asi: [FromQuery] bool incluirLibros.
		-Otra forma de hacer Model Binding esa traves del cuerpo de la peticion http.
		-Para crear un autor en la peticion de POST se usaba el body desde postman.
		-Se le emtia body > raw > JSON y se colocaba el nombre del usuario. Se está usando el cuerpo de la peticion para rellenar 
		-Cuando se esta en un post se usa el cuerpo de la peticion para rellenar la data del autor.
		-En un get se usa o la URL  a traves de parametro de ruta o a traves de queryStrings.
		-Asi en la petición POST se puede indicar esto: [FromBody] Autor autor
		-Otra fuente de datos que se puede usar es la cabecera de la petición.
		-Las cabeceras son metadatos que podemos enviar o recibir en el contexto de una peticion HTTP.
		-Imagina que el parametro de incluirLibros lo quieres obtener de una cabecera, pues se pone: [FromHeader] bool incluirLibros
		
		-Poniendo la URL en el navegador no devuelve nada.
		-Se va a hacer la eptición GET desde postman: https:localhost:puerto/api/autores/1
		-se va a Headers y se añade una llave y valor: incluirLibros:true.
		-Otra fuente que se verá es el FromForm para recibir ficheros de webapi: foto de una autor.
		
	48. Validaciones por defecto
		-Se va a hablar de validaciones de modelos.
		-Se tienen reglas de negocio las cuales se quiere que datos que mandan los cleintes sigan.
		-Se tiene clase autor, unautor tiene un nombre y no se quiere que se cree autor sin nombre por eso se puso el atbto required.
		-El atributo ApiController si en una accion como post se manda una peticion post y ese autor no tiene nombre, se va a retornar un 400 Bad Request indicando el error.
		-Se puede ir a postman: api/autores y se va a mandar dato de nombre vacio.
		-Devuelve esto con 400 Bad Request y el problemDetails que es un objeto que representa la respuesta de una peticion problmeatica :
		"status": 400
		"errors": {
			"Nombre": [
				"The Nombre field is required."
			]
		},
		
		-El arreglo dentro de errores > nombre representa los distintos errores que tiene dicho campo.
		-En el required del campo nombre de la clase Autor se puede poner esto: [Required(ErrorMessage = "El campo nombre es requerido")]
		-Para no hardcodear el nombre del campo, se pone un placeholder: [Required(ErrorMessage = "El campo {0} es requerido")]
		 
	49. Otras validaciones por defecto
		-Se va a colocar otro atributo para hacer otra validacion: StringLength para que el campo nombre no pase de X caracteres.
		-Se puede añadir Errormessage para personalizar el error: [StringLength(10, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")], donde 1 indica la longitud que debe cumplir el string.
		-Se va a añadir otras reglas de validación.
		-Para ello, se arreglan otras propeidades.
		public int Edad { get; set; }
		public string? TarjetaCredito { get; set; }
		public string? URL { get; set; }
		
		-Persona se pondra que estara en un rango: [Range(8,120)]
		-[CreditCard]: Esto valida el formato de una tarjeta de credito.
		-[Url]: Que tenga la estructura de URL el string que nos pasan
		
		-Se manda una peticion post a: https://localhost:7132/api/autores
		-Se manda en el body:
		{
			"Nombre": "",
			"edad": 128,
			"tarjetaCredito": "123",
			"url": "abc"
		}
		
		-Eso nos sacará error de nombre.
		-Relamente, no se pude crear una persona ya que estamos agregando unos campos que noe stan en bbdd...:habria que crear una migracion agregar esas cols para poder crear autor. Era ejemplo. se deja comentado.
		public class Autor
		{
			public int Id { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			public required string Nombre { get; set; }
			public List<Libro> Libros { get; set; } = new List<Libro>();

			//[Range(8,120)]
			//public int Edad { get; set; }

			//[CreditCard]
			//public string? TarjetaCredito { get; set; }

			//[Url]
			//public string? URL { get; set; }
		}
		
		
	50. Validaciones Personsalizadas por atributo
		-No estamos limitados a solamente usar validaciones predefinidas por el framework. Se pueden usar tambien validaciones persoanlizadas.
		-En el caso de autor que primera letra sea mayus. No hay un atributo que se pueda usar pero se puede hacer uno.
		-La idea de hacer un atributo es poder esa logica en otros lados, por ejemplo, en libros.
		-Se crea.
		-Click derecho en proyecto y se crea nueva carpeta que se llame Validaciones. Se agrega clase: PrimeraLetraMayusculaAttribute.cs.
		-En C# cuando clase va a ser usada como atributo, su nombre termine en Attribute.
		-La clase base es ValidationAttribute para usarla como atroibuto de validacion.
		-Se pone lo siguiente. El values es cualquier valor que intentemos asignarle al campo nombre de la clase Autor.
		 Se valida y se pone que si el valor es nulo o vacio como un espacio en blanco, se queire retornar exito porque la validacion verifica que la primera letra sea mayus
		 Se encarga de verificar si el valor es nulo o no.
		 Se tiene ya required en la clase y para poder mantenerme en lo mio, 
		 Es decir, digo si es nulo, lo retorno exitoso y que diga ya required si esta bien o no.
		 Ahora si se tiene un valor asignado que no es nulo,se obtiene la primera letra del value, se hace toString porque es un objeto.
		 Se pone value.toString()! porque se sabe que no va a ser nulo porque se ha hecho la validacion.
		 Luego se valida que la primera letra sea mayus.
		 Asi se retorna el error de validacion de un atributo.
		 public class PrimeraLetraMayusculaAttribute : ValidationAttribute
		{
			protected override ValidationResult? IsValid(object? value, ValidationContext validationContext)
			{
				if(value is null || string.IsNullOrEmpty(value.ToString()))
				{
					return ValidationResult.Success;
				}

				var valueString = value.ToString()!;
				var primeraLetra = valueString[0].ToString();

				if (primeraLetra != primeraLetra.ToUpper())
				{
					return new ValidationResult("La primera letra debe ser mayúsucula");
				}

				return ValidationResult.Success;

			}
		}
		
		
		-Asi se va a la clase Autor y se pone ese atributo.
		[Required(ErrorMessage = "El campo nombre es requerido")]
		[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
		[PrimeraLetraMayuscula]
		public required string Nombre { get; set; }....
		
		-Se hace una prueba desde Postman...
		-Se pueden probar las dos validaciones.
		
	51. Validaciones Personalziadas por Modelo
		-En la clase se pueden hacer validaciones personalziadas que peude ser útil si se involucra  varias propiedades
		-Por ejemplo una validacion que fuese que quieres primera letra mayus si el campo edad esta entre 30 y 40.
		-Eso puede no tener sentido pero es poderoso realziar una validacion usando la validacion por modelo.
		-Se va a reusar la validacion que habiamos hecho pero para modelo.
		-Se va a comentar  // [PrimeraLetraMayuscula]
		-Se hereda de interfaz IValidatableObject y se implementa el método Validate.
		-Se puede retornar un IEnumerable que permite retornar varios ValidationResult.
		-Sino se retorna ningun error de validaciopn es porque no ha habido errores y eso es que modelo es valido.
		-Se hace yield return que en C# permite ir construyendo linea por linea el IEnumerable que es una coleccion de ValidationResult.
		-COn el el new string se pasan los campos a los que se hace referencia que ha habido el error.
		-nameOf(Nombre), permite obtener una representacion en string de ese Nombre. Es equivalente a {"Nombre"}.
		-Es mejor poner nameof porque si te vas al string y haces control R, Control R lo puedes reemplazar facil si el dia de mañana cambia el nombre.
		public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
		{
			if (!string.IsNullOrEmpty(Nombre))
			{
				var primeraLetra = Nombre[0].ToString();

				if (primeraLetra != primeraLetra.ToUpper())
				{
					yield return new ValidationResult("La primera letra debe ser mayúscula - por modelo", new string[] { nameof(Nombre) });
				}
			}
		}
		
		-Se va a postman y se prueba.
		-Las validaciones por modelo solamente se ejecutan posterior a la ejecución de las validaciones por atributo.
		-Solamente si son exitosas.
		-Si hay error de validacion por atributo, la validacion por modelo no se ejecuta.
		-La ventaja de la validacion por modelo es que se tiene acceso al modelo completo.
		-Se puede hacer combinacion de valicaciones de varios campos de validacion if (primeraLetra != primeraLetra.ToUpper() && Edad > 40).
		-No es tan viable en caso de un atributo ya qe la idea de atributo es usar la propiedad a la que le fue asignada el atributo.
		-La ventaja de validacion por atributo es que puedo reutilziarla.
		-Se puede reusar en libro tambien por ejemeplo.
		
	52. Validando desde el Controlador - Validando contra la BD
		-Se vaa  validar en una peticion post a la hora de crear un libro, si el autor que nos mandan existe.
		-Se habia recogido una validacion pero que no gusta.
		-Un error de validacion tipico es problemDetails que es detalle de problema. Se quiere que la validacion que se retorne tenga mismo formato porque ahora se tiene simple string.
		-Para poder hacer esto, primero se va a modificar el ModelState.
		-Este permite tener uno objeto en el cual podemos colocar los errores del cliente enesta peticion http.
		-ModelState.AddModelError()
		[HttpPost]
		public async Task<ActionResult> Post(Libro libro)
		{
			var existeAutor = await context.Autores.AnyAsync(x => x.Id == libro.AutorId);

			if (!existeAutor)
			{
				ModelState.AddModelError(nameof(libro.AutorId), $"El autor de id {libro.AutorId} no existe");
				return ValidationProblem();
				// return BadRequest($"El autor de id {libro.AutorId} no existe");
			}

			context.Add(libro);
			await context.SaveChangesAsync();
			return Ok();
		}
		
		-Se prueba postman: https://localhost:7132/api/libros
		Body:
		{
			"titulo": "Libro Borrar",
			"autorId": 1123
		}
		
	53. Inyección de Dependencias y Acoplamiento
		-Las clases de nuestra app raramente son completamente autosuficientes y es normal separar responsabilidades entre diferenets clases.
		-Lo mismo sucede con controladores. Un controlador contiene conjunto de acciones por lo que responsabilidad del controlador es recibir peticiones HTTP hechas a nuestra webapi.
		 y coordinar el procesamiento de dicha solicitud.
		-Sin embargo, un controlador no debe tener la responsabilidad de mantener registros en una bbdd, ni de escribir mensajes en consola, ni calcular la inversa de una matriz...
		-Esas tareas han de ser delegadas a otras clases.
		-Cuando una clase A usa una clase B, decimos B es dependencia de la clase A. las dependencias son inevitables y han sido estudiadas en software. Se usa untermino para evaluarlas: acoplamiento.
		-Acopamiento puede ser fuerte o debil. El fuerte se caracteriza por una dependencia no flexible de otras clases.
		-No es bueno el acoplamiento fuerte.
		-En AutoresController se ve dependencia de ApplicationDbContext porque se esta usando.
		-Como clase AutoresController usa la clase ApplicationDbContext, esta dependen de AutoresController. 
		-Esta relacion no es muy flexible porque estas obligado a usar ApplicationDbContext para poder instanciar AutoresController.
		-No se puede usar otra clase.
		-Aqui hay acoplamiento fuerte. Esto es bueno o malo? Ya se vera en EF que es un caso especial.
		-Se vera ejemplo y se va a ver ejemplo de acoplamiento entre clases antes de abordar algo mas complejo como es EF Core.
		-Se va a crear un controlador temporal.
		-Se llamará ValoresController.
		-Es un controlador de pruebas.
		-Se quiere simular caso de pruebas.Se va a retornar un listado de valores.
		
		-Se crea la clase Valor dentro de Entidades. Se pone required para no tener esa advertencia de que el atributo que no acepta nulos, debe tener un valor distinto de nulo...
		public class Valor
		{
			public int Id { get; set; }
			public required string Nombre { get; set; }
		}
		
		-Controlador:
		[ApiController]
		[Route("api/valores")]
		public class ValoresController : ControllerBase
		{
			[HttpGet]
			public IEnumerable<Valor> Get()
			{
				return new List<Valor>
				{
					new Valor{Id = 1, Nombre = "Valor 1" },
					new Valor{Id = 2, Nombre = "Valor 2" }
				};
			}
			
		}
		
		-Controlador es sencillo pero tiene muchas responsabilidades como la de crear un listado de valores para luego devolverlño.
		-En AutoresController se iba a BBDD y se devolvia. Aqui algo parecido. Se debe crear clase que se encargue de obtener ese listado.
		-Se va al proyecto y se crea RepositorioValores. En software cuando se habal de una clase repostorio se encarga de abstraer la logica
		 para concetarnos a BBDD y obtener informacion.
		-Es clase que oculta detalle de implementacion que involucra comunicar con BBDD, ahcer una query, obtener data etc.
		-Asi que no se tenga todo ese codigo para conectarse a BBDD de Oracle SQl Server en controlador, sino que se mete en una clase que se pueda reutilziar y a eso se llama repositorio.
		public class RepositorioValores
		{
			public IEnumerable<Valor> ObtenerValores()
			{
				return new List<Valor>
				{
					new Valor{Id = 1, Nombre = "Valor 1" },
					new Valor{Id = 2, Nombre = "Valor 2" }
				};
			}
		}
		
		-Lo anterior del controlador, se sustituye por esto. Se delega la reponsabilidad de obtener valores en el repositorioValores y no esta harcodeada en el controlador.
		 [ApiController]
		 [Route("api/valores")]
		 public class ValoresController : ControllerBase
		 {
			 [HttpGet]
			 public IEnumerable<Valor> Get()
			 {
				 var repositorioValores = new RepositorioValores();

				 //return new List<Valor>
				 //{
				 //    new Valor{Id = 1, Nombre = "Valor 1" },
				 //    new Valor{Id = 2, Nombre = "Valor 2" }
				 //};

				 return repositorioValores.ObtenerValores();
			 }
		 }
		 
		-Aun asi hay acoplamiento fuerte porque cuando se usa valoresController estas obligado a usar RepositorioValores.
		-Si ahora te tienes que conectara  unwebapi dia de mañana:
		// var repositorioValores = new RepositorioValores();
		var repositorioValores = new RepositorioValoresWebAPI();?? No esta bien. Esa inflexibilidad, implica que para responder a un cambio de negocio,
		tenga que venir a ValoresController a modificar codigo....
		-El acoplamiento débil se da con el mecanismo de inyeccion de dependencias. Es facil cuando se pueden intercambiar depdendencias de forma sencilla.
		-La inyeccion de dependencias es un mecanismo mediante el cual las dependencias de un objeto son suministradas por otro objeto.
		-Se transforma lo anterior a esto:
		public class ValoresController : ControllerBase
		{
			private readonly RepositorioValores repositorioValores;

			public ValoresController(RepositorioValores repositorioValores)
			{
				this.repositorioValores = repositorioValores;
			}

			//Dependencia débil
			[HttpGet]
			public IEnumerable<Valor> Get()
			{   
				return repositorioValores.ObtenerValores();
			}
		}
		
		-La responsabilidad de instanciar ValoresController se le ha dado a quien esta llamando a ValoreController.
		-Se va a Program y se hace var ValoresController = new ValoresController(). Se tiene responsabilidad de pasarle RepositorioValores
		 y se puede configurar como se quiera. Ahora se peude controlar la instancia de esa dependecnai que tiene ValroesController.
		 que es RepositoriValores. Ahora para oder instanciar ValroesController, tengo que pasarle RepositorioValores pero
		 hay que configrar esa clase como un servicio. En ASP.NET Core cuando se habla de servicio se refiere a que cuando 
		 se solicita tipo, en este caso RepositorioValores, a traves de ctor, se sirva instancia de RepositorioValores.
		 Es decir, servicios se encragand e cosntruir las dependencias de nuestras clases. 
		 Para configurar servicios se va a Program y se hace esto: builder.Services.AddTransient<RepositorioValores>();
		
		-Con eso, se le dice a ASP.NET Core que el dia que haya una clase como ValoreController que tenga deendencia de RepositorioValores,
		 pues que puede inyectar instancia de dicha clase para poder usarla.
		 
	54. Utilizando el Principio de Inversión de Dependencias
		-Ya se esta usando la imnyeccion de dependencias en ValoresController porque se esta obteniendo su dependencias RepositorioValoresç
		 a traves del constructor. Esto se hace para tener mas flexibilidad. Pero parece que no se tiene gran ganancia. Parece
		 que es lo unico que se puede usar en ValoresController.
		-Por ahora, no se esta aplicando el principio de inversion de dependencias.
		-Este principio establece que nuestras clases deben depender de abstracciones y no de tipos concretos.
		-RepositorioValores es un tipo conceto.
		-Un ejemplo de abtsraccion es una clase abstracta o interfaz. Si se quiere tener la flexibilidad de querer cambiar
		 la dependencia de ValoresController, hay que depender de la abstraccion para que asi en tiempo de ejecucion se pueda hacer el intercambio.
		-En vez de depender de RepositorioValores se va a crear una interfaz de la que se va a depender.
		-En BibliotecaAPI se crea una clase IRepositorioValores.
		-Una interfaz lo que hace es establecer contrato en la que cualquer clase que imlemente dicha interfaz, tiene que implementar
		 dicho contrato. A traves de la interfaz, se colocan las signaturas que cualquier clase que implemnete la interfaz tiene que implementar.
		-La signatura es el tipo de dato de salida, nombre del metodo y parametos.
		-En la interfaz no esta la implmenetacion. Solo se indica que cualquier clase que vaya a interfaz esa iinterfaz, tiene que implementar un metodo con esa signatura.
		public interface IRepositorioValores
		{
			public IEnumerable<Valor> ObtenerValores();
		}
		
		-Para implementar interfaz, se va a la clase, : NombreInterfaz.
		-Ahora en lugar de depender de RepositorioValores, se depende de IRepositorioValores.
		private readonly RepositorioValores repositorioValores;
		Se cambia por: private readonly IRepositorioValores repositorioValores;.
		
		-Se depende de la interfaz o se establece el principio de inversion de dependencias porque asi vas a deepnder de una abstraccion
		-El tema de la interfaz es que no se sabe qué clase van a apsar por public ValoresController(IRepositorioValores repositorioValores)
		-Puede ser que sea RepositorioValores y mañana puede ser RepositorioValoresSQL, RepositorioValoresOracle.
		-Eso te da igual lo unico que interesa es que la clase que te vayan a pasar por ahi, implemente ObtenerValores.
		-Interfaz dice que cualquier clase que implmenete la interfaz IRepositorioValores, tiene que tener un metodo que tenga ObtenerValores.
		-Ahora en ValoresController es que la dependencia es una abstraccion.
		-Hay que ir a la clase program para decir que en el AddTrasient, donde dices que configruas RepositrioValores como un servicio, ahora se indica que el  servicio es 
		 IRespositorioValores, RepostorioVAlores. Es decir, se le dice a ASP.NET Core que cuando se vea que alguien necesita el servicio IrepositorioValores,
		 le sirva la instancia RepositorioValores.
		 Se cambia: builder.Services.AddTransient<RepositorioValores>();
		 Por: builder.Services.AddTransient<IRepositorioValores, RepositorioValores>();
		
		-En ValoreController, aunqque dice IRepositorioValores, en tiempo de ejecución se le va a srvir el RepositorioValores.
		-Ahora ya hay una relación de acoplamiento muy bajo, es muy flexible.
		-Ahora hay nuevo requerimiento y es que se necesita un repositoriode valores que busque los valores de una bbdd de Oracle.
		-Se crea clase RepositorioValoresOracle que implemente IRepositorioValores que obliga que la clase implmente un metodo con esa signaturaç
		-Hasta que no se hace, eso ni compila.
		-Control + Punto sobre la interfaz para implementarla.
		-Se retorna new List<Valor>. Se supone que viene de Oracle.
		public class RepositorioValoresOracle : IRepositorioValores
		{
			public IEnumerable<Valor> ObtenerValores()
			{
				return new List<Valor> {
					new Valor{Id=3, Nombre="Valor Oracle 1"},
					new Valor{Id=4, Nombre="Valor Oracle 2"},
					new Valor{Id=5, Nombre="Valor Oracle 3"},
				};
			}
		}
		
		-Se quiere que en ValoresController se utilice ese RepositorioValoresOracle.
		-No se tiene que ir a ValoreController a hacer ningun cambio.
		-Como se esta aplicando el principio de inversion de dependencias y se depende de una abstraccion y tipo concreto, se puede desde la clase Program, cambiar la implementacion
		que se esta usando y poner builder.Services.AddTransient<IRepositorioValores, RepositorioValoresOracle>();. Asi consigues que en ValoresController se use 
		la implementacion de oracle. Eso parece sencillo en proyecto pequeño como tenemos.
		En proyecto grande con decenas o cientos de clases que dependan de IRepositorioValores y con hacer cambio en simple linea de cambio se propague 
		por aplicacion y se haya hecho el cambio de 50 o 100 clases.
		-Lanzar y probar: https://localhost:7132/api/valores
	
	55. Servicios en ASP.NET Core
		-Se va a hablar de los tiempos de vida de los servicio. Hay 3: Trasnient, Scope y Singleton.
		-Transient: es el de menor tiempo de vida. Cuando un servicioe s marcado como Transient, cada vez que se solicita instancia de dicho servicio, esta instancia 
		 será totalmente nueva. Se sua cuando no hay estado compartido, es decir, cuando clase no tiene campos que se quieran compartir entre instancias
		-Scoped: Es cuando se crea instancia unica por peticion HTTP. No importa cuantas veces se solciite el servicio, siempre que sea dentro del mismo 
		 contexto http , sera entregada la misma instancia de la clase. Util cuando se queira preservar estado dentro de la solicitud HTTP.
		-Singleton: Ua unica instancia dels ervicio durante la vida de la app. No imporota cuantas veces se solitie el servicio, siempre se entrega la misma instancia aunque sea a usuarios distintos.
		 Es util cuando se quiere tener un estado global como por ejemplo una capa de chae.
	
	56. Ejemplo de Tiempo de Vida de los Servicios
		-Se va a crear un ejemplo que permita visualziar la diferencia entre cada uno de los tiempos de vida de un servicio.
		-Se crea nueva clase en la raiz de BibliotecasAPI: EjemploTiemposDeVida.
		-Se crearan 3 servicios: Transient, Scoped y Singleton.
		-Se vra como se comportan estos tres servicios.
		-Un Guid es un string aleatorio. Al momento de inicializar la clase se tendrá ese string aleatorio.
		-se pone propiedad publica para obtener el guid.
		-Cuando se instancie la clase ServicioTransient se crea string aleatorio que coloca en el campo_id pricado y para obtener esa info se usa ObtenerGuid que
		 es una propiedad publica que retorna el valor de _id.
		-Idem con Scoped y Singleton.
		public class EjemploTiemposDeVida
		{
			public class ServicioTransient
			{
				private readonly Guid _id;

				public ServicioTransient()
				{
					_id = Guid.NewGuid();
				}

				public Guid ObtenerGuid => _id;
			}

			public class ServicioScoped
			{
				private readonly Guid _id;

				public ServicioScoped()
				{
					_id = Guid.NewGuid();
				}

				public Guid ObtenerGuid => _id;
			}

			public class ServicioSingleton
			{
				private readonly Guid _id;

				public ServicioSingleton()
				{
					_id = Guid.NewGuid();
				}

				public Guid ObtenerGuid => _id;
			}

		}
		
		-Se van a crear esas tres clases como un servicio desde el area de servicios en la clase program.
		builder.Services.AddTransient<ServicioTransient>();
		builder.Services.AddScoped<ServicioScoped>();
		builder.Services.AddSingleton<ServicioSingleton>();
		
		-Ahora con servicios configurados ahi, se quiere decir que se peuden usar usando inyeccion de depednencias.
		-Se va a ValoresController. Se añade para metro mas en el constructor para obtener instancia de ServicioTransient.
		-En misma clase ValoresController se va a inyectar dos veces el mismo servicio.
		-Idem con Scoped y Singleton....
		-Control punto desde un parametro "por ejemplo, singleton" y Crear y asignar el resto de campos.
		public class ValoresController : ControllerBase
		{
			private readonly IRepositorioValores repositorioValores;
			private readonly ServicioTransient transient1;
			private readonly ServicioTransient transient2;
			private readonly ServicioScoped scoped1;
			private readonly ServicioScoped scoped2;
			private readonly ServicioSingleton singleton;

			public ValoresController(IRepositorioValores repositorioValores,
				ServicioTransient transient1,
				ServicioTransient transient2,
				ServicioScoped scoped1,
				ServicioScoped scoped2,
				ServicioSingleton singleton)
			{
				this.repositorioValores = repositorioValores;
				this.transient1 = transient1;
				this.transient2 = transient2;
				this.scoped1 = scoped1;
				this.scoped2 = scoped2;
				this.singleton = singleton;
			}......
			
		-Se crea nueva acción que será GET.
		-Se va a retorna IActionResult porque se va a retornar tipo anonimo.
		-Se esta construyendo objeto anonimo dopnde se tiene propeidad transients donde se colocan los Ids de lsos ervicios que son transient.
		-Mismo con Scoped y Singleton.
		-Se devuelve el guid de cada uno de los servicios.
		-Dado que transient significa que se va a crear una instancia de la clase cada vez que se solicita el servicio, se vera que los valores transient1 y trasient2 seran diferentes
		 porque se estan inyectando dos servicios transient y por tanto se esta instanciando dos veces la misma clase, mientras con scoped, se instancia una sola vez la clase
		 siempre que sea el mismo contexto HTTP. scoped1 y 2 no cambiaran. En Singleton se instancia una sola vez por el tiempo de vida de la app.
		 Ese valor no cambia a menos que se reinicie la app.
		[HttpGet("servicios-tiempos-de-vida")]
		public IActionResult GetServiciosTiemposDeVida()
		{
			return Ok(new
			{
				Transients = new
				{
					transient1 = transient1.ObtenerGuid,
					transient2 = transient2.ObtenerGuid,
				},
				Scopeds = new
				{
					scoped1 = scoped1.ObtenerGuid,
					scoped2 = scoped2.ObtenerGuid
				},
				Singleton = singleton.ObtenerGuid

			});

		}
		
		-Se ejecuta app en este endpoint. Se ve que trabnsient1 y 2 son difernetes. Scoped1 y 2 cambian pero son iguales entre si son iguales dentro de mismo contexto Http.
		-En singleton no cambia cada vez que se refresca.
		-En transient se tiene una instancia de la clase nueva sin importar que estemos en el mismo contexto http.
		-En scoped es misma instancia dentor de mismo conexto http. Si se tiene otro contexto, es decir, otra peticion, es optra instancia.
		-En singleton mismo valor, porque es siempre misma instancia hasta que se cierre la app y se vuelva a correr.
		
	57. Usando un Singleton para nuestro repositorio en memoria
		-Se tenía RepositorioValores que es de prueba pero se puede mejorar.
		-Se ve que se tiene un solo método para ObtenerValores.
		-Seria bueno usarlo tambien para insertar supuestos registros.
		-Si se hace se hara pequeña implementacion en memoria.
		-Se mete en el constructor listado de valores.
		-Lo que se hace es colocar como estado de la clase el listado de valores
		-Se crea el método publico que es InsertarValor.
		-Se cambia antes:
		public IEnumerable<Valor> ObtenerValores()
		{
			return new List<Valor> {
				new Valor{Id=3, Nombre="Valor Oracle 1"},
				new Valor{Id=4, Nombre="Valor Oracle 2"},
				new Valor{Id=5, Nombre="Valor Oracle 3"},
			};
		}
		
		-Por:
		private List<Valor> _valores;

		public RepositorioValoresOracle()
		{
			_valores = new List<Valor> 
			{
				new Valor{Id=3, Nombre="Valor Oracle 1"},
				new Valor{Id=4, Nombre="Valor Oracle 2"},
				new Valor{Id=5, Nombre="Valor Oracle 3"},
			};
		}

		public IEnumerable<Valor> ObtenerValores()
		{
			return _valores;
		}
		
		public void InsertarValor(Valor valor)
		{
			_valores.Add(valor);
		}
		
		-Se tiene que meter InsertarValores dentro de la interfaz IRepositorioValores. Para ello, desde InsertarValor, control punto, pull e insertar valor en IRespositorioValores...
		-RepositorioValores tiene que implementar ese contrato de InsertValor.
		-No se va a implementar ahora la logica que se puso en RepositorioValoresOracle.
		-En ValoresController se mete una nueva acción HttpPost.
		[HttpPost]
		public IActionResult Post(Valor valor)
		{
			repositorioValores.InsertarValor(valor);
			return Ok();
		}
		
		-Cuando se inserta un valor se quiere obtener el valor a traves del método ObtenerValores.
		-Se va a postman para hacer una peticion HTTP Post: 
			https://localhost:7132/api/valores
			{
				"id": "10",
				"nombre": "Valor Oracle 10"
			}
			
		-Ahora se lanza la petición GET desde el navegador y se ve que no se tiene la info.
		-En Program se ve que se ha configura els ervicio de IRepositorioValores como Transient.
		-Pero esto significa que cada vez que solicitemos una instancia del servicio IRepositorioValores se va a tener una nueva instancia de la clase RepositorioValoresOracle.
		-Esto sigmifica que cada vez que se solicite dicha nueva instancia, el campo de valores del constructir de RepositorioValoresOracle se inicialzia con lo que tiene en la clase...
		-Por eso, se tiene eso mismo. Por tanto, como se quiere compartir estado entre diferentes peticiones HTTP, pues se quiere que ese servicio sea Singleton
		 para que asi cualquier modificacion que un usuario haga pues ese listado de valores lo vea otro que es basicamente simular una BBDD porque si usuario
		 modificase la BBDD, pues otro usuario puede ver esa modificacion (insertar, updatear, borrar...).
		-Se cambia el servicio por AddSingleton para compartir estado en distintas peticiones HTTP.
		-Se da insertar y a get y ya se ve el nuevo valor...
		-Ahora ya se peude ser mas efectivo a la hora de decidir que tiempo de vida escoger.
			-Si se quiere comaprtir estado entre diferentes peticiones HTTP, pues usamos Singleton.
			-Si se quiere mantener ele stado dentro del mismo contexto HTTP, usar Scoped.
			-Sino interesa mantener el estado, pues Transient.
		
	58. ¿Y qué hacemos con Entity Framework Core?
		-Se habla de principio de inversión de dependencias y EF.
		-Este principio de inversión de dependencias dice que nuestras clases deben depender de tipos abstractos y no de concretos, es decir, depender de clases abstractas o interfaces. Esto
		 nos aydua a tener un nivel alto de flexibilidad y es recomendable para tener software que peuda evolucioanr.
		-ApliicationDBContext es un tipo concreto y recordamos que en AutoresController, se inyecta dicha clase a través del constructor.
		-Eso es que no se tiene por qué estar haciendo las cosas mal. Todo depende de las necesidades de negocio.
		-ApplicationDbContext aunque es una clase, en cierto sentido ya es de por sí una abstracción con respecto a detalles de implementación de la lógica de acceso a datos.
		-Para obtener un listado de autores se ha usado código como return await context.Autores.ToListAsync();
		-Eso nada habla acerca de SQLServer, Postgres....Se podria cambiar el motor de base de datos mañana y mi codigo de buscar listado de autores no cambairia
		-Aunque EF soporta varios motores de BBDD, no soporta todos.
		-Se sostiene el ehcho de que el DbContext ofrece flexibilidad. por tanto, no siempre es estrategico colocar 
		 detras de una interfaz. Se peuden hacer pruebas unitarias y de integración con EF Core muy facil, por lo que no es razon de peso para colcoarlo detras de una interfaz.
		-Existe una razon por la cual si deseariamos colocar nuestro ApplicationDbContext detras de una abstraccion y es cuando necesitamos soportar un motor de base de datos
		 el cual EF no soporta. Si se quiere suar SQL Server pero se quiere tambien usar Excel, pues tiene sentido usar una capa de abstraccion extra para poder soportar ambos
		 escenarios de forma simultanea.
		-ApplicationDbContext es especie de abstraccion que da flexibilidad, lo que es una escepcion a la regla y se peude depender de dicha clase sin problemas.
		-En el caso de que debamos soportar otras tecnologias no soportadas por Ef, si es aconsejable usar una interfazz 
		 para implementar el niveld e flexibilidad del sistema.
		-Rara vez lsos istemas cambian de motor de BBDD, por lo que implementar el nviel de complejidad de app por un por si acaso cambiamos de motor, no arroja beneficios.
	
	59. Loggers
		-El logging permite saber que esta ocurriendo con nuestra app cuando es eejcutada. Se peuden escribir mensajes en algun lugar para revisarlos.
		-Se peuden escribir mensajes en un archivo de texto, pero se van a escribir por consola ahora.
		-La idea del logging es que se tiene funciona  la que se llama, se pasa emnsaje de texto y se coloca en consola para evr funcion que se ejecuta, ver
		 valores que van saliendo etc.
		-El debugging no se puede usar en PROD, ni se puede epdir a un cliente de nosotros que esteusando WebAPi para que active mmodo debugging.
		-Lo que se peude hacer con un cliente es pedirle que use app y luego visualziar los logs. Esos mensajes qe han sido escritos por nuestra app, describiendo lo que está ocurriendo
		 dentro de nuestra app en tiempo de ejecucion.
		-Se peude usar ILogger. pemrite centralziar mensajes de logs. S epeude inyectar con sistema de inversion de dependencias, por ejemplo en AutoresController.
		-Es un servicio predeterminado, ya configurado por ASP.NET Core.
		-Se puede decir el nombre de la clase en la que se va a ejecutar el log.
		-basicamente, en este caso AutoresController.
		-Se pone asi.
		private readonly ILogger<AutoresController> logger;

		public AutoresController(ApplicationDbContext context, ILogger<AutoresController> logger)
		{
			this.context = context;
			this.logger = logger;
		}
		
		-Se va a la peticion hettpGET de listado-de-autores para usarlo.
		[HttpGet("/listado-de-autores")] // /listado-de-autores
		[HttpGet] // /api/autores/
		public async Task<IEnumerable<Autor>> Get()
		{
			logger.LogInformation("Obteniendo el listado de autores");
			return await context.Autores.ToListAsync();

		}
		-Se lanza una prueba en el navegador. Se ve mensaje en la consola.
		-Hay 6 niveles de mensajes: Trace, Debug, Information, Warning, Error, Critical.
		-Estos niveles permiten segmentar os mensajes segun el nivel de importancia.
		-Trace es el menor novel de importancia y critical el mayor nivel de importancia.
		-Se puede configurar a partir de que nivel se quieren procesar los mensajes de LOG. Si se elige INformation irá de ese para arriba: debug y trace no porquee stan por debajo del nivel minimo
		 del que quiero procesar los mensajes.
		 Asi funciona los nieveles en los mensajes de log.
		 Se pone idem LogTrace,  debugging.....
			[HttpGet("/listado-de-autores")] // /listado-de-autores
			[HttpGet] // /api/autores/
			public async Task<IEnumerable<Autor>> Get()
			{
				logger.LogTrace("Obteniendo el listado de autores");
				logger.LogDebug("Obteniendo el listado de autores");
				logger.LogInformation("Obteniendo el listado de autores");
				logger.LogWarning("Obteniendo el listado de autores");
				logger.LogError("Obteniendo el listado de autores");
				logger.LogCritical("Obteniendo el listado de autores");
				return await context.Autores.ToListAsync();

			}
		-Por defecto, en el expplorado de soluciones del proyecto, se ve en appsettings.development.json que se eejcuta en desarrollo, se ve el nivel de logging
		 y se ve que por defecto es Information, es decir se procesan los mensajes desde Information hacia arriba.
		-Para que no se llene la consola de mensajes de trace y debug que tiene asp.net core se puede usar una categoria que 
		 son los strings que se ponen entrecomillado como Defaukt.
		 Son los lugares en los cuales se va a aplicar el nivel de procesamiento de los logs.
		-Se tiene por ejemplo "Microsoft.AspNetCore", esto quiere decir que cualquier clase que se encuentre en este namespace,
		 le aplica ese nivel de procesamiento de log. Para yo aplicar el nivel de procesamiento Trace en AutoresControler,
		 se coloca el namespace como namespace. Si se quiere ser mas especifico se puede poner .AutoresController.
		 Asi, esto solo aplica a los mensajes de log que salgan de esta categoria.
		  "Logging": {
		   "LogLevel": {
			 "BibliotecaAPI.Controllers.AutoresController": "Trace",
			 "Default": "Information",
			 "Microsoft.AspNetCore": "Warning"
		   }
		 }
		 
		-Ahora ya si se imprimene sos mensajes en consola. Se peude hacer eso de forma temproal para miraer error y luego Information.
		-Se puede usar para investigar cosass y luego vovler a cambiarlo.
	
	60. Introducción al Middleware.
		-Hasta ahora se ha dicho que cuando WebAPI recibe una solicitud HTTP, es una accion de un controlador la que recibe la solicitud y la procesa.
		-Esta no es sdescripcion precisa de lo que realmente sucede cuando se recibe la solicitud. Una solicitud llega a WebAPI y pasa por lo que se conoce 
		 por pipeline de solicitudes HTTP.
		-Un pipe es una acdena de procesos conectados de tal manera que la salida de cada elemento de la acdena es la entarda del siguiente.
		-El pipeline es el conjunto de procesos conectados que reciben una solicitud y la procesan para dar algun tipo de Rdo.
		-Uno de esos procesos es el proceso Controlador que es donde se manejan los controladores y las acciones.
		-Ciertamente no es unico proceso del pipline. Se llama middleware a cada proceso del pipline.
		-Un middleware importante es el proceso de autorizacion que es el que permite la funcionalidad denegar el acecso de un recurso dependiendo de si
		 el usuario tiene permiso para acceder a este.
		-Es normal que se configuren permisos en el proceso de controladores donde indicamos que una accion, solo puede ser consumida por ciertos usuarios.
		-Para que esta logica de autorizacion funcione es importante haber apsado por el proceos de autorizacion priemro.
		-Esto implica que el orden de los proceoss en el pipeline es importante.
		-Los middlewares se ejecutan de la siguiente manera. Primero llega epticion, va al priemr middlware, luego al segundo, luego al tercero y se van ejecutando los
		 middlewares de atras adelante en la fase de respuesta, primero tercero, luego segundo, luego primero y luego se da respuesta al cliente.
		-Puede ser que un middleware que haga un cortocircuito. Puede que el segundo middleware recibe la peticion y verifica que no tiene que el tercer middleware la vea
		 y por tanto, hace cortocircuito y da una respuesta.
		-Si un middlware por ejemplo comprueba que un usuario no tiene permisos para continuar pues no le deja continuar.ç
		-Y no le pasa la peticion a los siguientes middlewares.
	
	61. Ejemplos de Middleware.
		-Se ve que en la clase Program esta el area de los middlewares.
		-Va desde el var app hasta app.Run.
		-Por ahora, solo 1 middleware que permite que cuando llega peticion a ruta especifica, pues un controlador peuda manejar sidcha peticion.
		-Se va a decir que se quiere crear middleware que se encarag de logegar cada peticion y cada respuesta que recibamos.
		-Es decir cuando llegue una peticion se quiere guardar en el log, el metodo y la ruta y de la respuesta se quiere usar el estado de la respuesta.
		-Se recibe el contexto y next que permite invocar el siguiente middleware. Desde dentro se quiere recibir una instancia del servicio Ilogger.
		-Se usa el cotexto htpp. Se quiere permitir tambien la invocacion del siguiente middleware y para eso se usa next.
		-Por un lado, se tiene que se quiere guardar en el log, informacion acerca de la peticion http, luego acerca de la respuesta.
		-Invoke permite invocar el resto de la tuberia de pipeline.
		-Es decir, el resto de los middlewares.
		-Primero, la epticion viene entra al middleware hace lo de la request y luego invoke y se suspende la ejecucion, se ejecuta MapControllers, va a un controlador como el de autores,
         se procesa y se devuelve informacion. Luego van middlwares hacia atras y luego ya se ejecuta lo de la respuesta.
			// área de middlewares
			app.Use(async (contexto, next) =>
			{
				// Viene la petición
				var logger = contexto.RequestServices.GetRequiredService<ILogger<Program>>();
				logger.LogInformation($"Petición: {contexto.Request.Method} {contexto.Request.Path}");

				await next.Invoke();

				//Se va la respuesta

				logger.LogInformation($"Respuesta: {contexto.Response.StatusCode}");
			});

			app.MapControllers();

			app.Run();		 
			
		-En la consola se ve la salida.
		
		-Se quiere enseñar un ejemplo en el que el orden de los Middlewares es super kmportante. Si se quiere tener una ruta que no tenga que evr con controladores,
		 que nadie pueda entrar por alguna razon. Hay una logica que se encarga de guardar el log, cualqueir peticion. La idea es guardar el log y luegi hagamos 
		 cualquier otra cosa para que asi si la eprsona incluso intenta entrar a ese sitio prohibido, pues que quede loggeado.
		 app.Use(async (contexto, next) =>
			{
				if (contexto.Request.Path == "/bloqueado")
				{
					contexto.Response.StatusCode = 403;
					await contexto.Response.WriteAsync("Acceso Denegado");
				} else
				{
					await next.Invoke();
				}
				
			});
			
		-Si se pone el de bloqueado arriba, que pasa? Se tiene acceso denegado pero no se escribe ni response ni request.
		-Esto es orque orden de middlewares es importate y este hace cortocircuito a peticion y or tanto 
		 el de abajo no se ejecuta. Si se tiene necesidad de engocio de guardar en un log las peticiones  y respuestas, pues estas provocadas por el middleware no se 
         logearian.

	62. Colocando los Middlewares en su propia clase
		-Se van a colcoar middlewares personalziados en sus propias clases, asis e mantiene program mas limpio.
		-Se crea clase, normalmente se mete en una carpeta, pero da igual por ahora.
		-Se le llama LogeuapeticionMiddleware. Se mete constructor. Se pone RequestDelegate que es el invoke.
		-Para ser middleware hay que meter metodo InvokeAsync.
		public class LogueaPeticionMiddleware
		{
			private readonly RequestDelegate next;

			public LogueaPeticionMiddleware(RequestDelegate next)
			{
				this.next = next;
			}

			public async Task InvokeAsync(HttpContext contextp)
			{

			}
		}
		
		-Se coge el cacho de code de la request del Middleware.
		public async Task InvokeAsync(HttpContext contexto)
		{
			// Viene la petición
			var logger = contexto.RequestServices.GetRequiredService<ILogger<Program>>();
			logger.LogInformation($"Petición: {contexto.Request.Method} {contexto.Request.Path}");

			await next.Invoke(contexto);

			//Se va la respuesta

			logger.LogInformation($"Respuesta: {contexto.Response.StatusCode}");
		}
		
		-Esto sirve para poder indicar que queires seguir la ejecucion del pipeline del middleware. Lo de más arriba del metodo se eejcuta en lo que la peticion viene 
		 y lo otro cuando se va la respuesta. Para sim plificar como usar el middleware, el standar es que se cree una clase estatica que exponga un metodo de extension 
		 de la siguiente forma.
		
		-Es clase auxiliar de la anterior. Va a ser estatica porque es un metodo de extension....
		public static class LogueaPeticionMiddlewareExtensions
		{
			public static IApplicationBuilder UseLogueaPeticion(this ApplicationBuilder builder)
			{
				return builder.UseMiddleware<LogueaPeticionMiddleware>();
			}
		}
		
		-La clase de arriba tiene logica de middleware y la otra tiene metodo auxiliar que permite usar el middleware de forma sencilla.
		-Donde estaba el code de antes en Program.cs, se mete asi.
		
		-El metodo de extension eprmite extender un tipo.
		-El IApplicationBuilder le pertenece a Microsoft. No hemos hecho  nosotros.
		-El emtodo de extension permite hacer como si la estuviese modifciando para agregarle ese metodo y de forma comoda
		-Cuando se hace app.UseLogueaPeticion es un webapplication y se esta agregando el metodo IApplicationBuilder que lo implementa esa parte de Microsoft y
		 al se run metodo ya lo agrega.
		-Se va a probar.
		-Se crea nueva clase para llevar el otro metodo a otra clase.
		-COn BloqueaPeticion idem logica que antes.
		
	63. Resumen
		-Se vio fundamentos de ASP.NET Core aplicados a WebAPI.
		-Los controladores sn clases que agrupan cjto de metodos que responden a peticiones http enbase a un recurso a estos metodos se llaman acciones.
		-Acciones on metodos que se ejecutan en abse a respuesta a peticion http.
		-Programacion asincrona nos aydua a ser eficientes cuando realizamos operaciones I/O.
		-Se pueden hacer validaciones de nuestros modelos para evitar tener data no valida.
		-La inyeccion de depedencias buena practica en ingenieria de software para centralizar logica de instanciacion de nuestras clases.
		-Servicio es una clase que se peude servir usando sistema de inyeccion de dependencias o contenedor de inversion de controles.
		-Los middlewares son funciones que se pueden ejecutar para procesar solciitudes http que recibe nuestra app.
		
Seccion 5: Manipulando recursos
	64. Introducción al Módulo
		-Es hora de hablar de manipulaciond e recursos que se refiere a las operaciones basicas de manipulacion como crear, actualizar, borrar y leer recursos.
	
	65. Limpiando el proyecto
		-El quiere borrar el ValoresController:
		using BibliotecaAPI.Entidades;
		using Microsoft.AspNetCore.Mvc;

		namespace BibliotecaAPI.Controllers
		{
			[ApiController]
			[Route("api/valores")]
			public class ValoresController : ControllerBase
			{
				private readonly IRepositorioValores repositorioValores;
				private readonly ServicioTransient transient1;
				private readonly ServicioTransient transient2;
				private readonly ServicioScoped scoped1;
				private readonly ServicioScoped scoped2;
				private readonly ServicioSingleton singleton;

				public ValoresController(IRepositorioValores repositorioValores,
					ServicioTransient transient1,
					ServicioTransient transient2,
					ServicioScoped scoped1,
					ServicioScoped scoped2,
					ServicioSingleton singleton)
				{
					this.repositorioValores = repositorioValores;
					this.transient1 = transient1;
					this.transient2 = transient2;
					this.scoped1 = scoped1;
					this.scoped2 = scoped2;
					this.singleton = singleton;
				}

				[HttpGet("servicios-tiempos-de-vida")]
				public IActionResult GetServiciosTiemposDeVida()
				{
					return Ok(new
					{
						Transients = new
						{
							transient1 = transient1.ObtenerGuid,
							transient2 = transient2.ObtenerGuid,
						},
						Scopeds = new
						{
							scoped1 = scoped1.ObtenerGuid,
							scoped2 = scoped2.ObtenerGuid
						},
						Singleton = singleton.ObtenerGuid

					});

				}


				//Dependencia débil
				[HttpGet]
				public IEnumerable<Valor> Get()
				{   
					return repositorioValores.ObtenerValores();
				}
				//Dependencia Fuerte
				//[HttpGet]
				//public IEnumerable<Valor> Get()
				//{
				//    var repositorioValores = new RepositorioValores();

				//    //return new List<Valor>
				//    //{
				//    //    new Valor{Id = 1, Nombre = "Valor 1" },
				//    //    new Valor{Id = 2, Nombre = "Valor 2" }
				//    //};

				//    return repositorioValores.ObtenerValores();
				//}


				[HttpPost]
				public IActionResult Post(Valor valor)
				{
					repositorioValores.InsertarValor(valor);
					return Ok();
				}

			}
		}

		-La clase Valor:
		namespace BibliotecaAPI.Entidades
		{
			public class Valor
			{
				public int Id { get; set; }
				public required string Nombre { get; set; }
			}
		}
		
		-BloqueaPeticionMiddleware:
		using BibliotecaAPI;

		public class BloqueaPeticionMiddleware
		{
			private readonly RequestDelegate next;

			public BloqueaPeticionMiddleware(RequestDelegate next)
			{
				this.next = next;
			}

			public async Task InvokeAsync(HttpContext contexto)
			{
				if (contexto.Request.Path == "/bloqueado")
				{
					contexto.Response.StatusCode = 403;
					await contexto.Response.WriteAsync("Acceso Denegado");
				}
				else
				{
					await next.Invoke(contexto);
				}
			}
		}

		public static class BloqueaPeticionMiddlewareExtensions
		{
			public static IApplicationBuilder UseBloqueaPeticion(this IApplicationBuilder builder)
			{
				return builder.UseMiddleware<BloqueaPeticionMiddleware>();
			}
		}

		-EjemploTiemposDevida:
		namespace BibliotecaAPI
		{
			public class ServicioTransient
			{
				private readonly Guid _id;

				public ServicioTransient()
				{
					_id = Guid.NewGuid();
				}

				public Guid ObtenerGuid => _id;
			}

			public class ServicioScoped
			{
				private readonly Guid _id;

				public ServicioScoped()
				{
					_id = Guid.NewGuid();
				}

				public Guid ObtenerGuid => _id;
			}

			public class ServicioSingleton
			{
				private readonly Guid _id;

				public ServicioSingleton()
				{
					_id = Guid.NewGuid();
				}

				public Guid ObtenerGuid => _id;
			}
		}

		-IRepositorioValores:
		using BibliotecaAPI.Entidades;
		namespace BibliotecaAPI
		{
			public interface IRepositorioValores
			{
				void InsertarValor(Valor valor);
				public IEnumerable<Valor> ObtenerValores();
			}
		}

		-LogueaPeticionMiddleware:
		namespace BibliotecaAPI;
		public class LogueaPeticionMiddleware
		{
			private readonly RequestDelegate next;

			public LogueaPeticionMiddleware(RequestDelegate next)
			{
				this.next = next;
			}

			public async Task InvokeAsync(HttpContext contexto)
			{
				// Viene la petición
				var logger = contexto.RequestServices.GetRequiredService<ILogger<Program>>();
				logger.LogInformation($"Petición: {contexto.Request.Method} {contexto.Request.Path}");

				await next.Invoke(contexto);

				//Se va la respuesta

				logger.LogInformation($"Respuesta: {contexto.Response.StatusCode}");
			}
		}

		public static class LogueaPeticionMiddlewareExtensions
		{
			public static IApplicationBuilder UseLogueaPeticion(this IApplicationBuilder builder)
			{
				return builder.UseMiddleware<LogueaPeticionMiddleware>();
			}
		}

		-RepositorioValores:
		using BibliotecaAPI.Entidades;

		namespace BibliotecaAPI
		{
			public class RepositorioValores : IRepositorioValores
			{
				public void InsertarValor(Valor valor)
				{
					throw new NotImplementedException();
				}

				public IEnumerable<Valor> ObtenerValores()
				{
					return new List<Valor>
					{
						new Valor{Id = 1, Nombre = "Valor 1" },
						new Valor{Id = 2, Nombre = "Valor 2" }
					};
				}
			}
		}

		-RepositorioValoresOracle:
		using BibliotecaAPI.Entidades;

		namespace BibliotecaAPI
		{
			public class RepositorioValoresOracle : IRepositorioValores
			{
				private List<Valor> _valores;

				public RepositorioValoresOracle()
				{
					_valores = new List<Valor> 
					{
						new Valor{Id=3, Nombre="Valor Oracle 1"},
						new Valor{Id=4, Nombre="Valor Oracle 2"},
						new Valor{Id=5, Nombre="Valor Oracle 3"},
					};
				}

				public IEnumerable<Valor> ObtenerValores()
				{
					return _valores;
				}

				public void InsertarValor(Valor valor)
				{
					_valores.Add(valor);
				}
			}
		}

		-AutoresController:
		using BibliotecaAPI.Datos;
		using BibliotecaAPI.Entidades;
		using Microsoft.AspNetCore.Mvc;
		using Microsoft.EntityFrameworkCore;

		namespace BibliotecaAPI.Controllers
		{
			[ApiController]
			[Route("api/autores")]
			public class AutoresController : ControllerBase
			{
				private readonly ApplicationDbContext context;
				private readonly ILogger<AutoresController> logger;

				public AutoresController(ApplicationDbContext context, ILogger<AutoresController> logger)
				{
					this.context = context;
					this.logger = logger;
				}

				//[HttpGet]
				////public string Get()
				//public IEnumerable<Autor> Get()
				//{
				//    return new List<Autor>
				//    {
				//        new Autor{Id = 1, Nombre = "Felipe"},
				//        new Autor{Id = 2, Nombre = "Claudia"}
				//    };

				//}

				[HttpGet("/listado-de-autores")] // /listado-de-autores
				[HttpGet] // /api/autores/
				public async Task<IEnumerable<Autor>> Get()
				{
					logger.LogTrace("Obteniendo el listado de autores");
					logger.LogDebug("Obteniendo el listado de autores");
					logger.LogInformation("Obteniendo el listado de autores");
					logger.LogWarning("Obteniendo el listado de autores");
					logger.LogError("Obteniendo el listado de autores");
					logger.LogCritical("Obteniendo el listado de autores");
					return await context.Autores.ToListAsync();

				}

				[HttpGet("primero")]// api/autores/primero
				public async Task<Autor> GetPrimerAutor()
				{
					return await context.Autores.FirstAsync();

				}

				[HttpGet("{id:int}")] // api/autores/id?incluirLibros=true|false
				public async Task<ActionResult<Autor>> Get(int id, [FromHeader] bool incluirLibros)
				{
					var autor = await context.Autores
						.Include(x => x.Libros)
						.FirstOrDefaultAsync(x => x.Id == id);

					if (autor is null)
					{
						return NotFound();
					}

					return Ok(autor);

				}

				[HttpGet("{nombre:alpha}")]
				public async Task<IEnumerable<Autor>> Get(string nombre)
				{
					return await context.Autores.Where(x => x.Nombre.Contains(nombre)).ToListAsync();
				}

				//[HttpGet("{parametro1}/{parametro2?}")]// api/autores/felipe/gavilan
				//public ActionResult Get(string parametro1, string parametro2 = "valor por defecto")
				//{
				//    return Ok(new { parametro1, parametro2 });
				//}


				[HttpPost]
				public async Task<ActionResult> Post([FromBody] Autor autor) {
					context.Add(autor);
					await context.SaveChangesAsync();
					return Ok();
				}

				[HttpPut("{id:int}")] // api/autores/1 
				public async Task<ActionResult> Put(int id, Autor autor)
				{
					if (id != autor.Id)
					{
						return BadRequest("Los IDs deben de coincidir");
					}

					context.Update(autor);
					await context.SaveChangesAsync();
					return Ok();

				}


				[HttpDelete("{id:int}")] // api/autores/1 
				public async Task<ActionResult> Delete(int id)
				{
					var registrosBorrados = await context.Autores.Where(x => x.Id == id).ExecuteDeleteAsync();

					if (registrosBorrados == 0)
					{
						return NotFound();
					}

					return Ok();

				}
			}
		}
		
		-De AutoreController, se quita el ILogger.
		-Se quita el httpget el de primero....
		-En resumen, dejo la nueva version de AutoresController y se puede comparar con lo que habia antes.
		using BibliotecaAPI.Datos;
		using BibliotecaAPI.Entidades;
		using Microsoft.AspNetCore.Mvc;
		using Microsoft.EntityFrameworkCore;

		namespace BibliotecaAPI.Controllers
		{
			[ApiController]
			[Route("api/autores")]
			public class AutoresController : ControllerBase
			{
				private readonly ApplicationDbContext context;

				public AutoresController(ApplicationDbContext context)
				{
					this.context = context;
				}

				[HttpGet] // /api/autores/
				public async Task<IEnumerable<Autor>> Get()
				{
					return await context.Autores.ToListAsync();

				}

				[HttpGet("{id:int}")] // api/autores/id
				public async Task<ActionResult<Autor>> Get(int id)
				{
					var autor = await context.Autores
						.Include(x => x.Libros)
						.FirstOrDefaultAsync(x => x.Id == id);

					if (autor is null)
					{
						return NotFound();
					}

					return Ok(autor);

				}

				[HttpPost]
				public async Task<ActionResult> Post([FromBody] Autor autor) {
					context.Add(autor);
					await context.SaveChangesAsync();
					return Ok();
				}

				[HttpPut("{id:int}")] // api/autores/1 
				public async Task<ActionResult> Put(int id, Autor autor)
				{
					if (id != autor.Id)
					{
						return BadRequest("Los IDs deben de coincidir");
					}

					context.Update(autor);
					await context.SaveChangesAsync();
					return Ok();

				}


				[HttpDelete("{id:int}")] // api/autores/1 
				public async Task<ActionResult> Delete(int id)
				{
					var registrosBorrados = await context.Autores.Where(x => x.Id == id).ExecuteDeleteAsync();

					if (registrosBorrados == 0)
					{
						return NotFound();
					}

					return Ok();

				}
			}
		}
		
		-En Autores se cambia esto:
		using BibliotecaAPI.NewFolder;
		using System.ComponentModel.DataAnnotations;

		namespace BibliotecaAPI.Entidades
		{
			public class Autor : IValidatableObject
			{
				public int Id { get; set; }
				[Required(ErrorMessage = "El campo nombre es requerido")]
				[StringLength(10, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
				// [PrimeraLetraMayuscula]
				public required string Nombre { get; set; }
				public List<Libro> Libros { get; set; } = new List<Libro>();

				public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
				{
					if (!string.IsNullOrEmpty(Nombre))
					{
						var primeraLetra = Nombre[0].ToString();

						if (primeraLetra != primeraLetra.ToUpper())
						{
							yield return new ValidationResult("La primera letra debe ser mayúscula - por modelo", new string[] { nameof(Nombre) });
						}
					}
				}

				//[Range(8,120)]
				//public int Edad { get; set; }

				//[CreditCard]
				//public string? TarjetaCredito { get; set; }

				//[Url]
				//public string? URL { get; set; }
			}
		}
		
		-Por esto:
		public class Autor
		{
			public int Id { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Nombre { get; set; }
			public List<Libro> Libros { get; set; } = new List<Libro>();
		}
		
		-En el development.json, comentar esto: // "BibliotecaAPI.Controllers.AutoresController": "Trace",
		-Program, esto:
		using BibliotecaAPI;
		using BibliotecaAPI.Datos;
		using Microsoft.EntityFrameworkCore;
		using System.Text.Json.Serialization;

		namespace BibliotecaAPI
		{
			public class Program
			{
				public static void Main(string[] args)
				{
					var builder = WebApplication.CreateBuilder(args);

					//área de servicios
					builder.Services.AddTransient<ServicioTransient>();
					builder.Services.AddScoped<ServicioScoped>();
					builder.Services.AddSingleton<ServicioSingleton>();

					builder.Services.AddSingleton<IRepositorioValores, RepositorioValoresOracle>();

					builder.Services.AddControllers().AddJsonOptions(opciones => 
					opciones.JsonSerializerOptions.ReferenceHandler = ReferenceHandler.IgnoreCycles);

					builder.Services.AddDbContext<ApplicationDbContext>(opciones => opciones.UseSqlServer("name=DefaultConnection"));

					var app = builder.Build();

					// área de middlewares
					//app.Use(async (contexto, next) =>
					//{
					//    // Viene la petición
					//    var logger = contexto.RequestServices.GetRequiredService<ILogger<Program>>();
					//    logger.LogInformation($"Petición: {contexto.Request.Method} {contexto.Request.Path}");

					//    await next.Invoke();

					//    //Se va la respuesta

					//    logger.LogInformation($"Respuesta: {contexto.Response.StatusCode}");
					//});

					app.UseLogueaPeticion();

					//app.Use(async (contexto, next) =>
					//{
					//    if (contexto.Request.Path == "/bloqueado")
					//    {
					//        contexto.Response.StatusCode = 403;
					//        await contexto.Response.WriteAsync("Acceso Denegado");
					//    } else
					//    {
					//        await next.Invoke();
					//    }
						
					//});

					app.BloqueaPeticion();

					app.MapControllers();

					app.Run();
				}
			}
		}
		
		-Por esto:
		using BibliotecaAPI;
		using BibliotecaAPI.Datos;
		using Microsoft.EntityFrameworkCore;
		using System.Text.Json.Serialization;

		namespace BibliotecaAPI
		{
			public class Program
			{
				public static void Main(string[] args)
				{
					var builder = WebApplication.CreateBuilder(args);

					//área de servicios

					builder.Services.AddControllers().AddJsonOptions(opciones => 
					opciones.JsonSerializerOptions.ReferenceHandler = ReferenceHandler.IgnoreCycles);

					builder.Services.AddDbContext<ApplicationDbContext>(opciones => opciones.UseSqlServer("name=DefaultConnection"));

					var app = builder.Build();

					// área de middlewares

					app.MapControllers();

					app.Run();
				}
			}
		}
		
	66. Repaso de Cómo configurar EF
		-Lo primero es instalar dos paquetes nugget: SQL Server y el de Tools porque se usa Visual Studio y es el que habilita para usar 
		 los comando de EF en el Package Manager Console.
		-Si se usa otro editor, se usa el Design.
		-Luego, se creó la carpeta datos donde se metió el ApplicationDbContext que es una clase que hereda de DBContext y a traves de 
		 esta clase se pueden inyectar las configuraciones fundamentales de EF como por ejemplo, SQL Server y las tablas
		 de Autoresy Libros que se basan en la clase Autor y Libro.
		-En la clase program, se coloca el servicio, AddDbContext y se le pasa opciones. Se mete UseSQLServer y se le pasa el ConnectionString.
		-Esta dentro de development appsettings.
		-Se puede ir a la folder de migrations que es donde estan las migraciones.
		-Una migracion es la representacion en codigo C# de los cambios que van a ocurrir en BBDD.
		-A veces se modifica una entidad que es autor y libro...Son clases que representan tablas en bbdd.
		-Tu modificas una entidad y esa modificacion peude significar una modificacion en BBDD.
		-Se quiere ver que esa modificacion es lo que realmente se quiere y no se quiere equivocar...
		-Y por ejemplo, no se quiere eliminar columna sin querer.
		-Entonces, es importante que para poder modificar la BBDD usando Entity Framework Core, se necesita una kigracion que permite observar los detalles
		 de los cambios que ocurriran en la BBDD. Se tiene  dos migracioens: TablaAutores y TablaLibros que amabas tienen un precio que es fecha en la que
		 las migraciones fueron hechas.
		-En TablaAutores se ve que se crea la tabla Autores.
		-Se ve que por defecto para el campo nombre, se ha metido esto: Nombre = table.Column<string>(type: "nvarchar(max)", nullable: false)
		-Imaginemos qu se quiere meter otra longitud com se ha hecho despues: [StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
		-Se ha hecho despues de lanzar la migracion.
		-Con libros pasa idem.
		-En libro se va a añadir esto.
		[Required]
		[StringLength(250, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
		public required string Titulo { get; set; }
		
		-Para que este cambio se refleje en mi BBDD, se lanza una migracion desde el PackageManager: Add-Migration CofiguracionLongitudColumnas.
		-Esto crea la migracion para ver los cambios que ocurriran en BBDD.
		-Ahora se lanza Update-Database
		-Se va a SQL Server Management Studio y se ven los cambios.
		-Se peuden usar anotaciones de datos para modifcar el esuqema de la tabla de SQL Server.
		-Se peuden hacer modificaciones coo esta en ApplicationDbContext.
		protected override void OnModelCreating(ModelBuilder modelBuilder)
		{
			base.OnModelCreating(modelBuilder);
			modelBuilder.Entity<Autor>().Property(x=>x.Nombre).HasMaxLength(150);
		}
		
		-Nunca boirrar lo de dentro porque puede dar un error al configrar el sistema de usuarios.
		-En el OnModelCreating se peuden hacer modificaciones.
		-Esto es mas poderoso que las anotaciones de datos porque no todo lo que se puede hacer por aqui, se puede hacer desde el otro lado.
		-Las anotaciones la ventaja es que se conectan con ASP.NET Core para hacer validaciones.
		-Si se comenta la anotacion y se deja solo lo de ApplicationDbContext nos va a dejar la columna en BBDD con esa longitud pero cuando ASp.NET Core reciba un nombre con length mayor a 150,
		 no va a auto,aticamente decirnos que habia un error y devolver un VAlidationError porque esto es configuracion de EF.
		 Lo otro es para EF y para validaciones de ASp.NET Core.
		 -Se comenta: modelBuilder.Entity<Autor>().Property(x=>x.Nombre).HasMaxLength(150);
		 
	67. Repaso de Cómo insertar registros en la BBDD
		-Se va a usar EF.
		-Para usar ApplicationDBCOntext en un controlador, se inyecta con constructor y se pone en campo de la clase para poder acceder a este en toda la clase.
		-Se va a post y para poder insertar registro en BBDD usando EF, se hace lo siguiente.
		-El FromBody que estaba en la peticion no hace falta en WebAPI porque por defecto un autor ya viene en el body. Es decir, un tipo complejo 
		 como Autor viene del cuerpo estandoe n conexto de post: [FromBody] Autor autor
		
		
		[HttpPost]
		public async Task<ActionResult> Post(Autor autor) {
			context.Add(autor);
			await context.SaveChangesAsync();
			return Ok();
		}
		
		-Como sabe EF que ese registro va en la tabla de autores?
		-Pues porque EF te permite ser esecifico....Se podria haber puesto: context.Autores.Add(autor);
		-Segun tipo de dato que se le pasa a Add ya sabe el tipo de dato que debe insertar.
		-Cuando se dice Add se marca ese objeto para que sea insertardo en la base de datos cuando se inserten cambios
		-En SaveChangesAsync es cuando guardas cambios. Recorre objetos que haya en memoria este autor y puede haber otro libro por ahi
		 y estan marcados para ser creados, borrados, actualizados y en un soo paquet,e nvio u operacion se hace eso.
		Si debajo de Add(autor) hubiese esto....
		var libro = new Libro() { Titulo= "titulo actualizado", Id = 1 };
		context.Update();
		
		-Se tendrian dos operaciones en memoria pero ninguna se va a hacer hasta que se haga ese Save.
	
	68. Creando recursos con post
		-Hasta ahora se estaba retornando un Ok(); pero el estandar manda retornar un 201 created.
		-De este modo, el cliente sabra que un recurso ha sido creado y obtendra un link a traves del cual podra obtener 
		 dicho recuros recien creado.
		-Primer cambio, desde post en AutoresController, se quiere poder hacer una referencia a le peticion GET.
		-Se le va a poner un nombre para eso a la peticion get: [HttpGet("{id:int}", Name = "ObtenerAutor")]
		-Ahora, en la peticion Post, en vez de poner return Ok(); se pone return CreatedAtRoute; asi se obtienen los datos del autor recien creado.
		-Hay que indicar en el segundo parametro los valores que se le tienen que pasar a este metodo para poder invocarlo, en este caso solo un id.
		[HttpPost]
		public async Task<ActionResult> Post(Autor autor) {
			context.Add(autor);
			await context.SaveChangesAsync();
			return CreatedAtRoute("ObtenerAutor", new { id = autor.Id });
		}
		
		-Cuando se inserta un autor al hacer SaveChangesAsync, se le coloca en la propiedad Id, el id del registro recien creado.
		-Por ultimo, se pasa el autor recien creado.
		[HttpPost]
		public async Task<ActionResult> Post(Autor autor) {
			context.Add(autor);
			await context.SaveChangesAsync();
			return CreatedAtRoute("ObtenerAutor", new { id = autor.Id }, autor);
		}
		
		-Se ejecuta la app. Desde postman se crea nuevo autor.
		https://localhost:7132/api/autores POST
		{
			"Nombre": "Felipe Reyes"
		}
		
		-Si se va a headers en la respuesta se tiene la Location que sirve para obtener el detalle del recurso recien creado.
		-En LibrosController se va a hacer Idem.
		https://localhost:7132/api/libros POST
		{
			"titulo": "Libro nuevo",
			"autorId": 5
		}
		
		-Se coge headers y se lanza GET.
		-Se coge esta peticion y se ve que se saca el autor del libro:
		https://localhost:7132/api/libros/5
		
	69. Nombre, Apellidos y Datos Sensibles
		-Igual se necesita guardar por separado nombres y apellidos de autores.
		-En el post puede que hubiese que mandar por separado nombre y apellidos.
		-Esto porque se peude querer ordenar por nombre o apellido nuestros autores.
		-Eso si, cuando se obtenga la data de los autores, quiero que me concatene nombre y apellido.
		-El nombre debe estar igual que ahora en https://localhost:7132/api/libros/5
		-Otro requerimiento es que se quiere guardar la identificacion del autor por temas legales.
		-Esta identificacion no debe ser mostrada a otros.
		-Ese dato lo puedo recibir al crear un autor pero cuando solicite la data de un autor, no puedo mostrar esa data sensible.
		-Se va a ir a Autor.
		Antes
		public class Autor
		{
			public int Id { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Nombre { get; set; }
			public List<Libro> Libros { get; set; } = new List<Libro>();
		}
		
		Despues. Identificacion sera nullable ? porque es un campo opcional.
		public class Autor
		{
			public int Id { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Nombres { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(20, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Apellidos { get; set; }
			public string? identificacion { get; set; }
			public List<Libro> Libros { get; set; } = new List<Libro>();
		}
		
		-Ahora se compila la app. ctrl + shift + B.
		-Se añade una migracion en el package Manager Console: Add-Migration NuevasColumnas.
		-Se ve lo que pasa en BBDD.
		-Se le da a Update-Database.
		-Se va a SQL Server Management Studio y en columnas se refresca y se ve que se tiene Nombres, Apellidos, Identificacion.
		-Se hace select y se que se tienen los nombres rellenos con info e identificacion y apellidos vacio.
		-Se hace DELET AUTORES; para borrar la data de la tabla.
		-Se crea un nuevo autor y en el POST se cambia el campo a "nombres".
		-Se pone ademas apellidos e identificacion.
		https://localhost:7132/api/autores
		{
			"nombres": "Felipe",
			"apellidos": "Gavilán",
			"identificacion": "123"
		}
		{
			"nombres": "Claudia",
			"apellidos": "Rodríguez",
			"identificacion": "456"
		}
		
		-Se lanza GET a esa URL https://localhost:7132/api/autores
		-Se ve ahora el campo identificacion. Uno de los requerimientos es que se quiere tener nombre y apellidos separados, pero los clientes 
		 de webapi no lo deben tener por separado y no deben ver la identificacion. 
		 
	70. DTOs y Automapper
		-Hasta ahora, siempre que retornamos recursos de webapi usamos entidades de nuestra app.
		-Cuando se habla de entidades nos referimos a esas clases que sirven para modelar una tabbla en nuestra BBDD como autor y libro.
		-Uno de los inconvenientes de esto es que en ocasiones no se quiere ostrar toda l data contenida en estas entidades.
		-Es normal querer mostrar solo un pequeño conjunto de datos y no todo
		-En otras ocasiones, se necesita transformar la data que se quiere mostrar.
		-Por ejemplo, concatenando nombres y apellidos.
		-Una manera de resolver esto es usando objetos de transferencia de datos.
		-Un objetos de transferencia de datos, DTO, Data transfer Object es un objeto que sirve para transportar datos entre procesos.
		-Nosotros usaremos DTOs para representar lso datos que nuestro webapi enviara y recibira de clientes.
		-Se va a comenzar creando DTO que resuelve el problema de lectura de Autores.
		-Se crea nueva carpeta para colocar DTOs. Se crea nueva clase.Se crea la clase AutorDTO.
		-Va a servir para representar una operacion de lectura o consulta de lectura sobre la tabla de autores.
		-Aqu se coloca lo que se quiere que los clientes del WebAPI vean de un Autor.
		-Se mete Id y NombreCompleto.
		public class AutorDTO
		{
			public int Id { get; set; }
			public required string NombreCompleto { get; set; }
		}
		
		-Se va a AutoresController y se va a l get de obtener todos.
		
		ANTES
		[HttpGet] // /api/autores/
		public async Task<IEnumerable<Autor>> Get()
		{
			return await context.Autores.ToListAsync();

		}
		
		DESPUES
		-Select permite transofrmar de un tipo de dato a otro. Se transforma de Autor a AutorDTO.
		-El resumen de lo que se hace aqui es ir a BBDD y obtener el listado de autores, luego no se quiere retornar toda la data de autores, identifica ry nombres y apellidos separados sino como se presemnta en AutorDto.
		-Se hace autores.select para transformar el listado de autores en un listado de AutorDto. autor representa un autor del listadod e autores y se transforma a AutorDTO.
		-Id = autor.ID y el NombreCompleto es la concatenacion.Se usa para ello stringInterpolation.
		[HttpGet] // /api/autores/
		public async Task<IEnumerable<AutorDTO>> Get()
		{
			var autores = await context.Autores.ToListAsync();
			var autoresDTO = autores.Select(autor => 
											new AutorDTO 
											{
												Id = autor.Id,
												NombreCompleto = $"{autor.Nombres} {autor.Apellidos}"
											});
			return autoresDTO;
		}
		
		-Se va a hacer la llamada GET ahora para comprobarlo.
		-En general, es buena practica usar DTO cuando se usan WebAPIs. Se complica cuando se tienen entidades con muchas propeidades.
		-En nuestro caso el mapeo es de dos propeidades cuando hay 20 o 50 seria tedioso y propenso a errores a hacer ese mapeo manualmente.
		-Existen herramientas que nos facilitan ese trabajo.
		-Se peude usar Automapper.
		-Click derecho en el proyecto de WebAPI Administrar paquetes nugget para instalarlo.
		-Se busca el Automapper y se instala.
		-Se va a la clase Program proque se tiene que configurar AutoMapper.
		-Se hace desde el area de servicios. Con esto se configura AutoMapper en la app y estamos indicando que los mapeos se van a configurar dentro del proyecto que se tiene ahi.
		-Eso se indica con el typeof(Program). Ahi se le dice que busque las configuraciones que se encuentren en el proyecto que contiene la clase Program.
		builder.Services.AddAutoMapper(typeof(Program));
		
		-Ahora se quiere usar y se crea una folder que se llamará utilidades y se meterá la clase AutoMapperProfiles. Se le llama profiles a este tipos de clases que tienen el mapeo de Automapper.
		-Se hereda de profile y se tiene un ctor y se colocan los mapeos.
		-Para configurar un mapeo se pone CreateMap que significa crear mapeo que va desde Autores a AutorDto.
		-Este apeo se mapea concatenando nombres y appelidos. S epone forMember. Como obtengo el NombreCompleto?
		 Se pone config.MapFrom se dice de donde sale el NombreCompleto que sale del Autor.
		public class AutoMapperProfiles: Profile
		{
			public AutoMapperProfiles()
			{
				CreateMap<Autor, AutorDTO>()
					.ForMember(dto => dto.NombreCompleto,
						config => config.MapFrom(autor => $"{autor.Nombres} {autor.Apellidos}"));
			}

		}
		
		-Se va a AutoresController y se inyecta el IMapper que e sun servicio de AutoMapper para usar ese mapeo que hemos configurado.
		private readonly ApplicationDbContext context;
		private readonly IMapper mapper;

		public AutoresController(ApplicationDbContext context, IMapper mapper)
		{
			this.context = context;
			this.mapper = mapper;
		}
		
		-Se cambia lo que se tenia antes en HTTPGet.
		[HttpGet] // /api/autores/
		public async Task<IEnumerable<AutorDTO>> Get()
		{
			var autores = await context.Autores.ToListAsync();
			var autoresDTO = autores.Select(autor => 
											new AutorDTO 
											{
												Id = autor.Id,
												NombreCompleto = $"{autor.Nombres} {autor.Apellidos}"
											});
			return autoresDTO;
		}
		
		Ahora
		[HttpGet] // /api/autores/
		public async Task<IEnumerable<AutorDTO>> Get()
		{
			var autores = await context.Autores.ToListAsync();
			var autoresDTO = mapper.Map<IEnumerable<AutorDTO>>(autores);
			return autoresDTO;
		}
				
		-Se prueba la peticion get.
		
		-Se hace lo mismo para la consulta de ObtenerAutor.
		[HttpGet("{id:int}", Name = "ObtenerAutor")] // api/autores/id
		public async Task<ActionResult<Autor>> Get(int id)
		{
			var autor = await context.Autores
				.Include(x => x.Libros)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (autor is null)
			{
				return NotFound();
			}

			return Ok(autor);

		}
		
		Despues
		[HttpGet("{id:int}", Name = "ObtenerAutor")] // api/autores/id
		public async Task<ActionResult<AutorDTO>> Get(int id)
		{
			var autor = await context.Autores
				.Include(x => x.Libros)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (autor is null)
			{
				return NotFound();
			}

			var autorDTO = mapper.Map<AutorDTO>(autor);

			return autorDTO;

		}
		
		-Se va a hacer idem con la peticion POST.
		[HttpPost]
		public async Task<ActionResult> Post(Autor autor) {
			context.Add(autor);
			await context.SaveChangesAsync();
			return CreatedAtRoute("ObtenerAutor", new { id = autor.Id }, autor);
		}
		
		DESPUES
		[HttpPost]
		public async Task<ActionResult> Post(Autor autor) {
			context.Add(autor);
			await context.SaveChangesAsync();
			var autorDTO = mapper.Map<AutorDTO>(autor);
			return CreatedAtRoute("ObtenerAutor", new { id = autor.Id }, autorDTO);
		}
		
		-Se necesita un autor para crear.
		-Se va a carpeta de DTOs y se agrega clase. llevamos todo menos el Id. Nos llevamos todo con lo que se tiene que crear el Autor.
		public class AutorCreacionDTO
		{
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Nombres { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(20, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Apellidos { get; set; }
			public string? identificacion { get; set; }
		}
		
		-Se va a AutoMapperProfiles y se crea el mapeo que va desde AutorCreacionDto a Autor.
		CreateMap<AutorCreacionDTO, Autor>();
		
		-Se va a AutoresControlelr. Se cambia el POST.
		ANTES
		[HttpPost]
		public async Task<ActionResult> Post(Autor autor) {
			context.Add(autor);
			await context.SaveChangesAsync();
			var autorDTO = mapper.Map<AutorDTO>(autor);
			return CreatedAtRoute("ObtenerAutor", new { id = autor.Id }, autorDTO);
		}
		
		DESPUES
		[HttpPost]
		public async Task<ActionResult> Post(AutorCreacionDTO autorCreacionDTO) {
			var autor = mapper.Map<Autor>(autorCreacionDTO);
			context.Add(autor);
			await context.SaveChangesAsync();
			var autorDTO = mapper.Map<AutorDTO>(autor);
			return CreatedAtRoute("ObtenerAutor", new { id = autor.Id }, autorDTO);
		}
		
		Lo mismo en PUT. Se ve que se puede reutilizar el AutoresCreacionDTO porque se tienen las mismas propiedades. Si se tuviesen diferentes propiedades, entonces es cuando
		cambia la cosa y habria que crear un DTO para la actualizacion.
		[HttpPut("{id:int}")] // api/autores/1 
		public async Task<ActionResult> Put(int id, Autor autor)
		{
			if (id != autor.Id)
			{
				return BadRequest("Los IDs deben de coincidir");
			}

			context.Update(autor);
			await context.SaveChangesAsync();
			return Ok();

		}
		
		-Se quita la validacion porque se ve que ya AutorCreacionDTO no tiene id.
		[HttpPut("{id:int}")] // api/autores/1 
		public async Task<ActionResult> Put(int id, AutorCreacionDTO autorCreacionDTO)
		{
			var autor = mapper.Map<Autor>(autorCreacionDTO);
			autor.Id = id;
			context.Update(autor);
			await context.SaveChangesAsync();
			return Ok();

		}
		
		-En delete se ve que no hay entidades utilizadas. No se hace nada.
		-Se va a Postman y se crea Felipe Reyes con el Post.
		https://localhost:7132/api/autores
		{
			"nombres": "Felipe",
			"apellidos": "Reyes",
			"identificacion": "789"
		}
		
		-Se comprueba que se ha creado el registro en BBDD y se lanza un PUT para actualizarlo. El id se saca del recien creado.
		https://localhost:7132/api/autores/8
		{
			"nombres": "Felipe",
			"apellidos": "Reyes - Actualizado",
			"identificacion": "7890"
		}
		
	71. DTOs de Libros
		-Esto es lo que ya se hizo....
		-Se va a crear LibroDTO.
		public class LibroDTO
		{
			public int Id { get; set; }
			public required string Titulo { get; set; }
		}
		
		-En autores se tiene un listado de libros por lo que hay que modificar el DTO de AutorDTO. Se  puede poner de las dos formas...
		public List<LibroDTO> Libros { get; set; } = new List<LibroDTO>();
		public List<LibroDTO> Libros { get; set; } = [];
		
		-Se configura el mapeo en AutoMapperProfiles: CreateMap<Libro, LibroDTO>();
		-Se va a LibrosController, se inyecta el servicio de AutoMapper.
		private readonly ApplicationDbContext context;
		private readonly IMapper mapper;

		public LibrosController(ApplicationDbContext context, IMapper mapper) {
			this.context = context;
			this.mapper = mapper;
		}
		
		-Se cambia el GET
		//Peticiones
		[HttpGet]
		public async Task<IEnumerable<Libro>> Get()
		{
			return await context.Libros.ToListAsync();
		}
		
		DESPUES
		[HttpGet]
		public async Task<IEnumerable<LibroDTO>> Get()
		{
			var libros =  await context.Libros.ToListAsync();
			var librosDTO = mapper.Map<IEnumerable<LibroDTO>>(libros);
			return librosDTO;
		}
		
		-Lo mismo con ObtenerLibro.
		[HttpGet("{id:int}", Name = "ObtenerLibro")] // /api/libros/1
		public async Task<ActionResult<Libro>> Get(int id)
		{
			var libro = await context.Libros
				.Include(x => x.Autor)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (libro is null)
			{
				return NotFound();
			}

			return Ok(libro);
		}
		
		DESPUES
		[HttpGet("{id:int}", Name = "ObtenerLibro")] // /api/libros/1
		public async Task<ActionResult<LibroDTO>> Get(int id)
		{
			var libro = await context.Libros
				.Include(x => x.Autor)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (libro is null)
			{
				return NotFound();
			}

			var libroDTO = mapper.Map<LibroDTO>(libro);

			return libroDTO;
		}
		
		-En el POST se mapea hacia libro.
		[HttpPost]
		public async Task<ActionResult> Post(Libro libro)
		{
			var existeAutor = await context.Autores.AnyAsync(x => x.Id == libro.AutorId);

			if (!existeAutor)
			{
				ModelState.AddModelError(nameof(libro.AutorId), $"El autor de id {libro.AutorId} no existe");
				return ValidationProblem();
				// return BadRequest($"El autor de id {libro.AutorId} no existe");
			}

			context.Add(libro);
			await context.SaveChangesAsync();
			return CreatedAtRoute("ObtenerLibro", new { id = libro.Id }, libro);
		}
		
		DESPUES
		[HttpPost]
		public async Task<ActionResult> Post(Libro libro)
		{
			var existeAutor = await context.Autores.AnyAsync(x => x.Id == libro.AutorId);

			if (!existeAutor)
			{
				ModelState.AddModelError(nameof(libro.AutorId), $"El autor de id {libro.AutorId} no existe");
				return ValidationProblem();
			}

			context.Add(libro);
			await context.SaveChangesAsync();

			var libroDTO = mapper.Map<LibroDTO>(libro);

			return CreatedAtRoute("ObtenerLibro", new { id = libro.Id }, libroDTO);
		}
		
		-Se quiere un DTO para crear un libro asi que se crea esa clase.
		public class LibroCreacionDTO
		{
			[Required]
			[StringLength(250, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			public required string Titulo { get; set; }
			public int AutorId { get; set; }
		}
		
		-Se hace el mapeo en AutoMapperprofiles.
		CreateMap<LibroCreacionDTO, Libro>();
		
		-En LibrosController se modifica el Post.
		[HttpPost]
		public async Task<ActionResult> Post(LibroCreacionDTO libroCreacionDTO)
		{
			var libro = mapper.Map<Libro>(libroCreacionDTO);
			var existeAutor = await context.Autores.AnyAsync(x => x.Id == libro.AutorId);

			if (!existeAutor)
			{
				ModelState.AddModelError(nameof(libro.AutorId), $"El autor de id {libro.AutorId} no existe");
				return ValidationProblem();
			}

			context.Add(libro);
			await context.SaveChangesAsync();

			var libroDTO = mapper.Map<LibroDTO>(libro);

			return CreatedAtRoute("ObtenerLibro", new { id = libro.Id }, libroDTO);
		}
		
		Se modifica el PUT
		[HttpPut("{id:int}")]
		public async Task<ActionResult> Put(int id, Libro libro)
		{
			if(id != libro.Id)
			{
				return BadRequest("Los IDs deben de coincidir");
			}

			var existeAutor = await context.Autores.AnyAsync(x => x.Id == libro.AutorId);

			if (!existeAutor)
			{
				return BadRequest($"El autor de id {libro.AutorId} no existe");
			}

			context.Update(libro);
			await context.SaveChangesAsync();
			return Ok();
		}
		
		DESPUES
		[HttpPut("{id:int}")]
		public async Task<ActionResult> Put(int id, LibroCreacionDTO libroCreacionDTO)
		{
			var libro = mapper.Map<Libro>(libroCreacionDTO);
			libro.Id = id;

			var existeAutor = await context.Autores.AnyAsync(x => x.Id == libro.AutorId);

			if (!existeAutor)
			{
				return BadRequest($"El autor de id {libro.AutorId} no existe");
			}

			context.Update(libro);
			await context.SaveChangesAsync();
			return Ok();
		}
		
		-Se prueba. Se va a get de un autor que tenga libros. No se han creado libros porque al borrar autores, se han borrado sus libros.
		-Se crea un libro.
		https://localhost:7132/api/libros POST
		{
			"Titulo": "Libro1",
			"autorId": 6
		}
		
		
		-Luego se hace GET del autor de ese libro.
		-Luego se hace un get al libro recien creado.
		-Luego un PUT del libro.
		https://localhost:7132/api/libros/6
		{
			"Titulo": "Libro1 - ACTUALIZADO",
			"autorId": 6
		}
		
	72. DTOs que suman
		-Se va a ir a Postman y se hacen opruebas.
		-En el listado de autores, aparecen libros vacios.
		-En el listado de libros tampoco aparece el Id y nombre de autor.
		-Distintas acciones tienen distintas necesidades.
		-Se van a crear DTOs distintos para cada caso y para no repetir code se puede usar herencia.
		
		-En el listado de Autores viene el listado de libros vacios.
		-Se crea DTO de Autor con  libros.
		-Se tieen dos versiones una con el listado de libros y otra sin el listado de libros.
		-Se llama AutorConLibrosDTO.
		public class AutorConLibrosDTO: AutorDTO
		{
			public List<LibroDTO> Libros { get; set; } = new List<LibroDTO>();
		}
		
		-AutorDTO
		public class AutorDTO
		{
			public int Id { get; set; }
			public required string NombreCompleto { get; set; }
		}
		
		-Sis e quiere AutorDTO sin libros se usa AutorDTo, si se quiere con libros AutorConLibrosDTO que hereda de esta ultima y ya tiene Id y Titulo.
		-Se va a AutoMapperProfiles y se mete esto:
		CreateMap<Autor, AutorConLibrosDTO>()
		.ForMember(dto => dto.NombreCompleto,
			config => config.MapFrom(autor => $"{autor.Nombres} {autor.Apellidos}"));
		
		-Se va a AutoresController y en el GET se devuelve el listado de autores sin los libros.
		-Pero en GET por ID, si se quiere usar AutorConLIbrosDTO.
		[HttpGet("{id:int}", Name = "ObtenerAutor")] // api/autores/id
		public async Task<ActionResult<AutorConLibrosDTO>> Get(int id)
		{
			var autor = await context.Autores
				.Include(x => x.Libros)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (autor is null)
			{
				return NotFound();
			}

			var autorDTO = mapper.Map<AutorConLibrosDTO>(autor);

			return autorDTO;
		}
		-Ahora se ve que en el listado de libros ya no se listan los libros de un autor. No se rellena un array que no se iba a rellenar...
		
		-Para el detalle del libro, se quiere que se devuelva la data con el autor.
		-Se crea DTO de libro con autor...
		public class LibroConAutorDTO: LibroDTO
		{
			public int AutorId { get; set; }
			public required string AutorNombre { get; set; }
		}
		
		-se hereda de LibroDto para usar el Id y Titulo del Libro.
		-Se va a AutoMapperporofiles.
		CreateMap<Libro, LibroConAutorDTO>()
			.ForMember(dto => dto.AutorNombre, config =>
				config.MapFrom(ent => $"{ent.Autor!.Nombres} {ent.Autor.Apellidos}"));

		-En LibroController en et por Id.
		 [HttpGet("{id:int}", Name = "ObtenerLibro")] // /api/libros/1
		 public async Task<ActionResult<LibroConAutorDTO>> Get(int id)
		 {
			 var libro = await context.Libros
				 .Include(x => x.Autor)
				 .FirstOrDefaultAsync(x => x.Id == id);

			 if (libro is null)
			 {
				 return NotFound();
			 }

			 var libroDTO = mapper.Map<LibroConAutorDTO>(libro);

			 return libroDTO;
		 }
		 
		 -En obtener LibroPorId ahora trae la data con el autor. Se hace la consulta desde PostMan.
		 
		-Como esta venga repetirse una parte del code en AutoMapper se va a colocar eso en una funcion....
		config => config.MapFrom(autor => $"{autor.Nombres} {autor.Apellidos}"));
		
		public AutoMapperProfiles()
		{
			CreateMap<Autor, AutorDTO>()
				.ForMember(dto => dto.NombreCompleto,
					config => config.MapFrom(autor => MapearNombreYApellidoAutor(autor)));

			CreateMap<Autor, AutorConLibrosDTO>()
				.ForMember(dto => dto.NombreCompleto,
					config => config.MapFrom(autor => MapearNombreYApellidoAutor(autor)));

			CreateMap<AutorCreacionDTO, Autor>();

			CreateMap<Libro, LibroDTO>();
			CreateMap<LibroCreacionDTO, Libro>();

			CreateMap<Libro, LibroConAutorDTO>()
				.ForMember(dto => dto.AutorNombre, config =>
					config.MapFrom(ent => MapearNombreYApellidoAutor(ent.Autor!)));
		}

		private string MapearNombreYApellidoAutor(Autor autor) => $"{autor.Nombres} {autor.Apellidos}";
		
	73. Leyendo Registros de EF Core
		-Vamos a AutoresController y vemos que obtenemos el listado de Autores.
		-La forma mas sencilla se ve que es autores = await context.Autores.ToListAsync();
		-Si se quiere obtener un autor por su id, se hace context.Autores y se dice include para obtener la data relacionada de libros. COn ForstOrdefaultAsync para obtener
		el primer registro o un valor por defecto y que cumpla que su id sea igual al valor que se pasa por parametro.
		Con eso se obtiene el primer autor que tenga ese id como su id o un valor por defecto que seria nulo.
		Si es nulo se retorna 404, sino el Autor.
		-Con Where tambien se pueden filtrar varios registros.
		-Si fuera alguna caracteristica que muchos autores tuvieran y se quiere obtener un listado de autores peor con una caracteristica. Para eso, se usa 
		 WHERE. Eso se hace en el delete context.Autores.Where. Se ve que se borra por Id.
	
	74. Actualizando Recursos
		-Se va a repasar la parte de editar un recurso. Para esto se usa el http PUT. 
		-Se pasa el Id porque se edita un recuros especifico y por eso se añade en la URL.
		-Se recibe el id del recurso y el recurso como tal.
		-En caso de EF se usa Update para marcar el objeto para ser actualizado y ya cuando se hace el SaveChangesAsync se actualiza el el regsitro de la bdd.
		-Algo que no es obligatorio pero si estandar es que en caso de actualizacion ya que cliente tiene el recurso que quiere actualizar. 
		 Por qpara actualizar el recurso, tienes qe tenerlo. No se suele retornar un Ok(), sino un NoContent que es un 204.
		-Esto es un estandar en Web APIs.
		-Esto retorna un 204 NotContent que es todo OK, pero no te puedo retornar nada porque tienes ya el recurso que has actualziado.
		[HttpPut("{id:int}")] // api/autores/1 
		public async Task<ActionResult> Put(int id, AutorCreacionDTO autorCreacionDTO)
		{
			var autor = mapper.Map<Autor>(autorCreacionDTO);
			autor.Id = id;
			context.Update(autor);
			await context.SaveChangesAsync();
			return Ok();

		}
		
		Por esto:
		[HttpPut("{id:int}")] // api/autores/1 
		public async Task<ActionResult> Put(int id, AutorCreacionDTO autorCreacionDTO)
		{
			var autor = mapper.Map<Autor>(autorCreacionDTO);
			autor.Id = id;
			context.Update(autor);
			await context.SaveChangesAsync();
			return NoContent();

		}
		
		-Idem se hace con el Delete.
		-Con Libros Idem.
		
	75. HTTP Patch y JSON patch
		-Se usa este para aplicar actualizaciones aprciales a un recurso. Si se tiene un recuros y solo se quieren actualizar unos pocos campos de este,
		 y no todos este el metodo HTTP a usar. El cliente enviara un cuerpo en la peticion HTTP el cual indicara los cambios que desea hacer sobre el recurso.
		 Se tiene qie saber los campos que desea modificar el cliente y cuales van a ser los nuevos valores.
		-Como indica el cliente esta info? El RFC 5789 no dice mucho acerca de como debe ser esa estructura.
		-Por suerte, existe un estandar en RFC 6902 llamado JSON Patch.
		-Este se usa para HTTP Patch. El JSON Patch indica como debe ser la estructura del cuerpo de la peticion HTTP que indica los cambios que el cliente quiere hacer sobre el recuros.
		-Este estandar define un cjto de oepraciones: agregar, remover, reemplezar, mover, copiar y pegar. A nosotros nos interesa reemplazar la cual usaremos para actualziar
		 campos de un recurso. 
		-Ejemplo de cuerpo de reemplazo:
			[
				{"op": "replace", "path": "/nombres", "value": "Felipe Gavilan"},
				{"op": "replace", "path": "/identificacion", "value": "123"},
			]
			
		-op es la oepracion. path dice el campo y el value el valor que tomara el campo.
		
	76. Actualizando solo algunos campos con HTTP Patch
		-Se instala primero un paquete Nugget: Se descarga el NewtonsoftJSON:Microsoft.AspNetCore.Mvc.NewtonsoftJson
		-Incluye el input y output del JSONPatch
		-Se configura el uso del NewtonSoft para poder usar el JSON Patch.
		-Se va a la clase Program. Ya no se necesita JsonOptions porque se esta devolviendo DTOs.
		-Ahora se usa AddNewtonSoftJSON.
		builder.Services.AddControllers().AddJsonOptions(opciones => 
		opciones.JsonSerializerOptions.ReferenceHandler = ReferenceHandler.IgnoreCycles);
		
		Por esto:
		builder.Services.AddControllers().AddNewtonsoftJson();
		
		-Se crea nuevo DTO para el patch: AutorPatchDTO. Nos llevamos lo de AutorCreacionDTO.
		public class AutorPatchDTO
		{
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Nombres { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(20, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Apellidos { get; set; }
			public string? identificacion { get; set; }
		}
		
		-Se va a AutoresController para añadir la accion correspondiente.
		-Se mete debajo de PUT. Se mete un condicional porque si el patchDoc es nulo es que el cuerpo de la peticion tiene algun error.
		-Se va a BBDD y se busca autor correspondiente. Sino se encuentra se devuelve un NotFound.
		-Se hace mapeo de autor a autorPatchDto.
		-Se valida que el campo nombr eo apellidos este relleno.
		-No hay que hacer contextUpdate por ue autorDB fue obtenido de ese contexto y EF ya sabe que hay un registro de la tabla autores que
		 se coirresponde con objeto autorDB.
		[HttpPatch("{id:int}")]
		public async Task<ActionResult> Patch(int id, JsonPatchDocument<AutorPatchDTO> patchDoc)
		{
			if (patchDoc is null)
			{
				return BadRequest();
			}

			var autorDB = await context.Autores.FirstOrDefaultAsync(x => x.Id == id);

			if (autorDB is null)
			{
				return NotFound();
			}

			var autorPatchDTO = mapper.Map<AutorPatchDTO>(autorDB);

			patchDoc.ApplyTo(autorPatchDTO, ModelState);

			var esValido = TryValidateModel(autorPatchDTO);

			if (!esValido)
			{
				return ValidationProblem();
			}

			mapper.Map(autorPatchDTO, autorDB);

			await context.SaveChangesAsync();

			return NoContent();
		}
		
		-Hay que ir a AutoMapperProfiles. Hay que mapear de autor a AutorPatchDTO.
		-Hay otro mapeo de AutorPatchDTO a Autor. Con ReverseMap va en ambos sentidos.
		CreateMap<Autor, AutorPatchDTO>().ReverseMap();
		
		-Se va a PostMan.
		-Se hace un Patch de un Autor para modificar un Autor.
		[
			{"op": "replace", "path": "/nombres", "value": "Felipe 2"}
		]
		
		[
			{"op": "replace", "path": "/nombres", "value": "Felipe"},
			{"op": "replace", "path": "/apellidos", "value": "Reyes"},
		]
		
		-Si le mando un campo de nombres vacio, tiene que devovler un Validationproblem con el campo requerido, la priemra tiene que ser mayus etc.
		
	77. Borrando Recursos
		-Se va a AutoresController. Se borra con HTTP Delete. para borrar un registro se usa ExecuteDeleteAsync que le dices tabla que contiene registros, usas filtro para indicar registros 
		 borrar y esto retorna cantidad de regs borrados.
		-Espo se guarda en vble. Si es igual a cero no ha sibdo nada borrado y ene se caso no existe autor con ese ID y se devuelve 404 Not Found. Si es disitnto de cero, se 
		retorna un 204 NoContent. Se esta borrando un reg, pero podria estar borrandose mas.....
	
	78. Relación Uno a Muchos
		-Se crea nueva relación entre libros y comentarios.
		-Se pueden escribir comentarios acerca de los libros que se han leido.
		-Se hizo entre autores y libros ya.
		-Se crea nueva Entidad. Se hace desde Entidades. El Id sera un GUID que es un string aleatorio se hace esto en comentario porque se espera tener miles, cientos de miles de comentarios
		 pues se usa un GUID para no acabarse los numeros. En enteros hay 2mil millones de comentarios y se espera tener mas....
		public class Comentario
		{
			public Guid Id { get; set; }
			public required string  Cuerpo { get; set; }
			public DateTime FechaPublicacion { get; set; }
			public int LibroId { get; set; }
			public Libro? Libro { get; set; }
		}
		
		-Se va al ApplicationDbContext y se añade el DbSet concreto.
		-public DbSet<Comentario> Comentarios { get; set; }
		
		-En Libro, se coloca el listado de Comentarios: public List<Comentario> Comentarios { get; set; } = new List<Comentario>();
		
		-Se añade la migracion: Add-Migration TablaComentarios.
		-Se mete Update-Database.
		-Se va a SQL Server Management Studio y se ve la nueva tabla.
	
	79. Controlador de un Recurso Dependiente
		-La relacion entre libros y comentarios es peculiar porque un comentario no tiene sentido sin un libro.
		-Por tanto, estamos ante relacion dependiente, donde el comentario depende del libro.
		-Esto se peude modelar en ruta de los comentarios colocando siempre el id del libro en cualquier ruta de mi controlador de comentarios.
		-Se crea controlador de comentarios.
		-Se coloca en la ruta el id del Libro al que le corresponde el comentario.
		-Para acceder al comentario de un libro, tengo que decir api/libros/id_libro/scomentarios. Asi permite ejecutar las acciones de 
		 este controlador que tenemos aqui.
		[ApiController]
		[Route("api/libros/{libroId:int}/comentarios")]
		public class ComentariosController: ControllerBase
		{
			private readonly ApplicationDbContext context;
			private readonly IMapper mapper;

			public ComentariosController(ApplicationDbContext context, IMapper mapper)
			{
				this.context = context;
				this.mapper = mapper;
			}
		}
		
		-Se crean los DTOs correspondientes.
		-Se cambia esto en comentario porque no tiene sentido un comentario sin cuerpo.
		[Required]
		public required string  Cuerpo { get; set; }
		
		public class ComentarioCreacionDTO
		{
			[Required]
			public required string Cuerpo { get; set; }
		}
		
		-No se incluye el Id del libro porque se incluye en la URL.
		
		-Este es el de lecyura y por eso no se pone Required.
		public class ComentarioDTO
		{
			public Guid Id { get; set; }
			public required string Cuerpo { get; set; }
			public DateTime FechaPublicacion { get; set; }
		}
		
		-Se va a AutoMapperProfiles.
		CreateMap<ComentarioCreacionDTO, Comentario>();
		CreateMap<Comentario, ComentarioDTO>();
		
		-Se crea ComentariopatchDTO. Se hereda de ComentarioCreacionDTO para no estar repticiendo code.
		public class ComentarioPatchDTO: ComentarioCreacionDTO
		{
		}
		
		-Se mappea.
		CreateMap<ComentarioPatchDTO, Comentario>().ReverseMap();
		
		-Se hace el get en ComentariosController. Se obtienen comentarios de un libro.
		-libroId proviene de la ruta.
		-Se comprueba existencia del libro para no estar buscando comentarios de un libro inexistente.
		[HttpGet]
		public async Task<ActionResult<List<ComentarioDTO>>> Get(int libroId)
		{
			var existeLibro = await context.Libros.AnyAsync(x => x.Id == libroId);

			if (!existeLibro)
			{
				return NotFound();
			}

			var comentarios = await context.Comentarios
				.Where(x => x.LibroId == libroId)
				.OrderByDescending(x => x.FechaPublicacion)
				.ToListAsync();

			return mapper.Map<List<ComentarioDTO>>(comentarios);
		}
		
		-Se otiene comentario por su id. 
		[HttpGet("{id}", Name ="ObtenerComentario")]
		public async Task<ActionResult<ComentarioDTO>> Get(Guid id)
		{
			var comentario = await context.Comentarios.FirstOrDefaultAsync(x => x.Id == id);

			if(comentario is null)
			{
				return NotFound();
			}

			return mapper.Map<ComentarioDTO>(comentario);
		}
		
		-Se hace un POST.
		[HttpPost]
		public async Task<ActionResult<ComentarioDTO>> Post(int libroId, ComentarioCreacionDTO comentarioCreacionDTO)
		{
			var existeLibro = await context.Libros.AnyAsync(x => x.Id == libroId);

			if (!existeLibro)
			{
				return NotFound();
			}

			var comentario = mapper.Map<Comentario>(comentarioCreacionDTO);
			comentario.LibroId = libroId;
			comentario.FechaPublicacion = DateTime.Now;
			context.Add(comentario);
			await context.SaveChangesAsync();

			var comentarioDTO = mapper.Map<ComentarioDTO>(comentario);

			return CreatedAtRoute("ObtenerComentario", new { id = comentario.Id, libroId }, comentarioDTO);
		}
		
		-En el comentario no se usa PUT, sino PATCh porque tenemos campos como FechaPublicacion que nunca se vana a recibir a traves de ComentarioCreacionDTO.
		-Es idem a HttpPatch de AutoresController. Se copia de ahi.
		[HttpPatch("{id}")]
		public async Task<ActionResult> Patch(Guid id, int libroId, JsonPatchDocument<ComentarioPatchDTO> patchDoc)
		{
			if (patchDoc is null)
			{
				return BadRequest();
			}

			var existeLibro = await context.Libros.AnyAsync(x => x.Id == libroId);

			if (!existeLibro)
			{
				return NotFound();
			}

			var comentarioDB = await context.Comentarios.FirstOrDefaultAsync(x => x.Id == id);

			if (comentarioDB is null)
			{
				return NotFound();
			}

			var comentarioPatchDTO = mapper.Map<ComentarioPatchDTO>(comentarioDB);

			patchDoc.ApplyTo(comentarioPatchDTO, ModelState);

			var esValido = TryValidateModel(comentarioPatchDTO);

			if (!esValido)
			{
				return ValidationProblem();
			}

			mapper.Map(comentarioPatchDTO, comentarioDB);

			await context.SaveChangesAsync();

			return NoContent();
		}
		
		-Se mete el Delete.
		[HttpDelete("{id}")]
		public async Task<ActionResult> Delete(Guid id, int libroId)
		{
			var existeLibro = await context.Libros.AnyAsync(x => x.Id == libroId);

			if (!existeLibro)
			{
				return NotFound();
			}

			var registrosBorrados = await context.Comentarios.Where(x => x.Id == id).ExecuteDeleteAsync();

			if (registrosBorrados == 0)
			{
				return NotFound();
			}

			return NoContent();
		}
		
		-Se busca el id de un libro en Sql Server Management Studio y se va a postMan.
		GET https://localhost:7132/api/libros/6/comentarios Vacio porque no hay comentarios.
		POST https://localhost:7132/api/libros/6/comentarios
		
		
		-Por headers, se coge URl: https://localhost:7132/api/libros/6/comentarios/9714303a-4ada-4d51-0f13-08dd59b9b19c
		Se hace GET
		Se duplica y se hace Patch.
		[
			{
				"op": "replace",
				"path": "cuerpo",
				"value": "Muy buen Libro - ACTUALIZADO"
			}
		]
		
		-Se vuelve a hacer GET y se ve RDO. Se podria hacer DELETE.
		
	80. Relación Muchos a Muchos
		-Es tiempo de que exploremso esto.
		-Es la relación natural entre autores y libros, porque un autor puede escribirmuchos libros, mientras que un libro puede ser escrito por varios autores.
		-Es como tener dos relaciones uno a muchos combinadas. Uno a muchos de autores a libros y uno a muchos de libros a autores.
		-Esta relacion recibe el nombre de muchos a muchos.
		-Al principio, se puso la relacion de 1 a N para mantener esto simple.
		-Se va a crear una relacion mas realista.
		-La relacion muchos a muchos se modela con tabla intermedia. Es decir, se creara una tabla que contendra las distintas relacioens entre autores y libros.
		-Se crea nueva Entidad.
		public class AutorLibro
		{
			public int AutorId { get; set; }
			public int LibroId { get; set; }
		}
		
		-Se quiere campo orden porque se quiere poder ordenar el listado de autores de un libro.
		-Tipicamente, el primer autor que sale es el que mas contribuyó al libro.
		-Se necesitan props de navegacion.
		-No se tiene propiedad Id porque la propiedad primaria de AutorLibro es composicion de AutorId y LibroId, como son dos se pone lo de Primarykey.
		-Asi se garantiza la unicdad, es decir que no va a haber dos regs que tengan mismo autor y mismo libro
		[PrimaryKey(nameof(AutorId), nameof(LibroId))]
		public class AutorLibro
		{
			public int AutorId { get; set; }
			public int LibroId { get; set; }
			public int Orden { get; set; }
			public Autor? Autor { get; set; }
			public Libro? Libro { get; set; }
		}
		
		-Se cambia Libro.
		public class Libro
		{
			public int Id { get; set; }
			[Required]
			[StringLength(250, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			public required string Titulo { get; set; }
			public int AutorId { get; set; }
			public Autor? Autor { get; set; }

		}
		
		public class Libro
		{
			public int Id { get; set; }
			[Required]
			[StringLength(250, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			public required string Titulo { get; set; }
			public List<AutorLibro> Autores { get; set; } = [];
			public List<Comentario> Comentarios { get; set; } = [];

		}
		
		-Se cambia Autor.
		public class Autor
		{
			public int Id { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Nombres { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(20, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Apellidos { get; set; }
			public string? identificacion { get; set; }
			public List<Libro> Libros { get; set; } = new List<Libro>();
		}
		
		public class Autor
		{
			public int Id { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Nombres { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(20, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Apellidos { get; set; }
			public string? identificacion { get; set; }
			public List<AutorLibro> Libros { get; set; } = [];
		}
		
		-Se va a ApplicationDbContext y se hace esto:
		public DbSet<AutorLibro> AutoresLibros { get; set; }
		
		-Se comenta el HttpPost y el HttpPut de LibrosController porque sino hay errores.
		-En el ObtenerLibro, se cambia esto.
		[HttpGet("{id:int}", Name = "ObtenerLibro")] // /api/libros/1
		public async Task<ActionResult<LibroConAutorDTO>> Get(int id)
		{
			var libro = await context.Libros
				.Include(x => x.Autor)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (libro is null)
			{
				return NotFound();
			}

			var libroDTO = mapper.Map<LibroConAutorDTO>(libro);

			return libroDTO;
		}
		
		[HttpGet("{id:int}", Name = "ObtenerLibro")] // /api/libros/1
		public async Task<ActionResult<LibroConAutorDTO>> Get(int id)
		{
			var libro = await context.Libros
				.Include(x => x.Autores)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (libro is null)
			{
				return NotFound();
			}

			var libroDTO = mapper.Map<LibroConAutorDTO>(libro);

			return libroDTO;
		}
		
		-Se comenta esto en mapeos:
		//CreateMap<Libro, LibroConAutorDTO>()
		//    .ForMember(dto => dto.AutorNombre, config =>
		//        config.MapFrom(ent => MapearNombreYApellidoAutor(ent.Autor!)));
		
		-Se compila el proyecto y se le da a Add-Migration.
		Add-Migration TablaAutoresLibros
		
		-Se da advertencia porque se va a eliminar columna AutorId en Libros. ya nos e tiene porque la tabla intermedia AutoresLibros es la que va a modela esta relacion.
		-Update-Database
		-Se va a SQL Server Management Studio y se ve que ya no se tiene la columna AutorId y se tiene la doble primary key con AutorId y LibroId.
	
	81. Insertando Datos en una Relación Muchos a Muchos
		-Para crear uun libro no se envia solo un autor, sino varios.
		-Se va a LibroCreacionDTO y se cambia la ultima propiedad.
		public class LibroCreacionDTO
		{
			[Required]
			[StringLength(250, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			public required string Titulo { get; set; }
			public int AutorId { get; set; }
		}
		
		Despues
		public class LibroCreacionDTO
		{
			[Required]
			[StringLength(250, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			public required string Titulo { get; set; }
			public List<int> AutoresIds { get; set; } = [];
		}
		
		-Se va a AutoMapperProfiles y se busca ese fichero con Ctrl + Coma.
		-Se busca el mapeo de LibroCreacionDto a Libro y se añade ForMember porque se quiere mapear LibroCreacionDto, esos AutoresIds a esa lista de AutorLibro dentro de Libro.
		-Se mapea de listado de enteros a AutorLibro.
		-Se crea un AutorLibro por cada enterp que haya en ese listado.
		-Cada Id es un Id de Autor.
		-Asi se apea hacia Autores, nuestros AutoresIds.
		CreateMap<LibroCreacionDTO, Libro>();
		
		Despues
		CreateMap<LibroCreacionDTO, Libro>()
			.ForMember(ent => ent.Autores, config =>
			config.MapFrom(dto => dto.AutoresIds.Select(id => new AutorLibro { AutorId = id })));
		
		-Se descomenta el HttpPost de LibrosController.
		-Se hacen dos validaciones en la segunda validacion se le dice que traiga todos los autores que se encuentren en esa lista de AutoresIds.
		-Se valida que ese listado de autores que se obtiene es igual a los AutoresIds. Sino, se estarian mandando autores que no existen.
		-Se buscarian los autores que no existen.
		Antes
		[HttpPost]
		public async Task<ActionResult> Post(LibroCreacionDTO libroCreacionDTO)
		{
			var libro = mapper.Map<Libro>(libroCreacionDTO);
			var existeAutor = await context.Autores.AnyAsync(x => x.Id == libro.AutorId);

			if (!existeAutor)
			{
				ModelState.AddModelError(nameof(libro.AutorId), $"El autor de id {libro.AutorId} no existe");
				return ValidationProblem();
			}

			context.Add(libro);
			await context.SaveChangesAsync();

			var libroDTO = mapper.Map<LibroDTO>(libro);

			return CreatedAtRoute("ObtenerLibro", new { id = libro.Id }, libroDTO);
		}
		
		Se tiene el tema del orden de los autores asi que se añade un metodo privado.
		private void AsignarOrdenAutores(Libro libro)
		{
			if (libro.Autores is not null)
			{
				for (int i = 0; i < libro.Autores.Count; i++) {
					libro.Autores[i].Orden = i;
				}
			}
		}
		
		DESPUES
		[HttpPost]
		public async Task<ActionResult> Post(LibroCreacionDTO libroCreacionDTO)
		{
			if(libroCreacionDTO.AutoresIds is null || libroCreacionDTO.AutoresIds.Count == 0)
			{
				ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds),
					"No se puede crear un libro sin autores");
				return ValidationProblem();
			}

			var autoresIdsExisten = await context.Autores
									.Where(x => libroCreacionDTO.AutoresIds.Contains(x.Id))
									.Select(x => x.Id).ToListAsync();

			if (autoresIdsExisten.Count != libroCreacionDTO.AutoresIds.Count)
			{
				var autoresNoExisten = libroCreacionDTO.AutoresIds.Except(autoresIdsExisten); ;
				var autoresNoExistenString = string.Join(",", autoresNoExisten);
				var mensajeError = $"Los siguientes autores no existen: {autoresNoExistenString}";
				ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds), mensajeError);
				return ValidationProblem();
			}

			var libro = mapper.Map<Libro>(libroCreacionDTO);
			AsignarOrdenAutores(libro);

			context.Add(libro);
			await context.SaveChangesAsync();

			var libroDTO = mapper.Map<LibroDTO>(libro);

			return CreatedAtRoute("ObtenerLibro", new { id = libro.Id }, libroDTO);
		}
		
		-Aqui se han validado los AutoresIds tanto de que vengan como que existan.
		-Se compila.
		-Se levanta la app
		-Se va a postman y se crea la peticion POST.
		POST https://localhost:7132/api/libros/
		{
			"titulo": "Programando en C#",
			"autoresIds": []
		}
		
		-Dara error y dira que faltan los autores. Dira que los dos primeros no existen.
		POST https://localhost:7132/api/libros/
		{
			"titulo": "Programando en C#",
			"autoresIds": [125, 250, 7]
		}
		
		-Se envia para dos que existan:
		POST https://localhost:7132/api/libros/
		{
			"titulo": "Programando en C#",
			"autoresIds": [7, 8]
		}
		
		-En la tabla AutoresLibros se ve esa relacion de qie para el id 7 se ha metido autor 7 y 8 y el orden va por orden ascendente de Ids.
		
	82. Actualziando Registros de Relaciones Muchos a Muchos
		-Quizas se quiera agregar autores a un libros, remover autores o cambiar orden de autores. Se usa tecnica con Automapper.
		-Se va a LibrosController y se descomenta el Put.
		-Se copia validacion del Post.
		Antes
		[HttpPut("{id:int}")]
		public async Task<ActionResult> Put(int id, LibroCreacionDTO libroCreacionDTO)
		{
			var libro = mapper.Map<Libro>(libroCreacionDTO);
			libro.Id = id;

			var existeAutor = await context.Autores.AnyAsync(x => x.Id == libro.AutorId);

			if (!existeAutor)
			{
				return BadRequest($"El autor de id {libro.AutorId} no existe");
			}

			context.Update(libro);
			await context.SaveChangesAsync();
			return NoContent();
		}
		
		-Se trae la dat del libro de la BBDD.
		-Con esto se tiene la logica que actualiza la dat de libros comotitulos y autores, si se quieren agregar o borrar auotres de un libro...
		[HttpPut("{id:int}")]
		public async Task<ActionResult> Put(int id, LibroCreacionDTO libroCreacionDTO)
		{
			if (libroCreacionDTO.AutoresIds is null || libroCreacionDTO.AutoresIds.Count == 0)
			{
				ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds),
					"No se puede crear un libro sin autores");
				return ValidationProblem();
			}

			var autoresIdsExisten = await context.Autores
									.Where(x => libroCreacionDTO.AutoresIds.Contains(x.Id))
									.Select(x => x.Id).ToListAsync();

			if (autoresIdsExisten.Count != libroCreacionDTO.AutoresIds.Count)
			{
				var autoresNoExisten = libroCreacionDTO.AutoresIds.Except(autoresIdsExisten); ;
				var autoresNoExistenString = string.Join(",", autoresNoExisten);
				var mensajeError = $"Los siguientes autores no existen: {autoresNoExistenString}";
				ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds), mensajeError);
				return ValidationProblem();
			}

			var libroDB = await context.Libros
						  .Include(x => x.Autores)
						  .FirstOrDefaultAsync(x => x.Id == id);

			if(libroDB is null)
			{
				return NotFound();
			}

			libroDB = mapper.Map(libroCreacionDTO, libroDB);
			AsignarOrdenAutores(libroDB);

			await context.SaveChangesAsync();
			return NoContent();
		}
		
		-Se va a DB y se trae la data del libro cona autores. AutoMapper se encarag de hacer mapeo de tal forma que no solamente actualice libro, sino data relacionada con lo del Include.
		-Cuando AutoMapper haga mapeo, se hace mapeo de los autores. Con AuitoresIds se actualiza el listado de AuotrLibro.
		-Como libroDB es un objeto el cual vino de EF, al hacerle modificaciones AutoMapper y hacerle SaveChangesAsync...se guarda en BBDD, tanto modificaciones de libro como data relacionada.
		-Se guarda, se ejecuta y se levanta Postman.
		-Se hace peticion PUT.
		PUT https://localhost:7132/api/libros/7
		{
			"titulo": "Programando en C# - Edicion 2",
			"autoresIds": [6, 8]
		}
		
		-Se ve que se ha cambiado la data en Libros y AutoresLIbros. Se ve que segun el orden en que se pongan los AutoresIds, en BBDD se ve que cambia ese orden.
	
	83. Obteniendo Data Relacionada en una Relación Muchos a Muchos
		-Se prueba en PostMan una ruta: 
		https://localhost:7132/api/autores/8 Da error.
		https://localhost:7132/api/libros/ Da error.
		
		-Lo que ocurre es que se deben arreglar los mapeos para que puedan funcionar las relaciones Muchos a Muchos.
		-Primero, se va a trabajar con Autores.
		-Por ejemplo, ha habido error al mapear desde Autor -> AutorConLibrosDTO. Especificamente, con la propiedad Libros.
		AutoMapper.AutoMapperMappingException: Error mapping types.

		Mapping types:
		Autor -> AutorConLibrosDTO
		BibliotecaAPI.Entidades.Autor -> BibliotecaAPI.DTOs.AutorConLibrosDTO

		Type Map configuration:
		Autor -> AutorConLibrosDTO
		BibliotecaAPI.Entidades.Autor -> BibliotecaAPI.DTOs.AutorConLibrosDTO

		Destination Member:
		Libros
		
		-Se va a Autor y se tiene public List<AutorLibro> Libros { get; set; } = [];
		-En AutorConLibrosDTOhay esto public List<LibroDTO> Libros { get; set; } = new List<LibroDTO>();
		-Se va a AutoMapperprofiles y se ve que no hay mapeos de AutorLibro a AlibroDTO.
		-El LibroDTO se tiene Id y Titulo, mientras que en AutorLibro se tiene LibroId y como no se llama asi, hay que decirle a AutoMapper que haga este mapeo y en el caso
		 del Libro de AutorLibro hay que ir al Titulo del Libro.
		 CreateMap<AutorLibro, LibroDTO>()
			.ForMember(dto => dto.Id, config => config.MapFrom(ent => ent.LibroId))
			.ForMember(dto => dto.Titulo, config => config.MapFrom(ent => ent.Libro!.Titulo));
			
		-Ahora, se devuelve esto https://localhost:7132/api/autores/8 pero nos falta el titulo porque es una relacion muchos a muchos y si se va a AutoresController
		 se ve que en el ObtenerPorId.
		 [HttpGet("{id:int}", Name = "ObtenerAutor")] // api/autores/id
			public async Task<ActionResult<AutorConLibrosDTO>> Get(int id)
			{
				var autor = await context.Autores
					.Include(x => x.Libros)
					.FirstOrDefaultAsync(x => x.Id == id);

				if (autor is null)
				{
					return NotFound();
				}

				var autorDTO = mapper.Map<AutorConLibrosDTO>(autor);

				return autorDTO;

			}
			
		-Ahi se va Autores y se obtiene la data de los libros.
		-Ese libros trae AutorLibro que no tiene ningun titulo.
		-Para obtener el titulo, hay que ir a la tabla de libros.
		-Se mete ahi el .ThenInclude
		[HttpGet("{id:int}", Name = "ObtenerAutor")] // api/autores/id
		public async Task<ActionResult<AutorConLibrosDTO>> Get(int id)
		{
			var autor = await context.Autores
				.Include(x => x.Libros)
					.ThenInclude(x => x.Libro)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (autor is null)
			{
				return NotFound();
			}

			var autorDTO = mapper.Map<AutorConLibrosDTO>(autor);

			return autorDTO;

		}
		
		-esto ya funcionaria en Postman: https://localhost:7132/api/autores/8
		
		
		https://localhost:7132/api/libros/6
		Da problemas con System.InvalidCastException: Unable to cast object of type 'BibliotecaAPI.DTOs.LibroDTO' to type 'BibliotecaAPI.DTOs.LibroConAutorDTO'.
		
		-En AutoMapperProfiles se tuvo que comentar esto porque se tenian ahora varios autores.
		//CreateMap<Libro, LibroConAutorDTO>()
		//    .ForMember(dto => dto.AutorNombre, config =>
		//        config.MapFrom(ent => MapearNombreYApellidoAutor(ent.Autor!)));
		
		-Se va hacia LibroConAutorDTO. Se cambia esto:
		public class LibroConAutorDTO: LibroDTO
		{
			public int AutorId { get; set; }
			public required string AutorNombre { get; set; }
		}
		
		-Por esto:
		public class LibroConAutoresDTO: LibroDTO
		{
			public List<AutorDTO> Autores { get; set; } = [];
		}
		
		-Se va a AutoMapperProfiles: CreateMap<Libro, LibroConAutoresDTO>();
		-En Libro, se mapea Id y Titulo y eso ya esta en librosConAutores porque viene de LibroDTO.
		
		-Se tiene que pensar como se va a mapear de AutorLibro a AutorDTO. Se va a mapear del libro que tiene Autores que es List<AutorLibro>.
		-Se va a mapear hacia LibroConAutoresDTO que tiene Autores (List<AutorDTO>)
		-Es lo mismo que se hizo de AutorLibro a LibroDto.
		CreateMap<AutorLibro, AutorDTO>()
			.ForMember(dto => dto.Id, config => config.MapFrom(ent => ent.AutorId))
			.ForMember(dto => dto.NombreCompleto,
				config => config.MapFrom(ent => MapearNombreYApellidoAutor(ent.Autor!)));
				
		-Se necesita obtener la data relacionada del autor.
		-Se va a LibroSController. Donde poner LibroConAutorDTO, se sustituye por LibroConAutoresDTO.
		-Se mete el ThenInclude porque se necesita la data del Autor.
		-Eso de Autores es un AutorLibro que tiene Id de autor pero no el nombre del autor.
		-Ahora esta URL si que funciona:
		https://localhost:7132/api/libros/6
		
	84. Creando un recurso con sus recursos relacionados
		-Que un cliente pueda crear el autor y sus libros de forma simultanea.
		-Haciendo dos cambios, se puede lograr esto.
		-Se añade una propeidad en AutorCreacionDTO.
		Antes
		public class AutorCreacionDTO
		{
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Nombres { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(20, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Apellidos { get; set; }
			public string? identificacion { get; set; }
		}
		
		Despues
		public class AutorCreacionDTO
		{
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Nombres { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(20, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Apellidos { get; set; }
			public string? identificacion { get; set; }
			public List<LibroCreacionDTO> Libros { get; set; } = [];
		}
		
		-En el post de AutoresController se mapea de AutorCreacionDto a Autor, asi que se mapea de LibroCreacionDTO hacia AutorLibro que se tiene dentro de Autor.
		-Se configura el mapeo en AutoMapperProfiles.
		CreateMap<LibroCreacionDTO, AutorLibro>()
			.ForMember(ent => ent.Libro, 
				config => config.MapFrom(dto => new Libro { Titulo = dto.Titulo }));
		
		-Ahora, hay que verificar que cuando se obtenga un AutorCreacionDTO en el POST de AutoresController, ese mapeo se encargue no soo de tener el Autor, sino tambien
		 los libors y cuando se haga el context.Add se va a agregar el autor con sus libros.
		 Asi el SaveChangesAsync, crea el autor con sus libros.
		 [HttpPost]
			public async Task<ActionResult> Post(AutorCreacionDTO autorCreacionDTO) {
				var autor = mapper.Map<Autor>(autorCreacionDTO);
				context.Add(autor);
				await context.SaveChangesAsync();
				var autorDTO = mapper.Map<AutorDTO>(autor);
				return CreatedAtRoute("ObtenerAutor", new { id = autor.Id }, autorDTO);
			}
			
		-Se va a Postman.
		-Se hace esta peticion.
		POST https://localhost:7132/api/autores/
		{
			"nombres": "Roberto",
			"apellidos": "Martínez",
			"identificacion": 135,
			"libros": [
				{"titulo": "Libro 1 - Roberto"},
				{"titulo": "Libro 2 - Roberto"}
			]
		}
		
		-Este get me devuelve la info creada:
		GET https://localhost:7132/api/autores/9
	
	85. Creando una colección de recursos
		-En ocasiones, vamos a tener la necesidad de permitirle a nuestros clientes no crear un solo recuros, sino varios al mismo tiempo.
		-Se vio esto en el anterior video permitiendo crea run autor con sus libros.
		-Si se quiere crear varios autores con sus respectivos lirbos, pues un listado de autores con sus libros.
		-Se peude considerar una coleccion de recursos como un recuros aparte.
		-Hasta ahora hemos tenido que cada recuros tiene un controladopr, lo que se av a crear es que se crea un controlador para colecciones autores.
		-AddRange sirve para agregar un listado de Entidades.
		-De un post donde se han cread recursos, yo tengo que retornar un 201.
		-Se deja con reutnr Ok() ya que es diferente proque se estan creando varios Autores.
		-Se tiene que devovler una accion que me permita obtener esos dos autores y solo esos dos.
		[HttpPost]
		public async Task<ActionResult> Post(IEnumerable<AutorCreacionDTO> autoresCreacionDTO)
		{
			var autores = mapper.Map<IEnumerable<Autor>>(autoresCreacionDTO);
			context.AddRange(autores);
			await context.SaveChangesAsync();
			return Ok();
		}
		
		-Se va a Postman.
		POST https://localhost:7132/api/autores-coleccion
		[
			{
				"nombres": "María",
				"apellidos": "Rosario",
				"identificacion": "757",
				"libros": [
					{"titulo": "Libro 1 - Maria Rosario"},
					{"titulo": "Libro 2 - Maria Rosario"},
					{"titulo": "Libro 3 - Maria Rosario"} 
				]
			},
			{
				"nombres": "Clemente",
				"apellidos": "Baez",
				"identificacion": "111" 
			},
			{
				"nombres": "Santiago",
				"apellidos": "Ulloa",
				"identificacion": "222",
				"libros": [
					{"titulo": "Libro 1 - Santiago Ulloa"}
				]
			}
		]
		
		-Se comprueba datos en Autores, Libros y AutoresLibros.
	
	86. Obteniendo una colección de recursos
		-Ahora que estamos creando una coleccion de Autores, debemos permitir alos cleintes, obtenr un listado de autores, no uno total sino por ejemplo,
		 quiero los autores, 10, 8 y 9. Es importante porque de nuestro webAPI queremos devovler un 201 a la hroa de crear una coleccion de Autores.
		 y debemos indicar la URL en la que se peuden obtener los Autores recien creados.  Se crea accion GET en AutoresController.
		 Se pasa por parametro un string ids porque van a ir separados por comas: /api/autores/1,2,3...
		 se convierten los strings en enteros.
		 Si el count de ids es diferente es que alguno no fue encontrado.
		
		[HttpGet("{ids}", Name = "ObtenerAutoresPorIds")]
		public async Task<ActionResult<List<AutorConLibrosDTO>>> Get(string ids)
		{
			var idsColeccion = new List<int>();

			foreach (var id in ids.Split(","))
			{
				if (int.TryParse(id, out int idInt))
				{
					idsColeccion.Add(idInt);
				}
			}

			if (!idsColeccion.Any())
			{
				ModelState.AddModelError(nameof(ids), "Ningún Id fue encontrado");
				return ValidationProblem();
			}

			var autores = await context.Autores
							.Include(x => x.Libros)
								.ThenInclude(x => x.Libro)
							.Where(x => idsColeccion.Contains(x.Id))
							.ToListAsync();

			if(autores.Count != idsColeccion.Count)
			{
				return NotFound();
			}

			var autoresDTO = mapper.Map<List<AutorConLibrosDTO>>(autores);
			return autoresDTO;
		}
		
		-Se levanta la app y se mete esa URL: https://localhost:7132/api/autores-coleccion/9,10,12
		-En el HTTPOST se necesita devolver un CreatedAtResult.
		Antes
		[HttpPost]
		public async Task<ActionResult> Post(IEnumerable<AutorCreacionDTO> autoresCreacionDTO)
		{
			var autores = mapper.Map<IEnumerable<Autor>>(autoresCreacionDTO);
			context.AddRange(autores);
			await context.SaveChangesAsync();
			return Ok();
		}
		
		DESPUES
		[HttpPost]
		public async Task<ActionResult> Post(IEnumerable<AutorCreacionDTO> autoresCreacionDTO)
		{
			var autores = mapper.Map<IEnumerable<Autor>>(autoresCreacionDTO);
			context.AddRange(autores);
			await context.SaveChangesAsync();

			var autoresDTO = mapper.Map<IEnumerable<AutorDTO>>(autores);
			var ids = autores.Select(x => x.Id);
			var idsString = string.Join(",", ids);
			return CreatedAtRoute("ObtenerAutoresPorIds", new { ids = idsString }, autoresDTO);
		}
		
		-Se va a postman.
		POST https://localhost:7132/api/autores-coleccion
		[
			{
				"nombres": "María",
				"apellidos": "Rosario 2",
				"identificacion": "757",
				"libros": [
					{"titulo": "Libro 1 - Maria Rosario"},
					{"titulo": "Libro 2 - Maria Rosario"},
					{"titulo": "Libro 3 - Maria Rosario"} 
				]
			},
			{
				"nombres": "Clemente",
				"apellidos": "Baez 2",
				"identificacion": "111" 
			},
			{
				"nombres": "Santiago",
				"apellidos": "Ulloa 2",
				"identificacion": "222",
				"libros": [
					{"titulo": "Libro 1 - Santiago Ulloa"}
				]
			}
		]
		
		-En Headers, Location, se tiene la URL de los autores recien creados.
		GET https://localhost:7132/api/autores-coleccion/13,14,15
		
	87. Resumen
		-En este modulo, se han explorado diferentes escenarios a la hora de manipular recuross en un webAPI.
		-Peude haber endpoints que manipulen recuross individuales o en coleccion.
		-Se ha aprendido acerca de entidades dependientes y de como modelar esa relacion en las rutas de WebAPI.
		-Los DTOS ayudan con separacion de responsavbildiades ya que con estos se peuden ocultar nuestra entidades del mundo extern, consiguiendo mas flexibilidad.
		-La relacion 1-N es que una entidad se relaciona con un conjunto de entidades como un libro puede relacionarse con varios comentarios.
		-Las relaciones muchos a muchos es cuando se tienen dos relaciones 1:N de forma simultanea entre dos entidades. Ejemplo entre libros y auotres. Un libro puede ser escrito por varios autores
		 y varios auotres peuden escribir varios libros.


Sección 6: Configuraciones
	
	88. Introducción
		-Se hablara de Congfigruaciones en ASP.NET CORE. La idea de las configuraciones es que nuestra app va a tener la necesidad de consumir info que se encontrara en poroveedores externos como
		 un archivo de configuracion. Es mala practica estar colocando ciertas configuraciones dentro de nuestra app por temas de seguridad o de que se tendria que recompilar 
		 cada vez que se quieran cambiar ciertas configuraciones como servidor donde sen encuentra la BBDD.
	
	89. Introducción a las configuraciones
		-Cuando hablamos de configuraciones nos referimos a datois que ayudan a nuestra app a funcionar de forma correcta.
		-Estos datos tienden a variar de un ambiente a otro.
		-O, al menos, son datos que no tienen sentido que formen parte del codigo fuente.
		-Un ejemplo de estos datos es la cadena de conexion o ConnectionString que indica la info del servidor de BBDD.
		-No es algo que se quiera tener en el codigo fuente pues se tendria que editar el codigo fuente por ambiente.
		-Es mejor tener esta y otras informaciones en fuentes externas.
		-Para comunicarnos con estas fuentes externas se usan los provvedores de configuracion,.
		-Los proveedores de configuracion permten conectarnos con difernetes tipos de fuenets externas de nuestra app, ya queramos comunciarnos con ficheros json, variables en memoria, argumentos en lienas de comandos...
		-Se deben usar proveedores de confguracion para poder consumir esas fuentes externas de datos.
		-La idea es que el framework de .NET nos permite tener un servicio a traves del cual podemos acceder a estos datos de forma directa 
		 y uniforme. Este servicio es el IConfiguration con el que se puede entrar a los datos de configuracion de nuestra app.
		-Se peude ver que se tienen varias opciones de cinfiguracion para controlar el ciclo de vida de las configuraciones.
		-Se peude configurar que si unos datos son actualziados, se ejecute una funcion de C#, o que se quiere que unos datos se mantenagan staticos durante el tiempo de vida de la app.
		
	90. Ejemplo de IConfiguration
		-Una ap de asp.net cre viene preparada para trabajar con difernetes fuentes de configuracion. De hecho ya hemos usado cofiguraciones ne nuestra app.
		 cuando colocamos el connectionString en el appsettings.development.json.
		-ConnectionStrings representa una seccion y dentro de ella esta la propeidad DefaultConnection.
		-Un proveedor de configuracion es una coleccion de llaves y valores. Para acceder a los valores a partir de las llaves, se peude usar el servicio IConfiguration.
		-Se crea Controlador de prueba.
		-Se va a usar el sistema JSON de dependencias para poder obtener una instancia del servicio IConfiguration.
		-IConfiguration permite obtener el valor a partir de cualquier proveedor de configuracion.
		-Se evra mas adelante como se interactua con varios proveedores al mismo tiempo.
		[ApiController]
		[Route("api/configuraciones")]
		public class ConfiguracionesController : Controller
		{
			private readonly IConfiguration configuration;

			public ConfiguracionesController(IConfiguration configuration)
			{
				this.configuration = configuration;
			}
			[HttpGet]
			public ActionResult<string> Get()
			{
				var opcion1 = configuration["apellido"];
				var opcion2 = configuration.GetValue<string>("apellido");
				return opcion2;
			}
		}
		
		-Se levanta app, va a postman y se prueba el endpoint. https://localhost:7132/api/configuraciones/
		
		-Se puede tener un simle valor o una seccion que e sun cojunto de llaves y valores...
		-Las secciones permiten agrupar ciertas llaves en una misma estructura.
		-Por ejemplo en ConnectionStrings se peuden colocar ConnectionStrings diferneets de mi app.
		-Se va a intentar obtener el valor del connectionString usando la sintaxis aprendida.
		
		-Añadir esto para indicar que peude ser nulo  y quitar advertencia: var opcion2 = configuration.GetValue<string>("apellidos")!;
		-Se hace porque puede ser que el valor no exista...
		-Se va a intentar acceder al valor de ConnectionStrings.
		[HttpGet("secciones")]
		public ActionResult<string> GetSeccion()
		{
			var opcion1 = configuration["ConnectionStrings:DefaultConnection"];
			var opcion2 = configuration.GetValue<string>("ConnectionStrings:DefaultConnection");
			var seccion = configuration.GetSection("ConnectionStrings");
			var opcion3 = seccion["DefaultConnection"];
			return opcion3!;
		}
		
		-POSTMAN: EJEMPLO => https://localhost:7132/api/configuraciones/secciones
		
	91. Secciones - GetChildren
		-Esto de als secciones permite tener secciones de codigo las cuales pueden incluso tener 
		 las mismas llaves pero con difernetes valores.
		-Se añade esto:
		"seccion_1": {
		  "nombre": "Felipe",
		  "edad": 999
		},
		"seccion_2": {
		  "nombre": "Claudia",
		  "edad": 111
		},
		
		-Se quiere acceder a estos valores desde el controlador.
		-Se quiere tener acceso a la seccion completa pero se va a hacer desde um campo de la clase.
		private readonly IConfiguration configuration;
		private readonly IConfigurationSection seccion_01;
		private readonly IConfigurationSection seccion_02;

		public ConfiguracionesController(IConfiguration configuration)
		{
			this.configuration = configuration;
			seccion_01 = configuration.GetSection("seccion_1");
			seccion_02 = configuration.GetSection("seccion_2");
		}
		
		-Se mete la peticion HttpGET
		[HttpGet("seccion_01")]
		public ActionResult GetSeccion01()
		{
			var nombre = seccion_01.GetValue<string>("nombre");
			var edad = seccion_01.GetValue<string>("edad");

			return Ok(new { nombre, edad });
		}

		[HttpGet("seccion_02")]
		public ActionResult GetSeccion02()
		{
			var nombre = seccion_02.GetValue<string>("nombre");
			var edad = seccion_02.GetValue<string>("edad");

			return Ok(new { nombre, edad });
		}
		
		-Se accede desde PostMan.
		https://localhost:7132/api/configuraciones/seccion_01
		https://localhost:7132/api/configuraciones/seccion_02
		
		-Se coloca en una variable aparte para que asi no tengamos accidentalmente acceso a otros valores que no quisieramos acceder.
		-Se peuden obtener todos lo valores de un proveedor de configuracion.
		-Peude ser util para debuggear.
		-Se mete una peticion httpget.
		[HttpGet("obtenertodos")]
		public ActionResult GetObtenerTodos()
		{
			var hijos = seccion_02.GetChildren().Select(x => $"{x.Key}: {x.Value}");
			return Ok(new { hijos });
		}
		
		-Se mete Postman: https://localhost:7132/api/configuraciones/obtenertodos
		
	92. Usando el AppSettings
		-Se va a habalr de los difernetes proveedores de configuracion. Basicamente, cuando se habla de proveedores de configuracion se refiere a los difernetes lugares
		 donde se peuden configurar datos como estos: cjtos de llaves y valroes.
		-Se hablara de appsettings.json.
		-Cuandos e creo el proyecto, se creo el appsettings.json y el appsettings.development.json.
		-appsettings.json es una configuracion base para prod, mientras que el development.json es una configuracion especifica para DESA.
		-En el development.json se puede tener un ConnectionString que apunte a mi bbdd de dev y en el appsettings.json un connectionString que apunte a BBDD de prod.
		-Cuando este correindo la webapi, si esta en modo dev, se usa el appsettings de dev, sino prod si estamos en prod.
		-El ver si estamos en modo desarrollo o modo dev de manera local es usando el launchSettings.json, usando una variable de ambiente.
		
		-Se va a ir appsetting.development.json y se va a meter una llave: "quien_soy":  "appsettings.Development.json (desarrollo)",
		-Idem en prod: "quien_soy": "appsettings.json (producción)",
		-Se va a ConfigurationController y se mete nueva peticion HTTP,.
		[HttpGet("proveedores")]
		public ActionResult GetProveedor()
		{
			var valor = configuration.GetValue<string>("quien_soy");
			return Ok(new { valor });
		}
		
		-Se va a postman.
		https://localhost:7132/api/configuraciones/proveedores
		
		-Si se cambia el valor, se configura una opcion en los proveedores de config como appsettings.development.json una funcionalidad que se llama ReloadOnChange,
		 para que cuando sean editados, automaticamente ASP.NET Core se peuda tomar ese valor editado.
		-Soi se comenta el valor en appsettings.development.json y ejecutamos la peticion de postman saca el valor de prod.
		-En dev primero se va a buscar al fichero de appsettings.development.json. Sino se encuentra ahi, se va a buscar a appsettings.json.
		-En dev se da preferencia al appsettings especifico del ambiete en el que estoy.
		
		-Se hace el cambio en el https del launchsettings.json para que se apunte a PROD.
		"https": {
		  "commandName": "Project",
		  "dotnetRunMessages": true,
		  "launchBrowser": true,
		  "applicationUrl": "https://localhost:7132;http://localhost:5065",
		  "environmentVariables": {
			"ASPNETCORE_ENVIRONMENT": "Production"
		  }
		}
		
		-Si se va a postman y se ejecuta el https, se ve que ya estamos modo prod y se va a bucar las config a appsettings.json.
	
	93. Variables de ambiente
		-Son valores que se configuran a nivel del ambiente como a nivel del SO.
		-No estan en ningunaa parte del code de la app.
		-Son utiles para tener valores sensibles como el tema de acceder a una cadena de conexion de PROD de modo que nadie pueda acceder a esa cadena de conexion.
		-Incluso existen servicios de solo escritura en los que ni tan siquiera la persona que creo la variable de ambiente puede ver su valor. Es util por temas de seguridad.
		-Se pueden configurar variables de ambiente en Windows, Linux, MACOS....
		-Se sigue trabajando con la vble quien_soy.
		-Se usa el launcSttings.json para definir una vble de ambiente.
		-Se mete en environmentvariables que es una seccion con llave sy valores.
		"environmentVariables": {
		  "ASPNETCORE_ENVIRONMENT": "Production",
		  "quien_soy": "una variable de ambiente"
		}
		
		-Se va a postman y se ejecuta: https://localhost:7132/api/configuraciones/proveedores
		-Se ve que saca la vble de ambiente. Porque se le da prioridad? Se ve en el siguiente video.
	
	94. Orden de declaración de proveedores de configuración
		-Se habia visto que al intentar sacar el valor de quien_soy se obtuvo el valor configurado en la vble de ambiente, esto a pesar de que esta configurado en 
		 diferentes proveedores de configuracion como appsettings.development.json y appsettings.json.
		-La razon es que existe un sistema de preferencia de los proveedores de configuracion.
		-Los proveedores que se configuran primero, tienen menor preferencia.
		-Es decir, los que se configuran al final tienen mas preferencia y sobreescriben a los anteriores.
		-Donde se ve el orden? Se va a Program.cs y ahi se ve el metodo CreateBUilder donde por defecto se configura la app de .NET.
		-Entre esas configuracioens está la configuración de preferencia de los proevedores de configuracion.
		-Se puede abrir source.dot.net y se ve el codigo fuente en HostingHostBuilderExtensions.cs y dentro de el, en ApplyDeafultAppConfiguration.
		-Lo primero que se configura es el appsetting.json, es el que menos preferencia tiene. Se ve que hay una parte que dice appsettings.{env.EnvironmentName}.json y eso
		 permite crear un appsettings por ambiente....
		-El development tiene mayor preferencia que el de prod porque se configrua despues. Si se esta en desarrollo se configrua otro proveedor
		 que es el UserSecrets.
		-Permite tener un archivo json que es privado de nuestra maquina, solo se encuentra ahi.
		-No se sube a GitHub etc.
		-Luego se tiene la configuracion de las variables de ambiente y tienen preferencia y sobreescriben a las variables de otros proveedores de configuracion.
		-Luego esta el AddCommandLineConfig porque la linea de comandso es otro proveedor de configruacion. Este peude sobrrescribir las vbles de ambiente. 
		-Hay otros proveedores de configuracion y cuando se configuran en Program posterior a CreateBuilder, va a sobreescribir a lo que tengamos a CreateBuilder.
		-No se sobreescribe el proevedor en si, sino lo que haya en las llaves.
		-Se recuerda que sino se encuentra una variable en un proveedor, lo va a buscar al siguiente de menos preferencia.
	
	95. User Secrets
		-Es otro proveedor de configuracion. Es para tener configuraciones personales que no se quiere que andie vea.
		-Es como appsettings pero esta garantrizado a no estar presente en nuestra app.
		-De esta manera, no corres riesgo de revelar datos sensibles a terceros.
		-En Visual Studio, boton derecho en el proyecto > "Administrar secretors de usuario" y crea un fichero json.
		-Hay una seccion en la que se pueden colcoar llaves y valores.
		-En el caso de dotnet-cli pueden usar el comando dotnet user-secrets init.
		-Se puede ver en la configuracion del proyecto el ID del UserSecrets que lo identifica de forma unica.
		-Donde esta ese fichero?? Se pulsa Windows + R y se mete: %APPDATA%\Microsoft\UserSecrets\
		-Se tienen muchas carpetas con muchos IDs. Se busca el ultimo por fecha y se ve que tengo el que he acabado de crear.
		-Ficheroe sta lejos del proyecto y es dificl que lo subamos sin querer a GitHub para darle seguimiento a nuestro proyecto usando Git.
		-Se puede evitar asi por accidnete revelar secretos nuestros.
		-Aqui claro se puede meter un connectionString con usuario y password o credenciales para conectar a WebAPI por el que pago.
		-Esto es para tener claves secretas sin correr peligro de revelarselo a otros.
		-Se mete quien_soy: 
		{
		  "quien_soy":  "secrets.json";
		}
		
		-Se imprime antes la vble de ambiente por el tema del orden de preferencia....
		
	96. Linea de Comandos
		-Sobreescribe el resto de proveedores porque se coloca al final. La idea es que se pueda ejecutar la app desde linea de comandos
		 y desde aqui se peuden pasarle argumentos, los cuales pueden ser transformados en valores de un proveedor de configuracion
		-Se abre el proyecto en una terminal de powershell.
		-Se pone dotnet run -- "quien_soy=linea de comandos".
		-Es algo que se sule usar en herramientas automaticas como por ejemplo si quieres tener archivo de Docker, un yaml, githubactions etc...
		-Haces dotnet run y le puedes pasar cualquier valor que sobreescribe cualquier proevedor de configuracion como appsettings.json
		-Se coge la URL que se levanta y se va a Postman:  http://localhost:5065/api/configuraciones/proveedores
	
	97. Diccionario en memoria como proveedor
		-Este sirve cuando tenemos valores que queremos centralziar en una parte del code de nuestra app.
		-Se va hacia la clase Program y se quiere poner un diccionario.
		-Se le llama diccionarioConfiguraciones.
		-Se mete en Program.cs.
		-Se agrega un nuevo proveedor de configuracion.
		-El orden en que se agregan los proveedores de configuracion es importante.
		-El proveedor AddInMemoryCollection tendra preferencia sobre CreateBuilder porque se ejecuta despues.
		var diccionarioConfiguraciones = new Dictionary<string, string>
		{
			{ "quien_soy", "un diccionario en memoria" }
		};

		builder.Configuration.AddInMemoryCollection(diccionarioConfiguraciones!);
		
		-Se ve que si se va a Postman y se vuelve a ejecutar y se copia la URL que se levanta, se ve que 
		 se enseña lo que se ha configurado en el diccionario en memoria.
		
		-Se ejecuta la app y se le vuelve a pasar por comando: dotnet run -- "quien_soy=linea de comandos"
		-Esto es para configurar como del proveedor de configuracion de linea de comandos  este valor.
		-Se ve que a pesar de que este es uno de los de mayor preferencia, ya que el de en memoria fue configurado posterior a la configuracion 
		 del proveedor del codigo fuente el de en mmeoria tiene preferencia.
		-Si por alguna razon se quiere tenr valores centralziados, se peude llevar a una clase y eso tiene preferencia sobre cualquier valor que se coloque en cualquier proveedor de configuraciones
		 de todos los vistos.
		 
	98. Patron con Opciones
		-Cada vez que se queire obtener l valor d eun proveedor de configuracion, estamos usando el IConfiguration.
		-En ConfiguracionesController se esta inyectando el IConfiguration y de ahi obtienes el valor deseado del proveedor de configuracion.
		-Exosten otras opciones. Quizas no guste ese string magico que se pone como "quien_soy".
		-Igual quizas ahora no se esta validando que exista ese valor.
		-Se quiere que se valide al momento de ejecutar la app por si escribes otra variable etc.
		-Se trabajara con el patron de Opciones. Se trata de tener un mecanismo lo suficentemente tipado
		 para obtener los valores de un proveedor de configuracion.
		-En ConfiguracionesController quizas en lugar de tener que hardcodear el tema de seccion_1, nombre, edad....
		 Igual se quiere algo fuertemente tipado para no escribir mal.
		-Se crea clase cuyas propiedadess erán nombre y edad.
		-Se crea una clase. Section no sera una propiedad, sino un campo de la clase.
		-Se accede a nombre y edad por medio de la clase, en vez de por medio de IConfiguration.
		public class PersonaOpciones
		{
			public const string Seccion = "seccion_1";

			public required string Nombre { get; set; }
			public int Edad { get; set; }
		}
		
		-Se va a la clase Program, area de Servicios, 
		-Se coloca la seccion como campo de clase para no hardcodear nada. Asi obtiene valores de la seccion para mapearlos hacia PersonasOpcioens.
		builder.Services.AddOptions<PersonaOpciones>()
			.Bind(builder.Configuration.GetSection(PersonaOpciones.Seccion));
			
		-Se cambia ConfiguracionesController.
		Antes
		[ApiController]
		[Route("api/configuraciones")]
		public class ConfiguracionesController : Controller
		{
			private readonly IConfiguration configuration;
			private readonly IConfigurationSection seccion_01;
			private readonly IConfigurationSection seccion_02;

			public ConfiguracionesController(IConfiguration configuration)
			{
				this.configuration = configuration;
				seccion_01 = configuration.GetSection("seccion_1");
				seccion_02 = configuration.GetSection("seccion_2");
			}

			[HttpGet("proveedores")]
			public ActionResult GetProveedor()
			{
				var valor = configuration.GetValue<string>("quien_soy");
				return Ok(new { valor });
			}

			[HttpGet("obtenertodos")]
			public ActionResult GetObtenerTodos()
			{
				var hijos = seccion_02.GetChildren().Select(x => $"{x.Key}: {x.Value}");
				return Ok(new { hijos });
			}

			[HttpGet("seccion_01")]
			public ActionResult GetSeccion01()
			{
				var nombre = seccion_01.GetValue<string>("nombre");
				var edad = seccion_01.GetValue<string>("edad");

				return Ok(new { nombre, edad });
			}

			[HttpGet("seccion_02")]
			public ActionResult GetSeccion02()
			{
				var nombre = seccion_02.GetValue<string>("nombre");
				var edad = seccion_02.GetValue<string>("edad");

				return Ok(new { nombre, edad });
			}

			[HttpGet]
			public ActionResult<string> Get()
			{
				var opcion1 = configuration["apellidos"];
				var opcion2 = configuration.GetValue<string>("apellidos")!;
				return opcion2;
			}

			[HttpGet("secciones")]
			public ActionResult<string> GetSeccion()
			{
				var opcion1 = configuration["ConnectionStrings:DefaultConnection"];
				var opcion2 = configuration.GetValue<string>("ConnectionStrings:DefaultConnection");
				var seccion = configuration.GetSection("ConnectionStrings");
				var opcion3 = seccion["DefaultConnection"];
				return opcion3!;
			}
		}
		
		Despues
		[ApiController]
		[Route("api/configuraciones")]
		public class ConfiguracionesController : Controller
		{
			private readonly IConfiguration configuration;    
			private readonly IConfigurationSection seccion_01;
			private readonly IConfigurationSection seccion_02;
			private readonly PersonaOpciones _opcionesPersona;

			public ConfiguracionesController(IConfiguration configuration, IOptions<PersonaOpciones> opcionesPersona)
			{
				this.configuration = configuration;
				seccion_01 = configuration.GetSection("seccion_1");
				seccion_02 = configuration.GetSection("seccion_2");
				_opcionesPersona = opcionesPersona.Value;
			}

			[HttpGet("seccion_1_opciones")]
			public ActionResult GetSeccion1Opciones()
			{
				return Ok(_opcionesPersona);
			}


			[HttpGet("proveedores")]
			public ActionResult GetProveedor()
			{
				var valor = configuration.GetValue<string>("quien_soy");
				return Ok(new { valor });
			}

			[HttpGet("obtenertodos")]
			public ActionResult GetObtenerTodos()
			{
				var hijos = seccion_02.GetChildren().Select(x => $"{x.Key}: {x.Value}");
				return Ok(new { hijos });
			}

			[HttpGet("seccion_01")]
			public ActionResult GetSeccion01()
			{
				var nombre = seccion_01.GetValue<string>("nombre");
				var edad = seccion_01.GetValue<string>("edad");

				return Ok(new { nombre, edad });
			}

			[HttpGet("seccion_02")]
			public ActionResult GetSeccion02()
			{
				var nombre = seccion_02.GetValue<string>("nombre");
				var edad = seccion_02.GetValue<string>("edad");

				return Ok(new { nombre, edad });
			}

			[HttpGet]
			public ActionResult<string> Get()
			{
				var opcion1 = configuration["apellidos"];
				var opcion2 = configuration.GetValue<string>("apellidos")!;
				return opcion2;
			}

			[HttpGet("secciones")]
			public ActionResult<string> GetSeccion()
			{
				var opcion1 = configuration["ConnectionStrings:DefaultConnection"];
				var opcion2 = configuration.GetValue<string>("ConnectionStrings:DefaultConnection");
				var seccion = configuration.GetSection("ConnectionStrings");
				var opcion3 = seccion["DefaultConnection"];
				return opcion3!;
			}
		}
	
		-Se puede validar que nombre y edad se esten llenando.
		public class PersonaOpciones
		{
			public const string Seccion = "seccion_1";

			[Required]
			public required string Nombre { get; set; }
			[Required]
			public int Edad { get; set; }
		}
		
		-Aqui tambien hay que añadir las validaciones en program.cs
		builder.Services.AddOptions<PersonaOpciones>()
		.Bind(builder.Configuration.GetSection(PersonaOpciones.Seccion))
		.ValidateDataAnnotations()
		.ValidateOnStart();
		
		-Si meto nombre2 en el appsettings, pues da error.
		-Cuando se usaba el IConfiguration, si se cambiaba una key o un value del appsettings, se hacia en tiemo de ejecucion. Con IOptions no. IOPtions toma esa data y guarda en cache.
		-Cada vez que se ejecute, hay que usar IOptionsSnapshot.
	
	99. Utilizando IOptionsSnapshot
		-Cada vez que se reciba una peticion HTTP a nuestro webAPI, van a ser llenadas los vaores de las opcioens.
		-Si se quiere que se cuando se actualice el appsettings development en tiempo de ejecucion y se develva valor actualziado hay que usar IOptionsSnapshot.
		-Cada vez que se realzia una peticion HTTP, se van a refrescar los valores de personasOpciones ye s algo mas lento pero no mas por esto vaya.
		-Para app en la que velocidad sea fundamental etc pues es importante.
		-Esto puede ser opcion no muys estartegica.
		-Se cambia esto en ConfiguracionesCOntroller:
		public ConfiguracionesController(IConfiguration configuration, IOptions<PersonaOpciones> opcionesPersona)
		
		public ConfiguracionesController(IConfiguration configuration, IOptionsSnapshot<PersonaOpciones> opcionesPersona)
		
		-IOptionsSnapshot funciona bien para controladores y otro tipo de servicios que son de tipo Scope porque el IOptionSnapshot se actualzia con cada peticion.
		-Funciona bien con controladores por ser de tipo Scope.
		-IOptions es bueno para ConnectionString.
		
	100. Utilizando IOptionsMonitor
		-permite ejecutar una funcion de C# al momento de cambio de los valores en un proveedor e configuracion.
		-Se usa en servicio Singleton.
		-El patron es que tenemos unos datos que queremos suar de forma frecuente como tarifa de un servicio pero por tema de velocidad no queremos colcoarlos en una bbdd esos valores y los colocamos
		 en un lugar de rapido acceso como el appsettings.json.
		-Se va a guardar la tarifa en un camppo de la clase y cuando el proveedor de configuracion se aactualizado 
		 pues se actualziara el campo de la clase
		-Se ava  Appsetiings y se meten tarifas.
		"tarifas": {
		  "dia": 10,
		  "noche":  12
		},
		
		-Se va a crear la clase en la cual, vamos a colcoar estos datos y nos asguramos de que dia y noche esten presentes. Es parecido a PersonasOpciones.
		-Se le llama a la clase TarifasOpciones.
		public class TarifaOpciones
		{
			public const string Seccion = "tarifas";

			[Required]
			public decimal Dia { get; set; }
			[Required]
			public decimal Noche { get; set; }
		}
		
		-Se añade el servicio en Program.cs.
		
		
		-Como se quiere usar IOptionsMonitor se necesita usar un servicio Singleton. Es un servicio que se reinicia en el momento de rieniciar la app.
		-Se añade clase que se llame Pagosprocesamiento Se añade OptionsMonitor.OnChange que se ejecuta cuando se vaya a buscar la variable a appsettings.json.
		public class ProcesamientoPago
		{
			private TarifaOpciones _tarifaOpciones;

			public ProcesamientoPago(IOptionsMonitor<TarifaOpciones> optionsMonitor)
			{
				_tarifaOpciones = optionsMonitor.CurrentValue;

				optionsMonitor.OnChange(nuevaTarifa =>
				{
					Console.WriteLine("tarifa actualizada");
					_tarifaOpciones = nuevaTarifa;
				});
			}

			public void ProcesarPago()
			{
				//Aqui usamos las tarifas
			}

			public TarifaOpciones ObtenerTarifas()
			{
				return _tarifaOpciones;
			}
		}
		
		-PagosProcesamiento lo tengo que configruar como Singleton.
		builder.Services.AddOptions<TarifaOpciones>()
		.Bind(builder.Configuration.GetSection(TarifaOpciones.Seccion))
		.ValidateDataAnnotations()
		.ValidateOnStart();
		
		builder.Services.AddSingleton<ProcesamientoPago>();
		
		-Ahora se puede utilizar este Singleton por ejemplo desde nuestro Controlador.
		-En la vida real, posiblemente ese servicio de procesamiento de pago, sería utilizado desde un job que sea recurrente, es decir una pieza de codigo que sea recurrente.
		-Se inyecta Pagosprocesamiento
		Antes
		private readonly IConfiguration configuration;    
		private readonly IConfigurationSection seccion_01;
		private readonly IConfigurationSection seccion_02;
		private readonly PersonaOpciones _opcionesPersona;

		public ConfiguracionesController(IConfiguration configuration, IOptionsSnapshot<PersonaOpciones> opcionesPersona)
		{
			this.configuration = configuration;
			seccion_01 = configuration.GetSection("seccion_1");
			seccion_02 = configuration.GetSection("seccion_2");
			_opcionesPersona = opcionesPersona.Value;
		}
		
		Despues
		private readonly IConfiguration configuration;
		private readonly ProcesamientoPago procesamientoPagos;
		private readonly IConfigurationSection seccion_01;
		private readonly IConfigurationSection seccion_02;
		private readonly PersonaOpciones _opcionesPersona;

		public ConfiguracionesController(IConfiguration configuration, IOptionsSnapshot<PersonaOpciones> opcionesPersona, ProcesamientoPago procesamientoPagos)
		{
			this.configuration = configuration;
			this.procesamientoPagos = procesamientoPagos;
			seccion_01 = configuration.GetSection("seccion_1");
			seccion_02 = configuration.GetSection("seccion_2");
			_opcionesPersona = opcionesPersona.Value;
		}
		
		-Se añade peticion HTTPGET.
		[HttpGet("options-monitor")]
		public ActionResult GetTarifas()
		{
			return Ok(procesamientoPagos.ObtenerTarifas());
		}
		
		-Se ejecuta la peticion en Postman: http://localhost:5065/api/configuraciones/options-monitor
		-Si se cambia el valor de la tarifa sin cerrar la ejecucion del programa, podra "tarifa actualizada" en la consola.
		-Sale dos veces y corre por ciertos eventos que ocurren al momento de salvar el fichero. Lo importante es ver que se ejecuta la funcion de C#.
		-Somos capaces de ejecutar una funcion de C# al momento de actualizar un valor de un proveedor de configuracion y somos capaces de usar una opcion interesante cuando tenemos servicio Singleton.
	
	101. Consideraciones de seguridad
		-No se debe eprmitir que algunas informaciones vivan en un archivo el cual es accesible a traves de un miembro de mi equipo.
		-El appsettings. jjson es accesible por cualquier eprsona que tenga acceso a codigos fuentes del proyecto.
		-pero sabemos que datos confidenciales como crdenciales, deben guardarse en algun proveedor de configuracion pero es importante que ese fichero no se esté guardando en GitHub o
		 en cualquier repo de control de versioens, ni tampoco que sea un fichero que cualquiera puede acceder.
		 Es importanter mantener ciertas configuraciones fuera del alcance de eprsonas no autorizadas a visualziar dichas configruacioens.
		 El ejemplo es el ConnectionString. la info de bbdd de prod, puede conteenr info sensible acerca de como autenticarse en el servidor de prod de bbdd
		 Es algo que no todos deben conocer.
		 para el caso de prod se suelen suar variables de ambiente para proteger configuraciones.
		 Cuando se publique la app en prod, se pone el connectionString de la bbdd de prod en una vble de ambiente a nivel de Azure. Asi ni siquiera persona
		 que tenga acceso tenga al codigo fuente, tendra acceso a ese connectionString.
		 Existen ifnormacioens que peuden no ser de prod que se quiere proteger.
		 Por ejemplo, un sistema que manda correos y acad desarrolador tiene user y password, es info sensible que no debe ir en el appsettings.json.
		 No es necesario usar vble de ambiente.
		 En este caso, es mejor usar los User Secrets. Asi, cada eprsona puede usar sus credenciales sin tener que exponerlas a mundo externo.
		 Otras informacioens como configuracion del logger y asi, se puede poner en appsettings.json sin peligro.
	
	102. Resumen
		-Se ha aprendido a usar configruaciones en ASP.NET Core.
		-Configuraciones son datos que necesitamos para que la app funcione.
		-Con IConfiguration se pueden obtener lso datos de diferentes proveedores de configuracion.
		-Los proveedores de configuracion son las fuentes de configuracion de nuestra aplicacion: ficheros json, bvariables de ambiente, secretos de usuario, lineas de comando o un simple diccionario en memoria.
		-Con el patron de opciones podemos usar mecanismos fuertemente tipados para acceder a nuestros datos de configuracion.
		
		
Seccion 7: Seguridad
	103. Introduccion a Modulo 7
		-Casi cualquier app no trivial tiene que lidiar con temas de seguridad (autenticacion, encriptacion, cors....).
	
	104. Limpiando la app
		-El borra todo lo relacionado con configuraciones. Lo dejamos porque si qie nos sirve de ejemplo...
	
	105. Autenticacion y Autorizacion
		Autenticacion
		-Hasta ahora todas las rutas de nuestro webapi han estado al aire libre donde cualquiera puede acceder a estas.
		-Esto no es bueno porque existen acciones, las cuales queremos que solo ciertos usuarios puedan acceder.
		-Para eso podemos usar autenticacion y autorizacion.
		-Autenticacion trata de que un usuario muestre credenciales para verificar su identidad.
		-Estas credenciales suelen ser user y password. 
		-En ASP.NEt Core es facil para implemetar un sistema de usuarios, usando Identity.
		-Cone sto se tiene las tablas de SQLServer necesarias para nuestro sistema de usuarios, ademas de meotdoos auxiliares para manejar
		 diferenets escensarios.
		-Una vez autenticado, webapi devuelve un JsonWebToken (JWT) es un string seguro que cntiene info confiable del user.. Es seguro porque esta firmado con llave secreta 
		 y peudes estar seguro de laveracidad de lo que contiene el JWT.
		-JWT contiene claims que son iformaciones acerca del usuario como su nombre, email, etc.
		-Cuando se quieren usar endpoints protegidos en webapi, se debe enviar JWT a traves de una cabeecra de la peticion HTTP y asi podra valdiarse como un usuario autenticado.
		-Untoken se divide en tres partes: cabecera, datos y firma.
		-La separacion de JWT va con puntos. Hay tres partes: cabecera, data y firma.
		-En cabecera aprece el algoritmo usado y tipo que es JWT.
		-La firma sirve para verificar si los datos del token no han sido alterados, para eso hay que ingresar la llave secreta con la que fue firmado el JWT.
		
		Autorizacion
		-Es lo que un usuario tiene permitido hacer
		-No basta con que solo se autentique. No es lo mismo un cliente de empresa que un empleado.
		-El empleado tendrá permsios extra.
		-Quizas solo usuarios especiales puedan borrar recursos.
		-A nivel de WebAPI se usará un código en el que se indicará que sólo un usuario admin pueda realziar esa operacion.
	
	106. Configurando Identity
		-Asi se tiene un conjunto de librerias que lo van a hacer mas facil para crear un sistema de usuarios. Se va a permitir a  
		 un conjunto de personas loggearse y registrarse. S epermitira renovar webToken, usar claims para crear usuarios que son admin a diferencia de otros 
		 que no son para dar eprmsisos especiales a admn. Es facil con Identity.
		
		-Se hace click derecho en proyecto, administracion de nugegts. Seinstala 
		Microsoft.AspNetCore.Identity.EntityFrameworkCore: permite usar identity con EntityFramework Core.
		Microsoft.AspNetCore.Authentication.JwtBearer: Para poder utilizar ese JWT que contiene claims del usuario.
		
		-Se a a ir a Datos > ApllicationDbContext. Para poder usar Identity con EF Core, en vez de hereadar de DbContexto, vaos a heredar de IdentityDbContext.
		 Esto no va apermitir de manera sencilla configurar tablas de un sistema de usuarios bien sencillo que funciona por defecto con Identity
		 Se va a tener tabalas de usuarios, claims...
		
		-Se cambia, esto
		public class ApplicationDbContext : DbContext
		
		-Por esto
		public class ApplicationDbContext : IdentityDbContext
		
		-Si se usa OnModelCreating, hay que asegurarse de tener esto porque sino no se puede crear la migracion: base.OnModelCreating(modelBuilder);
		-Se añade un amigracion: Add-Migration SistemaDeUsuarios.
		-Se ve que hay tabla de roles como vendedor, administrador...No se usa roles porque usaremos Claims.
		-Roles es como  Claims pero especificamente diseñado para categorizar usduarios.
		-Se tiene tabla usuarios: AspNetusers
		-Esta tabla de RoleClaims. A cada claim se peuden asignar roles especiales recordando que los claims es info acerca de algo.
		-Se pueden asignar claims a un rol para que todo usuario que tenga ese rol tenga dichos claims.
		-AspNetUserClaims para asignar claims especificos a un usuario.
		-AspNetuserLogins para autentificacion con proveedores de terceros como por ejemplo si se quiere
		 que nuestros usuarios puedan autenticar con cuenta de Google.
		-AspNetuserRoles que es una tabla intermedia que permite que haya relacion muchos a muchos entre usuarios y roles
		 Un usuario puede tener varios roles y un rol se puede asignar a muchos usuarios.
		-AspNetUserTokens que permite guardar tokens si se necesita.
		-Se hace Update-Database y se arregla 
		The Entity Framework tools version '9.0.1' is older than that of the runtime '9.0.3'. Update the tools for the latest features and bug fixes. See https://aka.ms/AAc1fbw for more information.
		
		-Se le da a nugget packages desde el administrador y se pincha sobre ellos y actualizar. Se va a la pestaña Updates y se actualiza.
		-Se va a program para configurar en el area de servicio, Identity. IdentityUser es clase que representa a un usuario.Se pasa
		 ApplicationDbContext para que servicios de Identity usen applicationDbContext y se conecten con las tablas de usuarios.
		 Luego, se configura un servicio que se llama Usermanager que es el manejador de usuarios que permite registrar usuarios.
		 Se añade idem SignInManager que permite autenticar usuarios.
		 Idem con AddHttpContextAccessor que permite acceder al conexto HTTP de cualqueir clase.
		 Se configura tambien la autenticacion. Lo de bearer es como el que tiene el token o carga algo. La persona que tenga el JWT demuestra ser el user en cuestion.
		 opciones.MapInboundClaims = false; es para que ASPN.NET Core no me cambie el numero de un calim por otro de forma automatica.
		 Igual tienes un claim que se llama Email y te cambian ese valor por otro.
		 Eso es confuso. Si se llama email prefiero que se quede como email.
		 Se añade la configuracion de un token. En concreto, que es lo que se va a tener en cuenta a la hora de valdiar un token porque no todo token es valido.
		 No se valida ni emisor ni audiencia del token. Si se valida el tiempo de expiracion del token y la llave secreta porque permite firmar token para que si alguien altera y no tiene llave secreta,
		 me lo mande y lo pueda rechazar. Tambien se configura la llave secreta.
		 Llave es clave y se va a extraer de un proveedor de configuracion.
		 Esto es para que asi en produccion yo peuda tener una llave que se va a encontrar con una variable de ambiente en mi servidor de PROD para que no todo el mundo tenga acceso a esta llave secreta.
		 Es con la que se firman los JWT.
		 ClockSkew es para que no se tenga problemas de discrepancia de tiempo cuando validemos la expiracion del token.
		 builder.Services.AddDbContext<ApplicationDbContext>(opciones => opciones.UseSqlServer("name=DefaultConnection"));

		builder.Services.AddIdentityCore<IdentityUser>()
			.AddEntityFrameworkStores<ApplicationDbContext>()
			.AddDefaultTokenProviders();

		builder.Services.AddScoped<UserManager<IdentityUser>>();
		builder.Services.AddScoped<SignInManager<IdentityUser>>();
		builder.Services.AddHttpContextAccessor();

		builder.Services.AddAuthentication().AddJwtBearer(opciones =>
		{
			opciones.MapInboundClaims = false;
			opciones.TokenValidationParameters = new TokenValidationParameters
			{
				ValidateIssuer = false,
				ValidateAudience = false,
				ValidateLifetime = true,
				ValidateIssuerSigningKey = true,
				IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["llavejwt"]!)),
				ClockSkew = TimeSpan.Zero
			};
		});
		
		-Ahora se va al development json para esta llave. Es fuera del logging.
		"llavejwt":  "ALSKDMALSKM3LK4M3LK43M43LAMSDLKASMDALSKDMASLKDMALK3M4LKM4L3KM5";
		
	
	107. Authorize y AllowAnonymous
		-Se van a proteger nuestras accione sy para eso se va a usar el atbto Authorize.
		-Con este se peude indicar que solo ciertas personas con ciertas credenciales pueden consumir una accion.
		-Esas credenciales pueden ser algo tan simple como ser logeado o incluso podria ser que el usuario fuese admin.
		-Se protege nuestras acciones y para eso se coloca el atbto de Authorize a nivel de clase en todos nuestros controladores.
		-Se va  AutoresColeccionController y se mete esto.
		[ApiController]
		[Route("api/autores-coleccion")]
		[Authorize]
		public class AutoresColeccionController : ControllerBase
		
		-Con este authorize no se peuden consumir las acciones que estan en ese controlador.
		-Si se quiere proteger una sola accion se pone el Authorize en la accion y listo.
		-pero, se van a proteger todas las acciones de un controlador.
		-Se añade idem en AutoresController, ComentariosController Y lIBROScONTROLLER.
		-si se hace una peticion desde postman a cvualquier ruta, da 401 que da unauthorized
		-Que pasa si tenemos una accion para la que se quiere hacer una excepcion? 
		-Si se quiere que un usuario no autenticado pueda obtener el listado de autores, pues para eso se peude usar AllowAnonymous,
		-Esto significa que cualquier persona peude usar este endpoint.
		-Se añade AllowAnonymous en el GET de Autores de AutoresController.
		[HttpGet] // /api/autores/
		[AllowAnonymous]
		public async Task<IEnumerable<AutorDTO>> Get()
		
	108. Registrando usuarios
		-Se va a crear Controlador de usuarios que nos va a permitir entre otras cosas registranos y logearnos en nuestra app.
		-Se van a crear unos pocos DTOs.
		CredencialesUsuarioDTO: valor de entrada que vamosa  recibir para registranos y autenticarnos. Se recibe email y password. El password se hace opcional porque quiero poder istanciar un 
		usuarioDTO sin password. En lo que se respecta a recibir las credenciales de UsuarioDTO desde un cliente debe venir con un password y por eso se mete un Required.
		public class CredencialesUsuarioDTO
		{
			[Required]
			[EmailAddress]
			public required string Email { get; set; }
			[Required]
			public string? Password { get; set; }
		}
		
		-Ahora se va a crear DTO que representa el valor de salid del WebAPI cuando el usuario se logea o registra.
		public class RespuestaAutenticacionDTO
		{
			public required string Token { get; set; }
			public DateTime Expiracion { get; set; }
		}
		
		-Se agrega el UsuariosController.
		-Se añade el Authorized porque habrá rutas que se quieren proteger.
		-UserManager para crear un usuario.
		-El IConfiguration es para obtener valores de un proveedor de configuracion.
		-NO se quiere asociar los errores a un campo especifico, por eso se pone string.Empty para coocar error vacio.
		-Se construye tambien un metodo privado para construir un token, el jwt. primero se crean los claims que es ingo acerca del usuario Un claim es una llave y un valor.
		-Se quiere tambien ir a la bbdd a buscar los claims del usuario: se usa userManager para buscar un user.
		-Se busca por Email. Se trabaja con llave secreta que estara en un proveedor de cofiguracion
		-Se usa un algoritmo que nos va a permitir firmar el JWT para que nadie pueda editar de forma fraudulenta sus valores.
		-Nosotros ponemos un año de vigencia para el token para no complicarnos.
		[HttpPost("registro")]
		public async Task<ActionResult<RespuestaAutenticacionDTO>> Registrar(CredencialesUsuarioDTO credencialesUsuarioDTO)
		{
			var usuario = new IdentityUser
			{
				UserName = credencialesUsuarioDTO.Email,
				Email = credencialesUsuarioDTO.Email
			};

			var resultado = await userManager.CreateAsync(usuario, credencialesUsuarioDTO.Password!);

			if (resultado.Succeeded)
			{
				var respuestaAutenticacion = await ConstruirToken(credencialesUsuarioDTO);
				return respuestaAutenticacion;
			}
			else
			{
				foreach (var error in resultado.Errors)
				{
					ModelState.AddModelError(string.Empty, error.Description);
				}

				return ValidationProblem();
			}
		}

		private async Task<RespuestaAutenticacionDTO> ConstruirToken(CredencialesUsuarioDTO credencialesUsuarioDTO)
		{
			var claims = new List<Claim>
			{
				new Claim("email", credencialesUsuarioDTO.Email),
				new Claim("lo que yo quiera", "cualqueir valor")
			};

			var usuario = await userManager.FindByEmailAsync(credencialesUsuarioDTO.Email);
			var claimsDB = await userManager.GetClaimsAsync(usuario!);

			claims.AddRange(claimsDB);

			var llave = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(configuration["llavesjwt"]!));
			var credenciales = new SigningCredentials(llave, SecurityAlgorithms.HmacSha256);

			var expiracion = DateTime.UtcNow.AddYears(1);

			var tokenDeSeguridad = new JwtSecurityToken(issuer: null, audience: null, claims: claims, expires: expiracion, signingCredentials: credenciales);

			var token = new JwtSecurityTokenHandler().WriteToken(tokenDeSeguridad);

			return new RespuestaAutenticacionDTO
			{
				Token = token,
				Expiracion = expiracion
			};
		}
		
		-Se va a postman para hacer un registro. La password tiene que cumplir unas reglas por defecto.
		POST http://localhost:5065/api/usuarios/registro
		{
			"email": "felipe@gmail.com",
			"password": "aA123456!"
		}
		
		-Se le mete esto al metodo: [AllowAnonymous]
		
	109. Login de usuarios
		-Se crea peticion POST. En lugar de usar userManager, se usa SignInManger que se inyecta en el ctor.
		private readonly UserManager<IdentityUser> userManager;
		private readonly IConfiguration configuration;
		private readonly SignInManager<IdentityUser> signInmanager;

		public UsuariosController(UserManager<IdentityUser> userManager, IConfiguration configuration, SignInManager<IdentityUser> signInmanager)
		{
			this.userManager = userManager;
			this.configuration = configuration;
			this.signInmanager = signInmanager;
		}
		
		-Si el usuario e snulo, queire decir que no existe un usuario con ese email. Sin embargo, en cuestiones de ciberseguridad existen ocasiones en las que
		 se quiere ser lo menos especifico posible caundo el usuario se intenta loggear porque no se le peude decir que no existe un usuario con ese email
		 porque entonces se esta revelando info acerca de quien está o no registrado en nuestra app. Para proteger la privacidad de nuestros users,
		 tengo que decir un mensaje vago o generico como Login Incorrecto.
		 Como se va a usar eso de login incorrecto en varios lugares se crea una funcion.
		 lockOutOnFailure es que el usuario aunque se equivoque varias veces al colocar password, no le vamos a bloquear la cuenta.
		[HttpPost("login")]
		public async Task<ActionResult<RespuestaAutenticacionDTO>> Login(CredencialesUsuarioDTO credencialesUsuarioDTO)
		{
			var usuario = await userManager.FindByEmailAsync(credencialesUsuarioDTO.Email);

			if (usuario == null)
			{
				return RetornarLoginIncorrecto(); 
			}

			var resultado = await signInManager.CheckPasswordSignInAsync(usuario, credencialesUsuarioDTO.Password!, lockoutOnFailure: false);

			if (resultado.Succeeded)
			{
				return await ConstruirToken(credencialesUsuarioDTO);
			}
			else
			{
				return RetornarLoginIncorrecto();
			}
		}

		private ActionResult RetornarLoginIncorrecto()
		{
			ModelState.AddModelError(string.Empty, "Login Incorrecto");
			return ValidationProblem();
		}
		
		-Se vuelve a probar la peticion de Postman.
		POST http://localhost:5065/api/usuarios/registro
		{
			"email": "felipe@hotmail.com",
			"password": "aA123456!"
		}
		Debe sacar error
		{
			"errors": {
				"": [
					"Username 'felipe@hotmail.com' is already taken."
				]
			},
			"type": "https://tools.ietf.org/html/rfc9110#section-15.5.1",
			"title": "One or more validation errors occurred.",
			"status": 400,
			"traceId": "00-f052455a4f8071acf2822f5fd4a994f8-954c4b28e287a5c1-00"
		}
		
		-Se añade esto: [AllowAnonymous] a login POST.
		
		-Se lanza desde postman la colicitud POST al login:
		POST http://localhost:5065/api/usuarios/login
		{
			"email": "felipe@hotmail.com",
			"password": "aA123456!"
		}
		
		-Si se coloca password incorrecto, saca Login incorrecto.
		
	110. Enviando el JWT
		-Se aprende a enviar el JWT para poder autenticarnos en la app y consumir los endpoints de la app, los cuales estan protegidos.
		-Si estoy logeado no signfica, en el caso de una herramienta como Postman, que automaticamente  se va a mandar el JWT
		-Se tiene api/libros y me retorna en postman un 401 Unauthorized porque no estoy mandando el JWT
		-Se coge desde la peticion del login el token y se copia desde postman.
		GET http://localhost:5065/api/usuarios/login
		Pestaña authorization > Bearer Token y se mete el token que hemos copiado.
		
		-Se le ha pasado una cabecera que se llama Authorization al WebAPI a traves de la peticion HTTP
		-Igual en un cliente de .net se tiene que construir con el httpClient con Angular o Android  para mandar el toke hace cabecera Authorization = ....
		
	111. Relacion entre Usuarios y Comentarios
		-Un usuario crea un comentario y por lo tanto quiero poder colocar la ID del usuario en el registro del comentario y se quiere que 
		 ese ID se corresponda con un usuario real
		-Se av hacia la entidad comentario 
		-Se vaa  recordar que el Id del usuario. En AspNetusers, el Id es un string.
		-Por tanto, esto se debe colcoar en Comentario.
		-Se pone required porque es obligatorio colcoar el id de un usuario.
		-Se coloca tb una propeidad de navegacion recordadon que es identityuser la clase que representa a un usuario.
		-Se coloca Nullable porque no siempre qie se tenga comentario voy a tener data relacionada.
		-hay un campo como obligatorio (UsuarioId), antes de crearlo, yo voy a tener que borrar la data que está en Comentarios, porque si agrego esta columna,
		 pues valor por defecto es nulo y dara error.
		-Si agrego esta columna, su valor por defecto va a ser nulo, pero no puede ser y dara error.
		-Si hago Add-Migration ComentarioUsuario y luego Update-Database pues se ve que falla.
		-Aunque el valor que se le da es un string vacio no nos vale para el id de un usuario. El error consiste en que no existe un usuario con el Id string vacio.
		-Como se esta configurando el UserId como llave foranea, el valor que coloque en dicho campo tiene que corresponderse con el Id de un usuario.
		-Se va a SQL Server Management Studio y se borra el contenido de la tabla de Comentarios: Delete Comentarios y se repite el comando de migracion.
		-Se actualizan idem los DTOs.
		Antes
		public class Comentario
		{
			public Guid Id { get; set; }
			[Required]
			public required string  Cuerpo { get; set; }
			public DateTime FechaPublicacion { get; set; }
			public int LibroId { get; set; }
			public Libro? Libro { get; set; }
			public List<Comentario> Comentarios { get; set; } = new List<Comentario>();
		}
		
		Despues => Nota: No se cuando se ha borrado esto: public List<Comentario> Comentarios { get; set; } = new List<Comentario>();
		public class Comentario
		{
			public Guid Id { get; set; }
			[Required]
			public required string  Cuerpo { get; set; }
			public DateTime FechaPublicacion { get; set; }
			public int LibroId { get; set; }
			public Libro? Libro { get; set; }
			// public List<Comentario> Comentarios { get; set; } = new List<Comentario>();
			public required string UsuarioId { get; set; }
			public IdentityUser? Usuario { get; set; }
		}
		
		-ComentarioDTO:
		ANTES
		public class ComentarioDTO
		{
			public Guid Id { get; set; }
			public required string Cuerpo { get; set; }
			public DateTime FechaPublicacion { get; set; }

		}
		
		DESPUES
		public class ComentarioDTO
		{
			public Guid Id { get; set; }
			public required string Cuerpo { get; set; }
			public DateTime FechaPublicacion { get; set; }
			public required string UsuarioId { get; set; }
			public required string UsuarioEmail { get; set; }
		}
		
		-Se va a ComentarioController. Se trae data relacionada del usuario.
		ANTES
		 [HttpGet]
		 public async Task<ActionResult<List<ComentarioDTO>>> Get(int libroId)
		 {
			 var existeLibro = await context.Libros.AnyAsync(x => x.Id == libroId);

			 if (!existeLibro)
			 {
				 return NotFound();
			 }

			 var comentarios = await context.Comentarios
				 .Where(x => x.LibroId == libroId)
				 .OrderByDescending(x => x.FechaPublicacion)
				 .ToListAsync();

			 return mapper.Map<List<ComentarioDTO>>(comentarios);
		 }
		 
		DESPUES
		[HttpGet]
		public async Task<ActionResult<List<ComentarioDTO>>> Get(int libroId)
		{
			var existeLibro = await context.Libros.AnyAsync(x => x.Id == libroId);

			if (!existeLibro)
			{
				return NotFound();
			}

			var comentarios = await context.Comentarios
				.Include(x => x.Usuario)
				.Where(x => x.LibroId == libroId)
				.OrderByDescending(x => x.FechaPublicacion)
				.ToListAsync();

			return mapper.Map<List<ComentarioDTO>>(comentarios);
		}
		
		-Esto tb se cambia.
		ANTES
		[HttpGet("{id}", Name ="ObtenerComentario")]
		public async Task<ActionResult<ComentarioDTO>> Get(Guid id)
		{
			var comentario = await context.Comentarios.FirstOrDefaultAsync(x => x.Id == id);

			if (comentario is null)
			{
				return NotFound();
			}

			return mapper.Map<ComentarioDTO>(comentario);
		}
		
		DESPUES
		[HttpGet("{id}", Name ="ObtenerComentario")]
		public async Task<ActionResult<ComentarioDTO>> Get(Guid id)
		{
			var comentario = await context.Comentarios
				.Include(x => x.Usuario)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (comentario is null)
			{
				return NotFound();
			}

			return mapper.Map<ComentarioDTO>(comentario);
		}
		
		-Se va a AutomapperProfiles y se busca el mapeo de Comentario a ComentarioDTO y se configura el mapeo de usuarioEmail. Se mapea de email a usuarioEmail.
		CreateMap<Comentario, ComentarioDTO>();
		CreateMap<Comentario, ComentarioDTO>()
			.ForMember(dto => dto.UsuarioEmail, config => config.MapFrom(ent => ent.Usuario!.Email));		
			
		-Esto consigue mapear la relacion entre usuario y comentario
		-No se tienen ahora comentarios. Lo que se quiere hacer es que cuando cree un comentario, quiero asignarle el id del usuario loggeado a ese comentario.
	
	112. Obteniendo al usuario loggeado
		-En ComnetarioCreacionDTO no se puede meter public required string usuarioId {get; set;}
		-No se puede hacer eso para obtener el Id del usuario loggeado porque cualquier puede mandar cualquier Id por ahi....
		-Se puede mandar el id de cualquiera y eso no puede ser.
		-Para obtener el id del usuario, se busca mecanismo.
		-Esto se va a hacer a traves del JSON Web Token que recibimos.
		-El JSOn Web Token contiene Claims y uno de los claims que le pusimos es el claim del email.
		-Esto se ve en el metodo ConstruirToken de UsuariosController.
		-A partir de ese email, voy a poder obtener el ID del usuario a traves del UserManager
		-Se toma el email del claim del json web token y de ahi buscas en la bbdd a que usuario le corresponde ese email.
		-Porque se puede confiar ene el email del token y no en el de ComentarioCreacionDTO? No se peude confiar porque cualquier puede
		 poner cualquier valor. En el claim no se peude poner cualquier valor porque ese jsonwebtoken es firmado con llave secreta.
		-Como es firmado con llave secreta, pues significa que se peude confiar en su contenido porque aquellos que tengan acceso a la llave secreta 
		 van a poder generar json web token valido para nuestra app, por eso se peude confiar en el email que se recibe por el claim.
		-Se crea un servicio que permite obtener el Id del usuario a partir de json web token.
		-Se crea una folder que se llame Servicios y dentro ServiciosUsuarios. Se mete nullable a lo que devuelve porque peude que usuario no exista.
		 que es tipico si el usuario no está loggeado.
		 public async Task<IdentityUser?> ObtenerUsuario()
		{
			var emailClaim = contextAccessor.HttpContext!.User.Claims.Where(x => x.Type == "email").FirstOrDefault();

			if (emailClaim is null)
			{
				return null;
			}
			var email = emailClaim.Value;
			return await userManager.FindByEmailAsync(email);
		}
		
		-Se crea una interfaz a partir de esta clase para poder usar el principio de inversion de dependencias para que asi dependamos de tipos abstractos y no de tipos concretos.
		-Se mete ctrl + . + k. Se crea una nueva interfaz y fuera.
		-Se va a Program y se coloca el servicio nuevo:
		-Se mete transient porque no se necesita compartir estado: builder.Services.AddTransient<IServiciosUsuarios, ServiciosUsuarios>();
		
		-Asi, se puede obtener el usuario loggeado en nuestra app pero de forma segura para que no se peuda su Id de usuario.
		
	113. Utilizando el servicio de usuarios.
		-Se va a usar el servicio de usuarios para crear, actualizar y borrar un comentario.
		-Se va a ComentariosControlelr y se inyecta IServiciosUsuarios.
		private readonly ApplicationDbContext context;
		private readonly IMapper mapper;
		private readonly IServiciosUsuarios serviciosUsuarios;

		public ComentariosController(ApplicationDbContext context, IMapper mapper, IServiciosUsuarios serviciosUsuarios)
		{
			this.context = context;
			this.mapper = mapper;
			this.serviciosUsuarios = serviciosUsuarios;
		}
		
		-Se va a la parte del Post, despues de examninar la existencia del libro se hace lo siguiente en el POST.
		 No deberia llegar a pasar el NotFound porque hay que recordar que arriba hay un Authorize.
		 Asi se asigna al comentario el Id del usuario que escribio dicho comentario.
		 Antes
		[HttpPost]
		public async Task<ActionResult<ComentarioDTO>> Post(int libroId, ComentarioCreacionDTO comentarioCreacionDTO)
		{
			var existeLibro = await context.Libros.AnyAsync(x => x.Id == libroId);

			if (!existeLibro)
			{
				return NotFound();
			}

			var comentario = mapper.Map<Comentario>(comentarioCreacionDTO);
			comentario.LibroId = libroId;
			comentario.FechaPublicacion = DateTime.Now;
			context.Add(comentario);
			await context.SaveChangesAsync();

			var comentarioDTO = mapper.Map<ComentarioDTO>(comentario);

			return CreatedAtRoute("ObtenerComentario", new { id = comentario.Id, libroId }, comentarioDTO);
		}
		
		DESPUES
		[HttpPost]
		public async Task<ActionResult<ComentarioDTO>> Post(int libroId, ComentarioCreacionDTO comentarioCreacionDTO)
		{
			var existeLibro = await context.Libros.AnyAsync(x => x.Id == libroId);

			if (!existeLibro)
			{
				return NotFound();
			}

			var usuario = await serviciosUsuarios.ObtenerUsuario();

			if(usuario is null)
			{
				return NotFound();
			}

			var comentario = mapper.Map<Comentario>(comentarioCreacionDTO);
			comentario.LibroId = libroId;
			comentario.FechaPublicacion = DateTime.Now;
			comentario.UsuarioId = usuario.Id;
			context.Add(comentario);
			await context.SaveChangesAsync();

			var comentarioDTO = mapper.Map<ComentarioDTO>(comentario);

			return CreatedAtRoute("ObtenerComentario", new { id = comentario.Id, libroId }, comentarioDTO);
		}
		
		-En el patch se hace algo parecido pero no se quiere que se actualice el Id del usuario que escribio el comentario 
		 pero si quiero verificar que el usuario que esta haciendo la actualizacion del comentario se ael que escribio el comentario.
		 FGavilan no va a ir a editar el comentario de Claudia.
		 Se retorna un Forbid porque no se peude editar el comentario de otro.
		ANTES
		[HttpPatch("{id}")]
		public async Task<ActionResult> Patch(Guid id, int libroId, JsonPatchDocument<ComentarioPatchDTO> patchDoc)
		{
			if (patchDoc is null)
			{
				return BadRequest();
			}

			var existeLibro = await context.Libros.AnyAsync(x => x.Id == libroId);

			if (!existeLibro)
			{
				return NotFound();
			}

			var comentarioDB = await context.Comentarios.FirstOrDefaultAsync(x => x.Id == id);

			if (comentarioDB is null)
			{
				return NotFound();
			}

			var comentarioPatchDTO = mapper.Map<ComentarioPatchDTO>(comentarioDB);

			patchDoc.ApplyTo(comentarioPatchDTO, ModelState);

			var esValido = TryValidateModel(comentarioPatchDTO);

			if (!esValido)
			{
				return ValidationProblem();
			}

			mapper.Map(comentarioPatchDTO, comentarioDB);

			await context.SaveChangesAsync();

			return NoContent();
		}
		
		
		DESPUES
		[HttpPatch("{id}")]
		public async Task<ActionResult> Patch(Guid id, int libroId, JsonPatchDocument<ComentarioPatchDTO> patchDoc)
		{
			if (patchDoc is null)
			{
				return BadRequest();
			}

			var existeLibro = await context.Libros.AnyAsync(x => x.Id == libroId);

			if (!existeLibro)
			{
				return NotFound();
			}

			var usuario = await serviciosUsuarios.ObtenerUsuario();

			if (usuario is null)
			{
				return NotFound();
			}

			var comentarioDB = await context.Comentarios.FirstOrDefaultAsync(x => x.Id == id);

			if (comentarioDB is null)
			{
				return NotFound();
			}

			if (comentarioDB.UsuarioId != usuario.Id)
			{
				return Forbid();
			}

			var comentarioPatchDTO = mapper.Map<ComentarioPatchDTO>(comentarioDB);

			patchDoc.ApplyTo(comentarioPatchDTO, ModelState);

			var esValido = TryValidateModel(comentarioPatchDTO);

			if (!esValido)
			{
				return ValidationProblem();
			}

			mapper.Map(comentarioPatchDTO, comentarioDB);

			await context.SaveChangesAsync();

			return NoContent();
		}
		
		-En el delete, se quita lo de los registrosBorrados porque queremos que solamente Felipe peuda borrar el comentario de Felipe,e s decir, que un usuario borre su propio comentario.
		 Para obtener el Id del usuario que hizo el comentario, tengo que obtener antes el comentario.
		 Se va a aprovechar a mostrar otra forma que se tiene de borrar registros de una tabla usando EF Core.
		 Se recuerda que se obtiene como param de la funcion el Id y no el comentario como tal.
		 ANTES
		[HttpDelete("{id}")]
		public async Task<ActionResult> Delete(Guid id, int libroId)
		{
			var existeLibro = await context.Libros.AnyAsync(x => x.Id == libroId);

			if (!existeLibro)
			{
				return NotFound();
			}

			var registrosBorrados = await context.Comentarios.Where(x => x.Id == id).ExecuteDeleteAsync();

			if (registrosBorrados == 0)
			{
				return NotFound();
			}

			return NoContent();
		}
		
		DESPUES
		[HttpDelete("{id}")]
		public async Task<ActionResult> Delete(Guid id, int libroId)
		{
		var existeLibro = await context.Libros.AnyAsync(x => x.Id == libroId);

		if (!existeLibro)
		{
			return NotFound();
		}

		var usuario = await serviciosUsuarios.ObtenerUsuario();

		if (usuario is null)
		{
			return NotFound();
		}

		var comentarioDB = await context.Comentarios.FirstOrDefaultAsync(x => x.Id == id);

		if(comentarioDB is null)
		{
			return NotFound();
		}

		if (comentarioDB.UsuarioId != usuario.Id)
		{
			return Forbid();
		}

		context.Remove(comentarioDB);
		await context.SaveChangesAsync();

		return NoContent();
		}
		
		-Se va a probar con un solo usuario y si tengo dos usuarios, verificar que por ejemplo Felipe no pueda borrar comentario de Claudia.
		
		-Se levanta la app y se va a PostMan. Hay que loggearse antes...
		-Se lanza esta peticion HTTP: http://localhost:5065/api/libros/1/comentarios.
		-El token se mete en Authorization > Bearer.
		-Se loggea con Borja y Felipe (jgavilan) y se copian en Notepad++ los dos token.
		- Se manda una peticion GET http://localhost:5065/api/libros/1/comentarios con el Authorization token y se ve que esta vacio porque no hay comentarios.
		-Se crea un comentario con el token de fgavilan.
		-POST http://localhost:5065/api/libros/1/comentarios
		{
			"cuerpo": "Buen Libro"
		}
		
		-Se hac u select en comentarios y se ve el Id del usuario.
		-Se va a intentar actualizar un comentario.
		-Se duplica el tab, se coge el Id del comentario, no del usuario y es un patch
		-PATCH http://localhost:5065/api/libros/1/comentarios/836add29-4c70-4ddf-a158-08dd7dbcf17d
		[{
			"op": "replace",
			"path": "/cuerpo",
			"value": "comentario actualizado"
		}]
		
		-Se hace un get del comentario.
		GET http://localhost:5065/api/libros/1/comentarios OK
		
		-Se va a borrar el comentario, duplicando la ultima pestaña, cambiando patch por delete.
		-Da OK el rdo. Se le da al GET y hay cero comentarios.
		
		-Se va al POST y se vuelve a crear el comentario.
		-Se va al GET y todo OK.
		-Se coge el token de Borja ahora y se va al patch. Con el token de borja, se va a intentar actualizar el comentario de Felipe.
		-Da Forbiden.
		-No se peude actualizar ni borrar el comentario de otra persona...
		
	114. Renovado el token
		-Los token sabemos que expiran por tema de seguridad para que no tengas un token que exista para siempre y si usuario malicioso lo tiene, no pueda usarlo siempre.
		 Esa es la logica de ponerle un tiempo de expiracion al token.
		-Nosotros le pusimos un año de expiracion al token pero en un banco es demasiado y se suele poner 15 mins.
		-Si eres usuario, estas en app bancario y de repente te saca en plenas oepraciones de forma activa y te saco porque el token 
		 expiró. Eso es pesima experiencia de usuario. Si se pone una fecha de expiracion corta como unos 20 mins, se peude poner un endpoint o una accion 
		 a traves de la cual el cliente puede renovar el token para asi, si usuario usa activamente la app, no se permite que el token expire sino que 
		 el cliente solicita nuevo token y por detras de camaras sae le da un nuevo token con nueva fecha de expiracion ya si usuario sigue usando app sin problema.
		-Se va a UsuariosController y se mete ese endpoint. No se tiene que recibir nada porque al final voy a verificar que el usuario esta loggeado
		 usando el servicio de usuarios. Se inyecta en el controlador el IServiciosUsuario
		public class UsuariosController : ControllerBase
		{
			private readonly UserManager<IdentityUser> userManager;
			private readonly IConfiguration configuration;
			private readonly SignInManager<IdentityUser> signInManager;
			private readonly IServiciosUsuarios serviciosUsuarios;

			public UsuariosController(UserManager<IdentityUser> userManager, IConfiguration configuration, SignInManager<IdentityUser> signInManager, IServiciosUsuarios serviciosUsuarios)
			{
				this.userManager = userManager;
				this.configuration = configuration;
				this.signInManager = signInManager;
				this.serviciosUsuarios = serviciosUsuarios;
			}
		
		Endpoint
		[HttpGet("renovar-token")]
		public async Task<ActionResult<RespuestaAutenticacionDTO>> RenovarToken()
		{
			var usuario = await serviciosUsuarios.ObtenerUsuario();

			if (usuario is null)
			{
				return NotFound();
			}

			var credencialesUsuarioDTO = new CredencialesUsuarioDTO { Email = usuario.Email! };

			var respuestaAutenticacion = await ConstruirToken(credencialesUsuarioDTO);
			return respuestaAutenticacion;
		}
		
		-Se prueba
		GET http://localhost:5065/api/usuarios/renovar-token Se mete el token de uno de los usuarios autenticados.
		
		-Se ve que se renueva y asi si tenemos un token que solo dura 20 mins en lo que el usuario usa la app, el cliente que puede ser una app de android, angular puede renovar silenciosamente el token
		 para dar una buena experiencia de usuario.
		 
	115. Configurando la autorizacion basada en claims
		-Falta brindar aun mas seguridad a nuestras rutas.
		-Es decir, que solo usuarios admin que puedan realziar tal o tal accion.
		-Parta empezar se va a crea runa politica de seguridad.
		-Esta permite indicar qué caracteristicas debe tener un usuario para pdoer realizar una accion.
		-Se va a decir que debe tener un claim especial que es el de los admin.
		-Se va a Program y se mete debajo de autenticacion ya que se va a meter una politica de autorizacion
		-La politica requiere que se tenga la politica esAdmin.
		-Cualquier usuario que tenga este claim va a ser un admin.
		-Se peuden meter ahi tantas politicas como se quiera. Se peude meter "esVendedor".
		builder.Services.AddAuthorization(opciones =>
		{
			opciones.AddPolicy("esadmin", politica => politica.RequireClaim("esadmin"));
		});
		
		-Para usar la politica, se va a AuotresColeccionController y en lugar de decir solo Authorize que dice que el usuario tiene que estar autenticado, pues tambien
		 se mete la politica. El JSONWebToken debe tener este claim de esadmin.
		[ApiController]
		[Route("api/autores-coleccion")]
		[Authorize(Policy = "esadmin")]
		public class AutoresColeccionController : ControllerBase
		
		-Se mete tb en AutoresController
		-El del AllowAnonymous que permite obtener siempre el lista de autores, es OK.
		
		-En comentarios tenemos el Authorize peroe sta bien porque se tienen comentarios como crear comentario, pero cualquier usuario puede crear comentarios.
		-Se mete idem en LibrosController.
		
		-En usuarios se tiene el authorize pero hay que tener cuidado porque cualquier que tenga un JSONWebToken debe poder utilizar como la accion de RenovarToken.
		 pero habra otras accioens como agregar los claims a u usuario que no.
		 Una forma sencilla es quitar el Auhorize y trabajar a nivel especifico de cada accion.
		 Se quitan los AllowedAnonymous y en renovar-token se mete Authorize.
		 
		-Se van a crear las acciones de UsuariosController que si que vana  necesitar la poitica de esadmin que van a permitr agregar un claim a un usuario.
		-Se crea EditarClaimDTO.
		public class EditarClaimDTO
		{
			[EmailAddress]
			[Required]
			public required string Email { get; set; }
		}
		
		-Ahora vamos a crear acciones debajo de renovar-token.
		-Se recibe el email del usuario al cual quiero hacer admin. Yo soy admin y quiero hacer a otro admin por eso no se usa el servicio de usuarios.
		[HttpPost("hacer-admin")]
		[Authorize(Policy = "esadmin")]
		public async Task<ActionResult> HacerAdmin(EditarClaimDTO editarClaimDTO)
		{
			var usuario = await userManager.FindByEmailAsync(editarClaimDTO.Email);

			if(usuario is null)
			{
				return NotFound();
			}

			await userManager.AddClaimAsync(usuario, new Claim("esadmin", "true"));
			return NoContent();
		}
		
		-Se av a hacer lo mismo pero para remover admin.
		[HttpPost("remover-admin")]
		[Authorize(Policy = "esadmin")]
		public async Task<ActionResult> RemoverAdmin(EditarClaimDTO editarClaimDTO)
		{
			var usuario = await userManager.FindByEmailAsync(editarClaimDTO.Email);

			if (usuario is null)
			{
				return NotFound();
			}

			await userManager.RemoveClaimAsync(usuario, new Claim("esadmin", "true"));
			return NoContent();
		}
		
		-Lo primero que tenemos que hacer es hacer admin a un usuario de forma manual porque recordamos que hay una tabla de claims
		 quee s donde se va a agudar el claim que señalamos aqui.
		 Se puede hacer en DEV esto y luego se explora en la BBDD cómo se visualiza esto...
		 [HttpPost("hacer-admin")]
		// [Authorize(Policy = "esadmin")]
		public async Task<ActionResult> HacerAdmin(EditarClaimDTO editarClaimDTO)
		{
			var usuario = await userManager.FindByEmailAsync(editarClaimDTO.Email);

			if(usuario is null)
			{
				return NotFound();
			}

			await userManager.AddClaimAsync(usuario, new Claim("esadmin", "true"));
			return NoContent();
		}
		
		-Se prueba esto...
		-Se tiene AspNetUserClaims que es la tabla de claims de usuarios que ahora no tiene nada.
		 Se va a mandar un POST http://localhost:5065/api/usuarios/hacer-admin
		 {
			"email": "jgavilan@gmail.com"
		 }
		 
		-En PROD para hacer admin a un usuario sin tener que quitar [Authorize(Policy = "esadmin")], pues se inserta un registro en BBDD.
		 en AspNetUserClaims, el Id del usuario se saca de AspNetUsers.
		 Se ve que se tenian dos tokens
		 Se ve que el token de Felipe fue creado antes de teenr ese claim en AspNetUserClaims,
		 por tanto el token viejo no tiene el claim de que el usuario es administrador.
		 Se tiene que generar un token nuevo.
		 Se hace post a login con fgavilan.
		 Se va a ver que el token que se genera si que tiene el claim de administrador.
		 Se puede verificar con jwt.io.
		 Ahora se puede evr que se peude ver listado de libros porque si uso el token anterior, pues da error de Forbid, pero con el token nuevo no.
		 
		-Se comprueba en este endpoint: GET http://localhost:5065/api/libros y con el Authorization > Bearer.
		-Ahora se puede descomentar el Authorize y hacer admin a quiens e quiera.
		
		-Solo se peude hacer admin con un token que tenga de claim esAdmin.
		-Lo mismo para borrar a un admin...
		-Hay que tener cuidado porque un usuario puede dejar de ser admin pero el token sino ha caducado pues ojo....
		
	116. Agregando una columna a la tabla de usuarios
		-Se va a querer guardar info extra acerca de los usuarios.
		-En AspNetusers se tiene un cjto de columnas, pero si se quiere guardar Fechanacimiento, como se cambia tabla de usuarios?
         Se crea una nueva clase y se crea migracion
		 Se crea la entidad usuario.
		 Se hereda de IdentityUser. Ahora se hereda de esa clase para que sea la clase Usuario la que representa a un usuario.
		 public class Usuario : IdentityUser
		{
			public DateTime FechaNacimiento { get; set; }
		}
		
		-Ahora se va a ApplicationDbContext y hay que decirle que hereda de IdentityDbContext y se indica Usuario porque hay que especificar que el tipo
		 de dato que representa a un usuario es la clase Usuario.
		 public class ApplicationDbContext : IdentityDbContext<Usuario>
		 
		-Se tiene que hacer cambio en el proeycto para que en todas partes donde se usó IdentityUser, use usuario.
		-Se da control Find y se marca EntireSolution y Se da a buscar.
		 No se peude hacer automaticamente, porque hay lugares donde no lo puedo cambiar. Hay en migraciones pe que no se puede cambiar.
		-Se hace todo a mano.
		-Ojo que en el reemplazo se ignora la carpeta Migrations.
		-Se va a hacer Add-Migration UsuarioFechaNacimiento
		-Si da error la migracion, es porque queda por cambiar en algun lafo IdentityUser por Usuario.
		-Despues se hace Update-Database.
		-Se refresca Db y se evra que hay FechaNacimeinto
		-Se crea un nuevo DTO porque quiero una nueva accion para editar los datos del usuario.
		-Se le llama ActualizarUsuarioDTO. No se va a pedir fechaNacimiento al registrarse el usuario. Se tiene el DTO para actualizar al usuario.
		public class ActualizarUsuarioDTO
		{
			public DateTime FechaNacimiento { get; set; }
		}
		
		-Se va a UsuariosController y nueva accion para actualizar el user, antes de renovar-token. No tiene que ser un admin porque un usuario puede colcoar 
		 su propia fecha de nacimiento sin ser admin por eso se pone Authorize.
		 [HttpPut]
		[Authorize]
		public async Task<ActionResult> Put(ActualizarUsuarioDTO actualizarUsuarioDTO)
		{
			var usuario = await serviciosUsuarios.ObtenerUsuario();

			if(usuario is null)
			{
				return NotFound();
			}

			usuario.FechaNacimiento = actualizarUsuarioDTO.FechaNacimiento;

			await userManager.UpdateAsync(usuario);
			return NoContent();
		}
		
		-Con esto, se va a PostMan y se hace esto, con el authorization bearer token que corresponde al usuario propio....
		PUT http://localhost:5065/api/usuarios
		{
			"fechaNacimiento": "1911-05-23"
		}
		
	117. Obtener el listado de usuarios
		-Se crea accion para obtener el listadod e users de la tabal de usuarios.
		-En vez de depender del UserManager, se va a usar el applicationDbContext.
		-Se crea un DTO que represente la data del usuario que quiero retornar. 
		public class UsuarioDTO
		{
			public required string Email { get; set; }
			public DateTime Fechanacimiento { get; set; }
		}
		
		-Se va a UsuariosController y se mete get debajo del constructor porque le gusta que primero esten los GET que es cuestion de gustos.
		 Solo admin ve esta data. Se inyecta el ApplicationDbContext.
		 Se tiene asi acceso a las tablas de Identity.
		 Tambien se inyecta IMapper.
		 private readonly UserManager<Usuario> userManager;
		private readonly IConfiguration configuration;
		private readonly SignInManager<Usuario> signInManager;
		private readonly IServiciosUsuarios serviciosUsuarios;
		private readonly ApplicationDbContext context;
		private readonly IMapper mapper;

		public UsuariosController(UserManager<Usuario> userManager, IConfiguration configuration, 
			SignInManager<Usuario> signInManager, IServiciosUsuarios serviciosUsuarios, ApplicationDbContext context, IMapper mapper)
		{
			this.userManager = userManager;
			this.configuration = configuration;
			this.signInManager = signInManager;
			this.serviciosUsuarios = serviciosUsuarios;
			this.context = context;
			this.mapper = mapper;
		}

		[HttpGet]
		[Authorize(Policy="esadmin")]
		public async Task<IEnumerable<UsuarioDTO>> Get()
		{
			var usuarios = await context.Users.ToListAsync();
			var usuariosDTO = mapper.Map<IEnumerable<UsuarioDTO>>(usuarios);
			return usuariosDTO;
		}
		
		-Se va a AutomapperProfiles para configurafr este mapeo.
		CreateMap<Usuario, UsuarioDTO>();
		
		-Se prueba.
		GET http://localhost:5065/api/usuarios + authorization bearer....
		
	118. Deslogueo
		-En WebAPI no se tiene que trabajar con deslogueo.
		-Cuando me logueo desde un cliente como PostMan se manda JWT y si tienes cliente como app de Angular, React, tienes JWT y si quieres 
		 deslogegarte pues borras ese JWT.
		 Es decir, hay que borrarlo de mi app de Android etc.
		 No hay que tener una accion en el WebAPI para permitir el desloggeo porque el logeo se permite por JWT. Sis e quiere deslogegarse hay que deshacerse de ese JWT
		 Si esta gaurdado en variable, se borra y listo.
		 En MVC si que hay que crear mecanismo de deslogeo pero en WebAPI no.
	
	119. Introducción a CORS
		Política de Seguridad del Mismo Origen
		-Existe una politica de seguridad que por defecto, impide que desde un navegador en una pagina de origen X
		 se haga una peticion HTTP a un endpoint de un origen G. 
		 Esto quiere decir que si estamos usando nuestro navegador en una pagina midominio.com e intentamos hacer una peticion HTTP
		 via JS a endpoint de dominnio midominio2.com, entonces se obtendra un error. El nombre de la politica de seguridad es 
		 poitica de seguridad del mismo origen. Esto es una politica de seguridad de navegadores.
		 No se va a tener el mismo problema si se hace una peticion HTTP desde una app movil, desde un servidor web, desde postman....
		-La politica se aplica a nivel del origen y no solo del dominio. 
		 Un origen es la combinacion de Esquema URI (http o https) + nombre del host + numero de puerto.
		-Para estos fines, las siguientes URLs que se vana  mostrar son de origen distinto a miDominio. com
		ORIGEN                         | Razon de que sea diferente
		http://www.miDominio.com       | El subdominio WWW
		https://www.miDominio.com      | El protocolo HTTPS
		http://www.miDominio.com:1234  | El puerto 1234
		http://www.miDominio.net       | El dominio es diferente
		
		-La razon de esta politica es prevenir el acceso de un script malicioso en una pagina a los recursos de otra pagina.
		-Hay ocasioens en las que se va a querer que se hagan peticiones HTTP sobre nuestros endpoints 
		 aun cuando estos vengan de otros origenes. Suele pasar mucho en WebAPI, ayq ue se tendra un servidor web detras 
		 de un origen disitnto que nuestra pagina web.
		 Por ejemplo, si se tiene un Single Page Application, es decir, una pagina de react, Angular, etc.
		 
		-Se peude habilitar el intercambio de recursos de origen cruzado (CORS) para permitir peticiones
		 desde otros origenes hacia nuetsro WebAPI.
		-Priemro se quiere ver que habra un error de CORS al intentar acceder directamente a nuestro WebAPI.
	
	120. Experimientando un error de CORS
		-Se va a crear una simple pagina HTML para probar nuestro WebAPI.
		-La idea es que se configurara un servidor difernete al nuestro pues por politica de CORS, no se nos 
		 dejara consumir e WebAPI desde el documento HTML. Se peude usar VS Code.
		 Se usa VS Code para levantar servidor Web.
		 Se abre el proyecto con VS Code y se crea un fichero: ejemplo-cors.html
		-Se tiene un script que se va a ejecutar al momento de que se cargue la pagina.
		-Se va a hacer una epticion HTML al endpoint de autores: https://localhost:5065/api/autores
		-Se descarga una extension que se llama Live Server que eprmite levantar servidor web.
		-Boton derecho en el HTML y abrir con Live Server.
		-Si se le da al F12 da Connection Refused porque el WebAPI está abajo.
		-Se levanta webAPI y da error de CORS. No se peude hacer una peticion a la pagina de webAPI porque son puertos diferentes y hay que configurar politica de CORS para poder comunicarse.
		
	121. Configurando CORS en ASP.NET
		-Al intentar comunicarnos con nuetsor webAPI desde doc HTML hay error de CORS que es Cros Origin Resource Sharing o intercambio de recursos de origen cruzado y esos mecanismos 
		 impiden que desde origenes desconocidos a nuestros webAPI se peudan comunicar con nosotros.
		 Si quiero poder comunicarme con este WebAPI desde el origen...
		
		-Se va a Program y se habilita CORS.
		-Por ahora se pone AllowAnyOrigin que desde cualquier origen se pueden comunicar con nosotros y se permite cualquier método
		 y se permite cualquier cabecera.
		builder.Services.AddCors(opciones =>
		{
			opciones.AddDefaultPolicy(opcionesCORS =>
			{
				opcionesCORS.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader();
			});
		});
		
		-Se va a Middlewares para habilitar CORS: app.UseCors();
		-Se hace Ctrl + F5 y se obtiene la info del endpoint de antes de autores.
		-No es necesario abrir WebAPI para que desde cualqueir origen se peudan comunicar con nosotros. Igual se puede eprmitir solo un listado de origenes.
		 Se va al appsettings.Development.json y se mete origenesPermitidos y es algo que se quiere colocar en un proveedor de configuracion
		 porque es algo que se peude cambair para diferentes ambientes.
		 Se mete arreglo. La verificación de CORS se hace del string completo asiq ue cuidado con meter / al final de la URL.
		 El navegador manda el origen sin la barra: "origenesPermitidos": [ "http://127.0.0.1:5500" ]
		
		-Se mete esto en Program.cs
		var origenesPermitidos = builder.Configuration.GetSection("origenesPermitidos").Get<string[]>();
		
		-Se cambia lo de allowAnyOrigins con esto.
		//área de servicios
		var origenesPermitidos = builder.Configuration.GetSection("origenesPermitidos").Get<string[]>()!; => No va a ser nulo !

		builder.Services.AddCors(opciones =>
		{
			opciones.AddDefaultPolicy(opcionesCORS =>
			{
				opcionesCORS.WithOrigins(origenesPermitidos).AllowAnyMethod().AllowAnyHeader();
			});
		});
		
		-Si se cambia el pueerto de origenespermitidos, pues nos volverá a dar problemas.
		
		
	122. Retornando cabeceras personalizadas - CORS
		-Esto va a ser util cuando se tiene info que queremos transimitir al cliente que no queremos colocar en el cuerpo de la respuesta
		 HTTP porque quizas no es parte de la respuesta sino que es metadata.
		-Se va a suponer que se quiere retornar una cabecera personalizada para transmitirle esa informacion que no e sparte del cuerpo al cliente.
		 Por defecto dicha cabecera no se muestra al code de JS.
		-Se mete middleware. Se mete await next(); para continuar con la ejecucion del resto de los middlewares.
		app.Use(async (contexto, next) =>
		{
			contexto.Response.Headers.Append("mi-cabecera", "valor");
			await next();
		});
		
		-El middleware se va a ejecutar antes cualquier epticion HTTP que haga.
		-Se peude hacer a login una peticion y en la cabecera se tiene "mi-cabecera": "valor".
		-Si intento acceder a esa cebecera desde el documento HTML, usando JS no se nos va a mostrar.
		const cabeceras = Array.from(respuesta.headers.entries());
        console.log(cabeceras);
		
		-Por politica de CORS, no se permite que los navegadores peudan acceder a esa info personalziada. hay que configurarlo
		-Para que se accesible en la config del CORS, se añade esto:
		//área de servicios
		var origenesPermitidos = builder.Configuration.GetSection("origenesPermitidos").Get<string[]>()!;

		builder.Services.AddCors(opciones =>
		{
			opciones.AddDefaultPolicy(opcionesCORS =>
			{
				opcionesCORS.WithOrigins(origenesPermitidos).AllowAnyMethod().AllowAnyHeader()
				.WithExposedHeaders("mi-cabecera");
			});
		});
		
		-Hay que exponer la cabecera....
	
	123. Entendiendo la encriptación
		-Hay funcion f que transofrma numero de la siguiente forma.
		F(2) = 7
		F(5) = 16
		
		-Si queremos una funcion G que revierta la operacion de F, que hacemos?
		 Hay que conocer lo que hace la funcion F para realizar la reversion. Hay que conocer el screto de la funcion F para poder tomar 
		 el numero resultante y obtener el numero original.
		-Hay funcion F la cual realiza una transformacion sobre un parametro.
		 Ademas, podemos deducir valor incial a aprtir del rdo si se conoce el secreto de funcion inicial.
		 
		-La encriptacion es un proceso que le aplicamos a un mensaje para codifciarlod e tal modo que solo personas autorizadas
		 peudan conocer el mensaje original. Al mensaje original que se va a encriptar se le llama texto plano.
		-Al rdo del proceso de encriptacion se le llama texto cifrado.
		-F(2) = 7, el 2 es el texto plano y el 7 es el tetxo cifrado.
		-La encriptacion busca proteger el tetxo plano. La idea es que una persona si ve el texto cifrado, le sea virtualmente imposible dedudcir el texto plano correpsondiente.
		-Un algoritmo de encriptacion es tan bueno como el nivel de dificultad que le provoque a un usuario no autorizado recobrar el texto plano a partir del texto cifrado.
		-En el caso de nuestra funcion f, el algoritmo de encriptacion no es bueno porque solo toma numero * 3 y suma uno y no es dificil de deducir.
		-En mund real, existen algoritmos de encriptacion avanzados y ato nivel de eficacia.
		-Para estos algoritmos lo tipico es usar una llave la que permite recobrar el tetxo plano a partir del cifrado. Es imprescindible proteger la llave
		 de personas no autorizadas.
		-La llave tieende a ser string aleatorio tremendamente largo.
		-Una manera deproteger esta llave es colocandola en un sitio seguro como vble de ambiente.
	
	124. Encriptacion en ASP.NET
		-Para encriptar en ASP.NET Core se ofrece el servicio de proteccion de datos.
		-Se puede usar IDataProtectionProvider y IDataProtector. El ultimo es el que se encarag de encriptar y desencriptar mensajes, el otro se encarga de crear IDataProtector.
		-En Program, Servicios, se añade: builder.Services.AddDataProtection();
		-Cone sto se tiene la configuracion minima necesaria para realziare ncriptacion a traves de servicios que hemos comentado.
		-Se crea controlador para no colocar codigo de ejemplo inncesario.
		-Se le llama SeguridadController.
		-Al CreateProetctor se le pasa un string de proposito que se peude pensar como parte de la llave del algoritmo de encriptacion que vamos a usar.
		-Sino se tiene el string de proposito, ni siquiera se peude desencriptar.
		-Es importante usar un string de proposito unico a menos a nivel de la app para asi tener una mayor proteccion de datos para que asi lo que yo encripte 
		 desde esta clase, no se pueda desencriptar desde otra clase, agregando una capa mas de proteccion de datos.
		-Ademas, dependiendo del proposito de la encriptacion, es posible que el string se quiera tener oculto, porque si encripto trahetas de credito, nos e quiere
		 que peresona entre a ese string de propsoito. Se mete el nombre de la clase, con eso te aseguras de que no se peuda desencriptar lo que yo encripto.
		-El string de proposito no es la llave sino parte de ella.
		-ASP.NET Core genera unas llaves que por defecto estan ocultas, de tal forma que quien no tenga esas llaves no peude desencriptar el texto cifrado.
		-Se meten dos acciones GET. Una toma un texto plano, lo cifra y devuelve.
		[HttpGet("encriptar")]
		public ActionResult Encriptar(string textoPlano)
		{
			string textoCifrado = protector.Protect(textoPlano);
			return Ok(new { textoCifrado });
		}

		[HttpGet("desencriptar")]
		public ActionResult Desencriptar(string textoCifrado)
		{
			string textoPlano = protector.Unprotect(textoCifrado);
			return Ok(new { textoPlano });
		}
		
		-Se va a postman y se prueba: GET http://localhost:5065/api/seguridad/encriptar?textoPlano=Felipe; params => textoPlano: Felipe.
		-Aunque se use tetxoPlano el algoritmo de encriptacion cada vez que se da a enviuar manda un string diferente. Al final, se tiene otro tetxo cifrado. Es dificil descubir texto plñano
		 a partir del cifrado.
		-Ahora se prueba desenciptar. Si se manda Felipe no se tiene string de base64 y daria error.
		-Me llevo el chorro: GET  http://localhost:5065/api/seguridad/desencriptar
		params => textoCifrado: CfDJ8I5OtKyks09OrG0siKLxsm2dCMcHbZVHNf177CgXGOEQq0nW0b3jl31kDrJmi8pNJ65J93X6tXsJA8R0mmZxlxU0Rc7o1EFs31uD8jPuSGC14-uQekIb24H2NuwNQivE7w
		
		-Te doy tetxo cifrado y ahora solo peudes usarlo por 1h, 1 dia....
		-Se crea protector limitado por tiempo en constructor del controller.
		private readonly IDataProtector protector;
		private readonly ITimeLimitedDataProtector protectorLimitadoPorTiempo;

		public SeguridadController(IDataProtectionProvider protectionProvider)
		{
			protector = protectionProvider.CreateProtector("");
			protectorLimitadoPorTiempo = protector.ToTimeLimitedDataProtector();
		}
		
		-Mismas peticiones, limitado por tiempo.
		[HttpGet("encriptar-limitado-por-tiempo")]
		public ActionResult EncriptarLimitadoPorTiempo(string textoPlano)
		{
			string textoCifrado = protectorLimitadoPorTiempo.Protect(textoPlano, lifetime: TimeSpan.FromSeconds(30));
			return Ok(new { textoCifrado });
		}

		[HttpGet("desencriptar-limitado-por-tiempo")]
		public ActionResult DesencriptarLimitadoPorTiempo(string textoCifrado)
		{
			string textoPlano = protectorLimitadoPorTiempo.Unprotect(textoCifrado);
			return Ok(new { textoPlano });
		}
		
		-Se prueba en postman lo de los 30sg. Al de 30sg, el payload ha expirado.
	
	125. Ejemplo Práctico de encriptación limitada por tiempo - Links que expiran
		-Se da uso a encriptacion limitada por tiempo con un ejemplo.
		-Se tiene endpoints que estan protegidos.
		-Si se quiere dar acceso a  un endpoint a una persona por tiempo limuitado. Esto es generar un token que expira que es texto cifrado.
		 De esta manera, token valido solo por tiempo que se indique.
		 En vida real puedes querer compartir fichero o lo que sea y esa invitacion se quiere que expire en el tiempo. No se quiere que esa invitacion quede abierta
		 un año o dos en el futuro, que se robe la invitacion etc y peuda acceder a recurso protegido. Asi usando el cifrado por tiempo, 
         se restringe acceso a un recurso.
         Por que usar estas herramientas y no gaurdar en una bbdd el tiempo de vida de accesoa  un recurso?
         Si se hace con un token peus es que da mas escalabilidad.
         Asi no se depende de conexiona  bbd y nos los podemos ahorrar y nuestro sistema peude manejar mas cantidad de usuarios.
         Pues esa oepracion del cifrado limitado por tiempo es en memoria.
		
		-Se va a LibrosController que se tiene el authorize de la lista GET de libros y se quiere generar un link que sea accesible para unas personas durante un tiempo limitado.
		 Va a ser una hora, unos minutos, etc...
		-Se inyecta esto en la clase.
		private readonly ApplicationDbContext context;
		private readonly IMapper mapper;
		private readonly ITimeLimitedDataProtector protectorLimitadoPorTiempo;

		public LibrosController(ApplicationDbContext context, IMapper mapper, IDataProtectionProvider protectionProvider) {
			this.context = context;
			this.mapper = mapper;
			protectorLimitadoPorTiempo = protectionProvider.CreateProtector("LibrosController").ToTimeLimitedDataProtector();
		}
		
		-Se crea accion para obtener el token. se crea url para la ruta que permite pasar un token para obteenr listado de libros.
		[HttpGet("listado/obtener-token")]
		public ActionResult ObtenerTokeListado()
		{
			var textoPlano = Guid.NewGuid().ToString();
			var token = protectorLimitadoPorTiempo.Protect(textoPlano, lifetime: TimeSpan.FromSeconds(30));
			var url = Url.RouteUrl("ObtenerListadoLibrosUsandoToken", new { token }, "https");
			return Ok(new { url });
		}
		
		-Se crea otro metodo. Es igual que el otro GET solo que el viejo esta protegido y puede ser usado por admins y este nuevo 
		 puede ser usado por cualquier persona que tenga el token.
		 Si ya apsa el tiempo de expiracion daba error por lo que se mete el try-catch.
		 Lo que se quiere es generar un link por tiempo definido que ava  permitir a una eprsona acceder a un recurso protegido.
		 Se pone 30sg, ero en vida real es un dia, una semana, etc.
		 El token que se genera se lo podemos dar a una persona y peude usarlo por un tiempo limitado 
		 y cuando expire, pues expira..Como no se accede a la BBDD, pues esto es mas escalable y eficiente.
		[HttpGet("listado/{token}", Name = "ObtenerListadoLibrosUsandoToken")]
		[AllowAnonymous]
		public async Task<ActionResult> ObtenerListadoLibrosUsandoToken(string token)
		{
			try
			{
				protectorLimitadoPorTiempo.Unprotect(token);
			}
			catch
			{
				ModelState.AddModelError(nameof(token), "El token ha expirado");
				return ValidationProblem();
			}
			var libros = await context.Libros.ToListAsync();
			var librosDTO = mapper.Map<IEnumerable<LibroDTO>>(libros);
			return Ok(librosDTO);
		}
		
		-Se va a postman: GET http://localhost:5065/api/libros/listado/obtener-token => En el Auth bearer Token hay que meter el token de un admin.

	126. Llaves de proteccion de datos
		-Los algoritmos de encriptacion mas comunes usan una llave y los procesos dados por ASp.NET Core  no son excepcion.
		-Hasta ahora, nos hemos mantenido hablando del string de proposito. Sin embargo, es improtante notar que el framework va a manejar la llaves por ti.
		 a no ser que decidas sobreescribri ciertas configruaciones por defecto desde tiempod e vida de una llave hasta donde
         guardan las llaves sus configuraciones que podemos personalizar si lo queremos.
		-Si webAPI se coloca en un App Service de Azure, llaves se colocan por defecto en carpeta en els ervidor. 
		-Una consideracione s que los disitntos slots que son como diferentes versiones de la app, tienen llaves distintas. Si hay instancias diferentes
		 de una app en dos servidores diferentes, tienen llaves diferneets que peuden traer situacioens inesperadas como que 
		 lo que encriptas en un slot no peudas desencriptarlo en otro servidor. Es problematico a veces, sobre todo si manejas a manejar los slots 
		 de manera transparente para usuario.
		-Solucione s colcoar las llaves en un lugar externo como Azure Blob Storage 
		-Si app esta instalada en ISS las llaves seran persistidas en uns ervicio HKLM.
		-El framework verifica en donde se encuentra la app y trata de buscar mejor manera de guardar las llaves.
		-Es importante  que se entienda lo que el framework va a hacer con las llaves en acso de que se necesite sobreescribir el comportamiento por defecto para que se ajuste a nuestras necesidades.
		
	127. Entendiendo Hashing
		-Encrptar es codificar un mensaje de tal foma que perosnas autorizadas pudieran decodificar el mensaje haciendo uso se llave secreta.
		-Hay otor proceso de decodificacion por el cual a diferencia de la encriptacion no permite obtener el tetxo plano original.
		-A esto se le llama Hash.
		
		-Una funcion hash es un algoritmo el cual transforma un mensaje de tal manera que es virtualmente imposible de descifrar revirtiendo el proceso.
		-Al rdo de una funcion hash se le llama hash.
		-Un uso practico de una funcion hash es para laverificacion de una Password.
		-Cuando te registras en app web, sueles proveer un email y password y lo correcto desde punto de vista de seguridad informatic aesque pagina no guarde 
		 tetxo plano del password, sino un hasch, es decir, una fucnion hash al texto  plano y guarde rdo, de tal mdoo que sea virtualmente imposible descifrar el texto original.
		-Es importante porque password es info confidencial del user.
		-Sino se guarda password en texto plano sin hash resultante como se valida login de user?
		 Cuando user intente logearse, nos va a mandar un correo y password y se debe tomar ese password, aplciar funcion hash y comaprar el hash con el gaudrado en bbdd, asis e peude autenticar ausuario sin
		 necesidad de conocer texto plano correspondiente a su passwor.
		
		-Existen ciertas consideraciones a la hora de implementar funcionalidad con Hash.
		-Como uso de SAL. Una sal es un valor aleatorio que se anexa al texto plano al cual le queremos aplicar la funcion hash.
		-Esto protege nuestros datos de ciertos ataques de diccionario.
		-Estas consideraciones de seguridad estan fuera del alcance de este curso.
		-Queremso ver como tomar un string y aplicar funcion hash en ASP:NET Core.
		-Se usa impementacion del algoritmo Pbkdf2 que ofrece el framework.
		-Se sua sal aleatoria que permite que incluso hashes realizados al mismo texto plano, den rdos distitnos.
		 Si se va a usar ahshes para guardarlos en la bbdd, recuerda que sal tambien se guarda para hacer la validacion apropiada.
		-No hay inconveniente en guardar la sal en texto plano en bbdd porque la utilidad de la sal es hacer dificil 
		 los ataques de diccionario. sin embargo, es importante no eneseñar la sal a nadie y menos a ausuarios no autorizados.
	
	128. Hashes en ASP.NET Core
		-Se crea nuevo DTO.
		public class ResultadoHashDTO
		{
			public required string Hash { get; set; }
			public required byte[] Sal { get; set; }
		}
		
		-Vamos a Servicios e implementamos el algortimo.
		-10K itereacioens para que la funcion se ejecute 10K veces para tener hash mas dificl de romepr.
		-Se pasan 256 bits para definri tamaño de hash
		public class ServicioHash
		{
			public ResultadoHashDTO Hash(string input, byte[] sal)
			{
				string hashed = Convert.ToBase64String(KeyDerivation.Pbkdf2(
					password: input,
					salt: sal,
					prf: KeyDerivationPrf.HMACSHA1,
					iterationCount: 10_000,
					numBytesRequested: 256 / 8
					));

				return new ResultadoHashDTO
				{
					Hash = hashed,
					Sal = sal
				};
			}
		}
		
		-Se mete otra funcion para que no sea obligatorio tener que apsar siempre una sal y tener que inventarla, creo un metodo que nor eciba una sal.
		public ResultadoHashDTO Hash(string input)
		{
			var sal = new byte[16];
			using (var rng = RandomNumberGenerator.Create())
			{
				rng.GetBytes(sal);
			}
			return Hash(input, sal);
		}
		
		-Se extrae interfaz de la clase y se mete en un archivo con Ctrl + .
		
		-Se va a Program para añadir este servicio. Se pone Transient porque no comparto este estado.
		builder.Services.AddTransient<IServicioHash, ServicioHash>();
		
		-Se va a usar en SeguridadController. Se inyecta.
		private readonly IDataProtector protector;
		private readonly ITimeLimitedDataProtector protectorLimitadoPorTiempo;
		private readonly IServicioHash servicioHash;

		public SeguridadController(IDataProtectionProvider protectionProvider, IServicioHash servicioHash)
		{
			protector = protectionProvider.CreateProtector("");
			protectorLimitadoPorTiempo = protector.ToTimeLimitedDataProtector();
			this.servicioHash = servicioHash;
		}
		
		-Se mete accion. hash1 y hash2 son sales diferentes que se geenran aleatorias.
		-hash3 tiene la sal de hash2 para evr que asi se puede mandar la misma sal para generar el mismo hash y por tanto 
		 poderr ealziar comparacion de passwords.
		[HttpGet("hash")]
		public ActionResult Hash(string textoPlano)
		{
			var hash1 = servicioHash.Hash(textoPlano);
			var hash2 = servicioHash.Hash(textoPlano);
			var hash3 = servicioHash.Hash(textoPlano, hash2.Sal);
			var resultado = new { textoPlano, hash1, hash2, hash3 };
			return Ok(resultado);
		}
		
		-Se prueba en Postman: GET http://localhost:5065/api/seguridad/hash?textoplano=felipe
		 Entre hash1 y hash2 se tiene diferente sal y ahsh es disitnto a pesar de que
		 es mismo tetxco felipe. Esto evita ataque de diccioanrio que si alguien incluso sabiendo algortimo que uso,
		 no va a poder de forma rapida hacer ataque de fuerza bruta para saber a que texto plano le corresponde un hash.
		
		-En hash3, tenemos mismo hash.
		-En nuestro caso, Identity lo hace ya por nosotros. Si se va a usuarios, en  passwordHash,  lo hace...
		
	129. Resumen
		-Se aprendio aspectos de Segrudiad de ASP.NET Core.
		-Se ha vsito que con identity se peyden tener muchas de las caracteristicas de un sistema de usuarios de una manera sencilla.
		-JWT es un string qe nos permitem darle un token al usuario de forma que este peuda autenticarse una vez que nos de usuario y password.
		-Los claims son infos del usuario en loq ue se peude confiar.
		-CORS mecanismoq eue vita que desde navegadores web se puedan realziar epticiones HTTP a nuestro webAPI usando code de JS
		 desde lugares no autorizados.
		-Encriptacion permite cifrar texto de manera descifrable pro alguien que tenga llave secreta.
		-hashing  permite cifrar tetxo de forma que se indescifrable.
	

Sección 8: Escenarios Avanzados
	130. Introducción => No dice anda especial.
	131. Limpiar
		-Se borran fichero pero se ha hecho un commit de esto hasta ntes de la seccion 8.
		-Se va a limpiar la app.
		-Se borra: 
			-SeguridadController
			-ServicioHash
			-IServicioHash
			-LibrosController. Se borra el ejemplo de ITimeLimitedDataProetctor
			ANTES
			using AutoMapper;
			using BibliotecaAPI.Datos;
			using BibliotecaAPI.DTOs;
			using BibliotecaAPI.Entidades;
			using Microsoft.AspNetCore.Authorization;
			using Microsoft.AspNetCore.DataProtection;
			using Microsoft.AspNetCore.Mvc;
			using Microsoft.EntityFrameworkCore;

			namespace BibliotecaAPI.Controllers
			{
				[ApiController]
				[Route("api/libros")]
				[Authorize(Policy = "esadmin")]
				public class LibrosController : ControllerBase
				{
					private readonly ApplicationDbContext context;
					private readonly IMapper mapper;
					private readonly ITimeLimitedDataProtector protectorLimitadoPorTiempo;

					public LibrosController(ApplicationDbContext context, IMapper mapper, IDataProtectionProvider protectionProvider) {
						this.context = context;
						this.mapper = mapper;
						protectorLimitadoPorTiempo = protectionProvider.CreateProtector("LibrosController").ToTimeLimitedDataProtector();
					}

					[HttpGet("listado/obtener-token")]
					public ActionResult ObtenerTokenListado()
					{
						var textoPlano = Guid.NewGuid().ToString();
						var token = protectorLimitadoPorTiempo.Protect(textoPlano, lifetime: TimeSpan.FromSeconds(30));
						var url = Url.RouteUrl("ObtenerListadoLibrosUsandoToken", new { token }, "https");
						return Ok(new { url });
					}

					[HttpGet("listado/{token}", Name = "ObtenerListadoLibrosUsandoToken")]
					[AllowAnonymous]
					public async Task<ActionResult> ObtenerListadoLibrosUsandoToken(string token)
					{
						try
						{
							protectorLimitadoPorTiempo.Unprotect(token);
						}
						catch
						{
							ModelState.AddModelError(nameof(token), "El token ha expirado");
							return ValidationProblem();
						}
						var libros = await context.Libros.ToListAsync();
						var librosDTO = mapper.Map<IEnumerable<LibroDTO>>(libros);
						return Ok(librosDTO);
					}

					//Peticiones
					[HttpGet]
					public async Task<IEnumerable<LibroDTO>> Get()
					{
						var libros =  await context.Libros.ToListAsync();
						var librosDTO = mapper.Map<IEnumerable<LibroDTO>>(libros);
						return librosDTO;
					}


					[HttpGet("{id:int}", Name = "ObtenerLibro")] // /api/libros/1
					public async Task<ActionResult<LibroConAutoresDTO>> Get(int id)
					{
						var libro = await context.Libros
							.Include(x => x.Autores)
								.ThenInclude(x => x.Autor)
							.FirstOrDefaultAsync(x => x.Id == id);

						if (libro is null)
						{
							return NotFound();
						}

						var libroDTO = mapper.Map<LibroConAutoresDTO>(libro);

						return libroDTO;
					}


					[HttpPost]
					public async Task<ActionResult> Post(LibroCreacionDTO libroCreacionDTO)
					{
						if(libroCreacionDTO.AutoresIds is null || libroCreacionDTO.AutoresIds.Count == 0)
						{
							ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds),
								"No se puede crear un libro sin autores");
							return ValidationProblem();
						}

						var autoresIdsExisten = await context.Autores
												.Where(x => libroCreacionDTO.AutoresIds.Contains(x.Id))
												.Select(x => x.Id).ToListAsync();

						if (autoresIdsExisten.Count != libroCreacionDTO.AutoresIds.Count)
						{
							var autoresNoExisten = libroCreacionDTO.AutoresIds.Except(autoresIdsExisten); ;
							var autoresNoExistenString = string.Join(",", autoresNoExisten);
							var mensajeError = $"Los siguientes autores no existen: {autoresNoExistenString}";
							ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds), mensajeError);
							return ValidationProblem();
						}

						var libro = mapper.Map<Libro>(libroCreacionDTO);
						AsignarOrdenAutores(libro);

						context.Add(libro);
						await context.SaveChangesAsync();

						var libroDTO = mapper.Map<LibroDTO>(libro);

						return CreatedAtRoute("ObtenerLibro", new { id = libro.Id }, libroDTO);
					}

					private void AsignarOrdenAutores(Libro libro)
					{
						if (libro.Autores is not null)
						{
							for (int i = 0; i < libro.Autores.Count; i++) {
								libro.Autores[i].Orden = i;
							}
						}
					}


					[HttpPut("{id:int}")]
					public async Task<ActionResult> Put(int id, LibroCreacionDTO libroCreacionDTO)
					{
						if (libroCreacionDTO.AutoresIds is null || libroCreacionDTO.AutoresIds.Count == 0)
						{
							ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds),
								"No se puede crear un libro sin autores");
							return ValidationProblem();
						}

						var autoresIdsExisten = await context.Autores
												.Where(x => libroCreacionDTO.AutoresIds.Contains(x.Id))
												.Select(x => x.Id).ToListAsync();

						if (autoresIdsExisten.Count != libroCreacionDTO.AutoresIds.Count)
						{
							var autoresNoExisten = libroCreacionDTO.AutoresIds.Except(autoresIdsExisten); ;
							var autoresNoExistenString = string.Join(",", autoresNoExisten);
							var mensajeError = $"Los siguientes autores no existen: {autoresNoExistenString}";
							ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds), mensajeError);
							return ValidationProblem();
						}

						var libroDB = await context.Libros
									  .Include(x => x.Autores)
									  .FirstOrDefaultAsync(x => x.Id == id);

						if(libroDB is null)
						{
							return NotFound();
						}

						libroDB = mapper.Map(libroCreacionDTO, libroDB);
						AsignarOrdenAutores(libroDB);

						await context.SaveChangesAsync();
						return NoContent();
					}

					[HttpDelete("{id:int}")] // /api/libros/1
					public async Task<ActionResult> Delete(int id)
					{
						var registrosBorrados = await context.Libros.Where(libro => libro.Id == id).ExecuteDeleteAsync();

						if(registrosBorrados == 0)
						{
							return NotFound();
						}

						return NoContent();
					}

				}
			}
			
			DESPUES
			using AutoMapper;
			using BibliotecaAPI.Datos;
			using BibliotecaAPI.DTOs;
			using BibliotecaAPI.Entidades;
			using Microsoft.AspNetCore.Authorization;
			using Microsoft.AspNetCore.DataProtection;
			using Microsoft.AspNetCore.Mvc;
			using Microsoft.EntityFrameworkCore;

			namespace BibliotecaAPI.Controllers
			{
				[ApiController]
				[Route("api/libros")]
				[Authorize(Policy = "esadmin")]
				public class LibrosController : ControllerBase
				{
					private readonly ApplicationDbContext context;
					private readonly IMapper mapper;

					public LibrosController(ApplicationDbContext context, IMapper mapper) {
						this.context = context;
						this.mapper = mapper;
					}

					//Peticiones
					[HttpGet]
					public async Task<IEnumerable<LibroDTO>> Get()
					{
						var libros =  await context.Libros.ToListAsync();
						var librosDTO = mapper.Map<IEnumerable<LibroDTO>>(libros);
						return librosDTO;
					}


					[HttpGet("{id:int}", Name = "ObtenerLibro")] // /api/libros/1
					public async Task<ActionResult<LibroConAutoresDTO>> Get(int id)
					{
						var libro = await context.Libros
							.Include(x => x.Autores)
								.ThenInclude(x => x.Autor)
							.FirstOrDefaultAsync(x => x.Id == id);

						if (libro is null)
						{
							return NotFound();
						}

						var libroDTO = mapper.Map<LibroConAutoresDTO>(libro);

						return libroDTO;
					}


					[HttpPost]
					public async Task<ActionResult> Post(LibroCreacionDTO libroCreacionDTO)
					{
						if(libroCreacionDTO.AutoresIds is null || libroCreacionDTO.AutoresIds.Count == 0)
						{
							ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds),
								"No se puede crear un libro sin autores");
							return ValidationProblem();
						}

						var autoresIdsExisten = await context.Autores
												.Where(x => libroCreacionDTO.AutoresIds.Contains(x.Id))
												.Select(x => x.Id).ToListAsync();

						if (autoresIdsExisten.Count != libroCreacionDTO.AutoresIds.Count)
						{
							var autoresNoExisten = libroCreacionDTO.AutoresIds.Except(autoresIdsExisten); ;
							var autoresNoExistenString = string.Join(",", autoresNoExisten);
							var mensajeError = $"Los siguientes autores no existen: {autoresNoExistenString}";
							ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds), mensajeError);
							return ValidationProblem();
						}

						var libro = mapper.Map<Libro>(libroCreacionDTO);
						AsignarOrdenAutores(libro);

						context.Add(libro);
						await context.SaveChangesAsync();

						var libroDTO = mapper.Map<LibroDTO>(libro);

						return CreatedAtRoute("ObtenerLibro", new { id = libro.Id }, libroDTO);
					}

					private void AsignarOrdenAutores(Libro libro)
					{
						if (libro.Autores is not null)
						{
							for (int i = 0; i < libro.Autores.Count; i++) {
								libro.Autores[i].Orden = i;
							}
						}
					}


					[HttpPut("{id:int}")]
					public async Task<ActionResult> Put(int id, LibroCreacionDTO libroCreacionDTO)
					{
						if (libroCreacionDTO.AutoresIds is null || libroCreacionDTO.AutoresIds.Count == 0)
						{
							ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds),
								"No se puede crear un libro sin autores");
							return ValidationProblem();
						}

						var autoresIdsExisten = await context.Autores
												.Where(x => libroCreacionDTO.AutoresIds.Contains(x.Id))
												.Select(x => x.Id).ToListAsync();

						if (autoresIdsExisten.Count != libroCreacionDTO.AutoresIds.Count)
						{
							var autoresNoExisten = libroCreacionDTO.AutoresIds.Except(autoresIdsExisten); ;
							var autoresNoExistenString = string.Join(",", autoresNoExisten);
							var mensajeError = $"Los siguientes autores no existen: {autoresNoExistenString}";
							ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds), mensajeError);
							return ValidationProblem();
						}

						var libroDB = await context.Libros
									  .Include(x => x.Autores)
									  .FirstOrDefaultAsync(x => x.Id == id);

						if(libroDB is null)
						{
							return NotFound();
						}

						libroDB = mapper.Map(libroCreacionDTO, libroDB);
						AsignarOrdenAutores(libroDB);

						await context.SaveChangesAsync();
						return NoContent();
					}

					[HttpDelete("{id:int}")] // /api/libros/1
					public async Task<ActionResult> Delete(int id)
					{
						var registrosBorrados = await context.Libros.Where(libro => libro.Id == id).ExecuteDeleteAsync();

						if(registrosBorrados == 0)
						{
							return NotFound();
						}

						return NoContent();
					}

				}
			}
			
			-Se va a la clase Program.
				-Se quita:
				Middleware de prueba:
				app.Use(async (contexto, next) =>
				{
					contexto.Response.Headers.Append("mi-cabecera", "valor");
					await next();
				});
				
				Esto: builder.Services.AddTransient<IServicioHash, ServicioHash>();
				
			-Se va a AutroesController ys e mete AllowAnonymous a la peticion "ObtenerAutor"
			
			-En ComentariosController se mete en la epticion GET y en ObtenerComentario (una eprsona que no esta logeada, puede ver 1 comentario).
			-En LibrosController idem: GET y en ObteenrLibro.
			
	132. Instalando Swagger
		-Hasta ahora hemos usado navegador web o postman para interactuar con webAPI, pero unproblema de esto es que hay que conocer las rutas del webAPI.
		-Es mejor tener interfaz de usuario pro la cual podamos explorar nuestras rutas.
		-Para ello, la predilecta es Swagger.
		-Se va a paquetes Nugget y se instala Swagger con SwashBuckle.AspnetCore
		-Antes de hacer builder.Build() se configura.
		 El middleware de UseSwagger sirve para pder servir lo que se conoce como el documento de Swagger que es un JSOn
		 que contiene las distintas rutas del WebAPI. El SwaggerUI es para poder utilizar una interfaz de usuario para visualizar ese doc de Swagger
		 builder.Services.AddSwaggerGen();

		var app = builder.Build();

		// área de middlewares
		app.UseSwagger();
		app.UseSwaggerUI();
		
		-Se ejecuta app y se va a /swagger y se ven las distintas rutas.
		-Se invoca una accion.
		-Se peude buscar usuario por ID etc...
		-Si se usa mucho swagger y se quiere que cuando se abra la app se levante, pues se va a launchSettings y se añade esto:
		"https": {
		  "commandName": "Project",
		  "dotnetRunMessages": true,
		  "launchBrowser": true,
		  "launchUrl": "swagger",
		  //"applicationUrl": "https://localhost:7132;http://localhost:5065",
		  "applicationUrl": "https://localhost:7132",
		  "environmentVariables": {
			"ASPNETCORE_ENVIRONMENT": "Production",
			"quien_soy": "una variable de ambiente"
		  }
		}
		
	133. Agregando informaciones extras a Swagger
		-Existen modificaciones que podemos añadir a Swagger.
		-Se puede personalizar el titulo de BibliotecaAPI. Se consigue configurando las opciones de AddSwaggerGen.
		builder.Services.AddSwaggerGen(opciones =>
		{
			opciones.SwaggerDoc("v1", new Microsoft.OpenApi.Models.OpenApiInfo
			{
				Title = "Biblioteca API",
				Description = "Este es un web api para trabajar con datos de autores y libros",
				Contact = new Microsoft.OpenApi.Models.OpenApiContact
				{
					Email = "felipe@hotmail.com",
					Name = "Felipe Gavilán",
					Url = new Uri("https://gavilan.blog")
				},
				License = new Microsoft.OpenApi.Models.OpenApiLicense
				{
					Name = "MIT",
					Url = new Uri("https://opensource.org/license/mit/")
				}
			});
		});
		
	134. Agregando descripciones a las acciones
		-Se peude agregar info a las rutas o endpoints para indicar a usuario para que sirve, para que se utiliza, que es ese id....
		-Se va a AutoresController y se va a ObtenerAutor
		[HttpGet] // /api/autores/
		[AllowAnonymous]
		[EndpointSummary("Obtiene autor pod Id")]
		public async Task<IEnumerable<AutorDTO>> Get()
		{
			var autores = await context.Autores.ToListAsync();
			var autoresDTO = mapper.Map<IEnumerable<AutorDTO>>(autores);
			return autoresDTO;
		}
		
		-Se puede añadir descripcion en el mismo EndPoint: [EndpointDescription("Obtiene un autor por Id. Incluye sus libros. Si el autor no existe, se retorna 404.")]
		-Tambien descripcion del id....public async Task<ActionResult<AutorConLibrosDTO>> Get([Description("El id del autor")]int id)
		-Se puede indicar lo que va a retornar el metodo...
		[HttpGet("{id:int}", Name = "ObtenerAutor")] // api/autores/id
		[AllowAnonymous]
		[ProducesResponseType<AutorConLibrosDTO>(StatusCodes.Status200OK)]
		[ProducesResponseType(StatusCodes.Status404NotFound)]
		public async Task<ActionResult<AutorConLibrosDTO>> Get([Description("El id del autor")]int id)
		{
			var autor = await context.Autores
				.Include(x => x.Libros)
					.ThenInclude(x => x.Libro)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (autor is null)
			{
				return NotFound();
			}

			var autorDTO = mapper.Map<AutorConLibrosDTO>(autor);

			return autorDTO;

		}
		
	
	135. Swagger y JWT
		-Hasta ahora nos hemos mantenido usando peticiones GET.
		-No se ha probado por ejemplo la creacion de un autor sin libros.
		-Se obtiene un 401 al mandar esta peticion porque se tiene que ser administrador para pdoer usar el endpoint de POST /api/autores.
		{
		  "nombres": "Autor",
		  "apellidos": "De Swagger",
		  "identificacion": "123"
		}
		
		-Me da un error 401.
		-Para autenticarme como tal tengo que apsar un JSOn Web Token.
		-Como se pasa un JSON Web Token usando Swagger? Eso se configura con code en program.
		 El In es para mandarlo en una cabecera.
		 El AddSecurityRequirement es donde se indica que se va a usar la definicion de Seguridad en nuestro doc de Swagger para todos los endpoints.
		 Se añade esto en Program > builder.Services.AddSwaggerGen(opciones =>
		opciones.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
		{
			Name = "Authorization",
			Type = SecuritySchemeType.ApiKey,
			Scheme = "Bearer",
			BearerFormat = "JWT",
			In = ParameterLocation.Header
		});

		opciones.AddSecurityRequirement(new OpenApiSecurityRequirement
		{
			{
				new OpenApiSecurityScheme
				{
					Reference = new OpenApiReference
					{
						Type = ReferenceType.SecurityScheme,
						Id = "Bearer"
					}
				},
				new string[]{ }
			}
		});
		
		-Ahora aparece el Authorization. Se hace login y se mete el JWT en la peticion...
		-Se va a Authorize y se mete Bearer + " " + Token....
		-Se va a POST /api/autores para probar....
		
		
		
		
	136. Personalizando los endpoints en los que Swagger usa JWT - IParameterFilter
		-Se puede meter un candando en las peticiones HTTP para indicar que en el endpoint se peude mandar el JWT  .
		-El candado se ha metido en todos los endpoints, incluso en esos donde no se necesita.
		-Que ams da que se mande que no? Pues eso puede afectar a ciertas funcionalidades que dependen de que no estemos autenticados, por ejemplo, 
		 el caché.
		 Se peude tener una capa de caché que nos permite no estar consultando siempre la BBDD ante datos que no cambian mucho.
		-Cuando se manda un JWT el cache no funciona, por que? porque se entiende que una persona manda JWT es porque posiblemente hay dtaos personales.
		 Es como que estas en una red social y hay un endpoint que sea como mis amigos o mis seguidores....No es lo mismo los seguidores de Roberto que de Claudia....
		-Por defecto, cuando tenemos un endpoint, el cual, tiene una capa de cache, hay una excepcion de que no se va a usar la capa de cache sis e envia un JWT. 
		 No sea que vaya a ser data que le pertenece a ese usuario.
		 Hay que ser cuidadosos a la hora de mandar o no un JWT.
		 Se va a colcoar el candado solo en la rutas en la sque se enecesite un JWT para acceder a estas.
		-Se mete nueva carpeta que sea Swagger en el proyecto...Y se crea clase FiltroAutorizacion
		 IOperationFilter me permite modificar la MetaData de cada una de las rutas que se muestran en Swagger.
		 Aqui se ve basicamente la descripcion de la accion y estoy verificando si tiene un Authorize en el Attribute de la peticion del controlador. Sino lo tiene, 
		 entonces se retorna porque noe sta protegido....
		 Del mismo modo, se va a ver que si existe un AllowAnonymousAttribute entonces return....
		 Ahora se mete el SecurityRequiremnt, es decir lo que se modifico en un video atras...Se copia todo....
		 public class FiltroAutorizacion : IOperationFilter
		{
			public void Apply(OpenApiOperation operation, OperationFilterContext context)
			{
				if (!context.ApiDescription.ActionDescriptor.EndpointMetadata.OfType<AuthorizeAttribute>().Any())
				{
					return;
				}

				if (context.ApiDescription.ActionDescriptor.EndpointMetadata.OfType<AuthorizeAttribute>().Any())
				{
					return;
				}

				operation.Security = new List<OpenApiSecurityRequirement>
				{
					new OpenApiSecurityRequirement
					{
							{
								new OpenApiSecurityScheme
								{
									Reference = new OpenApiReference
									{
										Type = ReferenceType.SecurityScheme,
										Id = "Bearer"
									}
								},
								new string[]{ }
							}
					}
				};
			}
		}
		
		-Con el FiltroAutorizacion se le dice que se le va a poenr ese candado a las distintas rutas,
		 siempre y cuando esas rutas tengan un AuthorizeAttribute y no tenga AllowAnonymous.
		 Se comenta lo de OpenSecurityRequirement de la parte de program.
		 Se mete esto: opciones.OperationFilter<FiltroAutorizacion>();
	
	137. Paginación
		-Imagina que tenemos una accion que devuelve un listadod e autores y que devuelve miles de auotres, 
		 pues noseria conveniente mostrar a usuarios miles de autores porque esa info abruma....
		 Eso peude ralentizar WebAPI. Lo que se hace es apginar que es dvidir la info en segmentos.
		 Por ejemplo de 10 en 10, de 20 en 20....
		-Se crea DTO que ava  representar tanto una pagina como la cantidad de registros por pagina: PaginacionDTO. 
		-No tiene porque ser una clase. Puede ser un record porque de forma sencilla va a ser inmutable, es decir, que no se ava  poder cambiar una vez instanciado.
		 Se mete la cantidad amxima de records por pagina. Aqui si se quiere mostrar mas de 50 regs opor pagina, pues no se permite.
		 Ese init es para que no se peuda modificar una vez inicialziado.
		 Math.Max(1, pagina) es porque quizas por error el cliente me mande ir a la pagina -1 y eso no lo permita y uestre la pagina 1.
		 pero, si quiere ir a la 5, que se la de. Math.Max, devuelve el valor maximo de los dos...
		 Lo del clamp es que se quiere que RecordsPorPagina sea valor entre 1 y un maximo. Esto es que se le pasa un valor por ejemplo 10 y te dice esta 10 entre 1 y CantidadmaximaPorPagina? Si
		 Pues entonces el valor de eso es 10. Si es -1, se devuelve 1 y si el valor es mayor a 50 en este caso, pues se retorna CantidadMaximaRecordsPorPagina.
		public record PaginacionDTO(int Pagina = 1, int RecordsPorPagina = 10)
		{
			private const int CantidadMaximaRecordPorPagina = 50;

			public int Pagina { get; init; } = Math.Max(1, Pagina);
			public int RecordsPorPagina { get; init; } =
				Math.Clamp(RecordsPorPagina, 1, CantidadMaximaRecordPorPagina);
		}
		
		-Se va a AutoresController y en el GET para obtenerr los datos se mete el fromQuery para ser explicitos y que se necesita los datos de QueryStrings.
		
		-Para poder pagina necesito obtener la cantidad total de auotres porque para decirle al cliente cuantos registros hay 
		 para que peuda calcualr cuantas paginas hay para mostrarle al usuario. Asi el ciente peude renderizar pag 1, 2....
		 Esto de la paginacione s algo que se quiere usar para otros recursos por lo que se va a centralizar esta oeprac ion.
		[HttpGet] // /api/autores/
		[AllowAnonymous]

		public async Task<IEnumerable<AutorDTO>> Get([FromQuery] PaginacionDTO paginacionDTO)
		{
			var autores = await context.Autores.ToListAsync();
			var autoresDTO = mapper.Map<IEnumerable<AutorDTO>>(autores);
			return autoresDTO;
		}
		
		-Se va a Utilidades y se añade HttpContentExtensions Eso de que hay 100 registros o lo que sea se coloca en la cabecera 
		 de al respuesta HTTP porque la cantidad de autores no es un autor en si o algo que se muestre en el cueropo, sino que 
		 se pidio el listado de autores ye sto es MetaData y eso va a en la cabecera de la respuesta y por eso se coloca un metodo de extension
		 sobre la clase HttpContext
		 Se mete static para que se pueda meter un metodo de extension.
		 Va a ser generico el InsertarParametrisPaginacionEnCabecera proque se va a poder usar con Autores, Libros....
		 IQueryable es una representacion de un objeto al cual le podemos hacer un query.
		 La T es lo que peude ser Auotrs, Libros...
		 Se va a obtener la cantidfad de regs de la tabla.
		 Ahora se mete a cabecera..
		public static class HttpContextExtensions
		{
			public async static Task InsertarParametrosPaginacionEnCabecera<T>(this HttpContext httpContext, IQueryable<T> queryable)
			{
				if(httpContext is null)
				{
					throw new ArgumentNullException(nameof(httpContext));
				}

				double cantidad = await queryable.CountAsync();
				httpContext.Response.Headers.Append("cantidad-total-registros", cantidad.ToString());
			}
		}
		
		-Para que cantidad-total-registros quede expuesto ante un cliente que ejecuta un navegador, se va a program y se busca configuraciond e CORS y se cambia "mi-cabecera" por "cantidad-total-registros".
		opciones.AddDefaultPolicy(opcionesCORS =>
		{
			opcionesCORS.WithOrigins(origenesPermitidos).AllowAnyMethod().AllowAnyHeader()
			.WithExposedHeaders("cantidad-total-registros");
		});
		
		-Se va de nuevo a AutoresController.
		 Se cambiapeticion GET.
		 Queryable permite ir parte por parte construyendo el query...
		 Queryable es una representacion de la tabla de Autores pero en memoria.
		 No tiene regs pero permite armar query parte por parte...
		 Asi, se pasa la representacion de la tabla de Autores.
		[HttpGet] // /api/autores/
		[AllowAnonymous]

		public async Task<IEnumerable<AutorDTO>> Get([FromQuery] PaginacionDTO paginacionDTO)
		{
			var queryable = context.Autores.AsQueryable();
			await HttpContext.InsertarParametrosPaginacionEnCabecera(queryable);
			var autores = await queryable.ToListAsync();
			var autoresDTO = mapper.Map<IEnumerable<AutorDTO>>(autores);
			return autoresDTO;
		}
		
		-Se ve que en la respuesta, en response headers me pone el total de regs...
		-La paginacion se va a utilzar en otros lados y se mete a otra clase...: IQueryableExtensions
		 La funcion Skip permite saltarme un cjto de regs.
		 Podemos decir, quiero los regs de la pagina 1 y quiero primeros 10 o me salto primeros diez y cojo los siguientes 10...
		 (1-1) * .....0...En la pagina 1 te saltas 0 regs y asi...
		Take cogeria por ejemplo los siguientes 10 o 20....En funcion de lo de RecordPorpagina.
		
		
		-Como se hizo un metodo de extension a IQueryable, 
		public static class IQueryableExtensions
		{
			public static IQueryable<T> Paginar<T>(this IQueryable<T> queryable, PaginacionDTO paginacionDTO)
			{
				return queryable
					.Skip((paginacionDTO.Pagina - 1) * paginacionDTO.RecordsPorPagina)
					.Take(paginacionDTO.RecordsPorPagina);
			}
		}
		
		-Se va a AutoresController para agregar la paginacion al emtodo. Se mete OrderBy primero para poder meter Take y Skip.
		[HttpGet] // /api/autores/
		[AllowAnonymous]
		public async Task<IEnumerable<AutorDTO>> Get([FromQuery] PaginacionDTO paginacionDTO)
		{
			var queryable = context.Autores.AsQueryable();
			await HttpContext.InsertarParametrosPaginacionEnCabecera(queryable);
			var autores = await queryable
				.OrderBy(x => x.Nombres)
				.Paginar(paginacionDTO).ToListAsync();
			var autoresDTO = mapper.Map<IEnumerable<AutorDTO>>(autores);
			return autoresDTO;
		}
		
		-Se prueba pagina y records por pagina...
		
	
	138. Paginación en Libros
		-Se hace algo parecido en el GET de LibrosController.
		//Peticiones
		[HttpGet]
		[AllowAnonymous]
		public async Task<IEnumerable<LibroDTO>> Get([FromQuery] PaginacionDTO paginacionDTO)
		{
			var queryable =  context.Libros.AsQueryable();
			await HttpContext.InsertarParametrosPaginacionEnCabecera(queryable);
			var libros = await queryable
				.OrderBy(x => x.Titulo)
				.Paginar(paginacionDTO).ToListAsync();
			var librosDTO = mapper.Map<IEnumerable<LibroDTO>>(libros);
			return librosDTO;
		}
		
		-Se mira rdo en Swagger.
	
	139. Preparando el terreno para guardar imágenes
		-Se va a aprender a recibir ficheros en nuestro WebAPI. Podemos querer recibir PDFs, Excel, imagenes, videos de nuestros clientes.
		-En nuestro caso, queremos poder recibir imagenes proque queremos pdoer gardar la foto de un Autor.
		-Esta la opcion de guardar en Azure y localmente.
		-En Azure hay un servicio para poder guardar archivos.
		-En ambos casos, lo que se guarda en BBDD es la URL de la imagen del Autor.
		-Se va a la Entidad del Autor porque lo que se quiere colocar el campo que lo que va a tener es la foto del Autor o URL de la foto.
		-Se mete nullable por no ser obligatorio.
		-Se mete lo del Unicode porque como se va a meter una URL hay que contemplar que no se va a admitir cualquier caracter Unicode(false).
		 Así, se es mas eficiente con la info que vamos a guardar en este campo porque se usa varchar y no nvarchar.
		 [Unicode(false)]
		 public string? Foto { get; set; }
		 
		-Se le da a Add-Migration AutorFoto.
		
		-Se va a AutorDTO y se coloca esto:public string? Foto { get; set; }
		-Se crea AutorCreacionDTO con foto esto para no afectar la funcionalidad actual que tenemos para poder gaurdar multiples autores de una tirada.
		-Se mete DTO especial para meter un autor cxon su foto.
		-Se hereda de AutorCreacionDTO para hacer uso de toda la funcionalidad que tiene.
		-Se usa IFormFile para representar archivos.
		public class AutorCreacionConFotoDTO: AutorCreacionDTO
		{
			public IFormFile? Foto { get; set; }
		}
		
		-Se crea un nuevo mapeo porque no se quiere mapear entre la foto y la foto de autor que es un string.
		-Se ignora la foto porque en un sitio es un string y en el otro un FormFile.
		CreateMap<AutorCreacionConFotoDTO, Autor>()
			.ForMember(ent => ent.Foto, config => config.Ignore());
		
		-Ahora se va con parte funcional. Se necesita un servicio para guardar archivos.
		-En Servicios se agrega una interfaz.
		-Se mete el Task de Borrar para que se peuda borrar la imagen cuando por ejemplo se borra un Autor.
		-ruta es la URL de la imagen y contenedor es una carpeta en la que se guardan las imagenes. Se pueden tener multiples carpetas para multiples archivos.
		-Puede haber una carpeta para fotos de los Autores, otra carpeta para portadas de Libros, etc.
		-Almacenar devuelve un string porque guarda la ruta de una imagen. Sirve idem para pdf, excel, etc...
		-Tambien habra un metodo de editar para borrar la imagen anterior y se guarda una nueva.
		-Cambiar una foto por otra. Algo que se puede hacer con las interfaces es tener implementacion por defecto.
		-En Editar, ruta va con nullable porque Foto no es requerido. Se ve que se borra la imagen anterior y se almacena una nueva.
		public interface IAlmacenadorArchivos
		{
			Task Borrar(string? ruta, string contenedor);
			Task<string> Almacenar(string contenedor, IFormFile archivo);
			async Task<string> Editar(string? ruta, string contenedor, IFormFile archivo)
			{
				await Borrar(ruta, contenedor);
				return await Almacenar(contenedor, archivo);
			}
		}
		
		-Se va a AutoresController. Se crea un const: private const string contenedor = "autores";
		-Se inyecta el IAlmacenadorArchivos.
		-Se clona el HTTPOst y se mete FromForm que se usa cuando se obtiene data de formulario y es util
		 cuando se reciben ficheros.
		[HttpPost("con-foto")]
		public async Task<ActionResult> PostConFoto([FromForm] AutorCreacionConFotoDTO autorCreacionDTO)
		{
			var autor = mapper.Map<Autor>(autorCreacionDTO);

			if (autorCreacionDTO.Foto is not null)
			{
				var url = await almacenadorArchivos.Almacenar(contenedor, autorCreacionDTO.Foto);
				autor.Foto = url;
			}

			context.Add(autor);
			await context.SaveChangesAsync();
			var autorDTO = mapper.Map<AutorDTO>(autor);
			return CreatedAtRoute("ObtenerAutor", new { id = autor.Id }, autorDTO);
		} 
		
		-En el put se va a validar que exista el Autor.
		[HttpPut("{id:int}")] // api/autores/1 
		public async Task<ActionResult> Put(int id, AutorCreacionDTO autorCreacionDTO)
		{
			var existeAutor = await context.Autores.AnyAsync(x => x.Id == id);

			if (!existeAutor)
			{
				return NotFound();
			}

			var autor = mapper.Map<Autor>(autorCreacionDTO);
			autor.Id = id;
			context.Update(autor);
			await context.SaveChangesAsync();
			return NoContent();

		}
		
		-Se deja asi.
		HttpPut("{id:int}")] // api/autores/1 
        public async Task<ActionResult> Put(int id, AutorCreacionConFotoDTO autorCreacionDTO)
        {
            var existeAutor = await context.Autores.AnyAsync(x => x.Id == id);

            if (!existeAutor)
            {
                return NotFound();
            }

            var autor = mapper.Map<Autor>(autorCreacionDTO);
            autor.Id = id;

            if (autorCreacionDTO.Foto is not null)
            {
                var fotoActual = await context
                                .Autores.Where(x => x.Id == id)
                                .Select(x => x.Foto).FirstAsync();
                var url = await almacenadorArchivos.Editar(fotoActual, contenedor, autorCreacionDTO.Foto);
                autor.Foto = url;
            }

            context.Update(autor);
            await context.SaveChangesAsync();
            return NoContent();

        }
		
		-Se va al metodo de bortrar y tal como se tiene no me conviene porque se necesita obtener la data de la Foto, 
		Antes
		[HttpDelete("{id:int}")] // api/autores/1 
		public async Task<ActionResult> Delete(int id)
		{
			var registrosBorrados = await context.Autores.Where(x => x.Id == id).ExecuteDeleteAsync();

			if (registrosBorrados == 0)
			{
				return NotFound();
			}

			return NoContent();

		}
		
		DESPUES
		[HttpDelete("{id:int}")] // api/autores/1 
		public async Task<ActionResult> Delete(int id)
		{
			var autor = await context.Autores.FirstOrDefaultAsync(x => x.Id == id);

			if (autor is null)
			{
				return NotFound();
			}

			context.Remove(autor);
			await context.SaveChangesAsync();
			await almacenadorArchivos.Borrar(autor.Foto, contenedor);

			return NoContent();

		}
		
		-En el put se tiene que colocar la imagen: public async Task<ActionResult> Put(int id, [FromForm] AutorCreacionConFotoDTO autorCreacionDTO)
		
		-Se van a tener dos implementaciones para poder guardar archivos.
	
	140. Salvando Imágenes en Azure
		-Se va a Azure Storage Account que es un servicio que sirve para almacenar archivos. Se busca Storage Accounts 
		-Se crea un o nuevo y se selecciona un Resource Group.
		-Esto se refeire a una coleccion de recursos que sirve para poder agrupar soluciones relacionadas.
		-Por ejemplo para nuetsro WebAPI vamos a tener Azure App Service, BBDD de SQl, un servidor de BBDD, Azure Storage Account...
		 La idea es que como todo esto se relaciona a nuestro proyecto de BibliotecaAPi, lo vamos a tener en un grupo que lo podemos ver 
		 como una caroeta en la que colocamos todo lo relacionadoa  nuestro proeycto de BiliotecaAPi.
		-Se le da a Crear Cuenta de Almacenamiento > Nuevo grupo de recursos > biblioteca-api.
		-Nombre de cuenta: bibliotecaapiudemy
		-Servicio Principal: Azure Blob Storage para guardar difernetes tipo de archivos.
		-Ahora se va a Advanced y se chequea Permitir el acceso anónimo en contenedores individuales
		-Es para poder conectarnos desde nuestro WebAPI hacia Azure Storage Account.
		-Se le da a crear.
		
		-Se va a un paquete nugget y se crea el Azure Storage Blobs.
		-Se instala y se la da a ir al recurso.
		-Se busca llave que esta la llave que me va a permitir conectar desde WebAPI a Azure Storage.
		-Se va a la key1 > Cadena de conexión y se copia.
		-Se va al appsettings.development.json y se mete el AzureStorageConnection.
		
		-Se implementa una clase que permite guardar archivos en Azure.
		-Se va a Servicios: 
		public class AlmacenadorArchivosAzure : IAlmacenadorArchivos
		{
			private readonly string connectionString;

			public AlmacenadorArchivosAzure(IConfiguration configuration)
			{
				connectionString = configuration.GetConnectionString("AzureStorageConnection")!;
			}
			public async Task<string> Almacenar(string contenedor, IFormFile archivo)
			{
				var cliente = new BlobContainerClient(connectionString, contenedor);
				await cliente.CreateIfNotExistsAsync();
				cliente.SetAccessPolicy(PublicAccessType.Blob);

				var extension = Path.GetExtension(archivo.Name);
				var nombreArchivo = $"{Guid.NewGuid()}{extension}";
				var blob = cliente.GetBlobClient(nombreArchivo);
				var blobHttpHeaders = new BlobHttpHeaders();
				blobHttpHeaders.ContentType = archivo.ContentType;
				await blob.UploadAsync(archivo.OpenReadStream(), blobHttpHeaders);
				return blob.Uri.ToString();
			}

			public async Task Borrar(string? ruta, string contenedor)
			{
			   if (string.IsNullOrEmpty(ruta))
			   {
					return;
			   }

				var cliente = new BlobContainerClient(connectionString, contenedor);
				await cliente.CreateIfNotExistsAsync();
				var nombreArchivo = Path.GetFileName(ruta);
				var blob = cliente.GetBlobClient(nombreArchivo);
				await blob.DeleteIfExistsAsync();
			}
		}
		
		-Se va a program y se coloca el servicio. Transient porque no se necesita manejar estado: builder.Services.AddTransient<IAlmacenadorArchivos, AlmacenadorArchivosAzure>();
		
		-Ya se puede probar.
		-Se levanta la app y se va a Swagger con el token de autenticacion, al endpoint con-foto para poder
		 subir un autor con foto.
		-Funciona bien el endpoint porque he quitado el Authorized en AutoresController pero me pone Unauthorized....Hay que ver el error en el endpoint para un usuario que es admin..
		-No funcionaba porque hay que meterle Bearer en el authorize.
		-En la respuesta, se tiene la URL donde se ha subido la foto a Azure.
		-Si se accede a Storage Browser se puede ver el archivo por ahí > Contenedor de blobs > autores
		-Ahora se ve ahi la imagen del autor. Imaginemos que nos hemos equivocado con la imagen y se quiere cambiar.
		-Se va al PUT y se modifica para el ID del autor creado la imagen y si se va a la vieja URl ya nos dice que el fichero no existe.
		-Y se le puede dar tambien a Obtener el autor por el Id.
		-Ahora hay que probar que al borrar el autor, se borra la magen tambien.
	
	141. Salvando imágenes localmente
		-Se va a implementar el servicio de almacenar ficheros localmente.
		-Dentro de Servicios, nueva clase. IWebHostEnvironment permite acceder a una carpeta que tenemos en el servidor para guardar las imagenes.
		-IHttpContextAccesor para acceder al contexto HTTP.
		-Se inventa el nombre del archivo con Guid para que no haya problema de colisiones.
		public async Task<string> Almacenar(string contenedor, IFormFile archivo)
		{
			var extension = Path.GetExtension(archivo.FileName);
			var nombreArchivo = $"{Guid.NewGuid}{extension}";
			string folder = Path.Combine(env.WebRootPath, contenedor);

			if (!Directory.Exists(folder))
			{
				Directory.CreateDirectory(folder);
			}

			string ruta = Path.Combine(folder, nombreArchivo);
			using (var ms = new MemoryStream())
			{
				await archivo.CopyToAsync(ms);
				var contenido = ms.ToArray();
				await File.WriteAllBytesAsync(ruta, contenido);
			}

			var request = httpContextAccessor.HttpContext!.Request;
			var url = $"{request.Scheme}://{request.Host}";
			var urlArchivo = Path.Combine(url, contenedor, nombreArchivo).Replace("\\", "/");

			return urlArchivo;
		}
		
		-El de borrado.
		public Task Borrar(string? ruta, string contenedor)
		{
			if (string.IsNullOrEmpty(ruta))
			{
				return Task.CompletedTask;
			}

			var nombreArchivo = Path.GetFileName(ruta);
			var directorioArchivo = Path.Combine(env.WebRootPath, contenedor, nombreArchivo);

			if (File.Exists(directorioArchivo))
			{
				File.Delete(directorioArchivo);
			}

			return Task.CompletedTask;
		}
		
		-Se va a ir a la clase de Program y tenemos puesto que hemos suado els ervicio de Azure pero la comentamos y metemos esto:
		builder.Services.AddTransient<IAlmacenadorArchivos, AlmacenadorArchivosLocal>();
		
		-Importante que esté esto en program: builder.Services.AddHttpContextAccessor(); Es para poder usarlo en AlmacenadorArchivosLocal
		-Se usa el WebRootPath que se corresponde con un directorio especial en un proyecto de ASPnetCore que se llama wwwroot que es donde se colocan los archivos estáticos.
		 como imagenes, pdfs etc.
		-Se crea fichero wwwroot.
		-se necesita indicar que yo quiero servir archivos estáticos de este WebAPI.
		-se mete en program esta linea: app.UseStaticFiles();
		
		-Se ejecuta la app y se va a la ruta con-foto para meter una imagen a un actor...Si se va al proyecto, se ve que la imagen se ha creado en wwwroot > autores.
		-Se ve que se está colocando localmente.
		-Se prueba el PUT, cambiando una imagen por otra.
		-Y se prueba el DELETE.
	
	142. Filtros Dinámicos con EF Core
		-Se continúa aprendiendo de ejecucion diferida en EF Core.
		-Se peude usar IQueryable para colcoar en una variable una representacion de lo que sera eñ query que se va a relaizar.
		-Esto permite dividr el query en varias linea.
		-Esto se presta a que pdoamso ser creativos.
		-Podemos asi implementar filtros dinámicos de esta forma.
		-Se peude tener una condicion IF no se que y solo modificar el queryable si una condicion es verdadera. Asi se tiene un filtro dinamico que se da en ocasiones y no siempre.
		-Se va a meter filtro dinamico para Autores. Se quiere filtrar por nombre de autor, apellido, si tiene loibros....De forma dinamico...
		 Si a la accion le mando nombre, filtra por nombre, sino se lo mando, pues no por nombre de Autor.
		-Se crea AutorFiltroDTO que es contiene los datos por los que se va a filtrar.
		-Esto es mejor para recibir la data por un queryString.
		-Lo del nullable por Nombres es por si se quiere filtrar por nombres.
		-DTO
		public class AutorFiltroDTO
		{
			public int Pagina { get; set; } = 1;
			public int RecordsPorPagina { get; set; } = 10;
			public PaginacionDTO PaginacionDTO {
				get
				{
					return new PaginacionDTO(Pagina, RecordsPorPagina);
				}
			}

			public string? Nombres { get; set; }
			public string?  Apellidos { get; set; }
			public bool? TieneFoto { get; set; }
			public bool? TieneLibros { get; set; }
			public string? TituloLibro { get; set; }
			public bool IncluirLibros { get; set; }
			public string? CampoOrdenar { get; set; }
			public bool ordenAscendente { get; set; } = true;
		}
		
		-Se mete un nuevo endpoint en AutoresController. Se le llama ejecucion diferida porque se arma el query y al final se ejecuta.
		-Se prueba el endpoint para listar todos los autores y se busca por C.
		-se busca por felipe.
		-Ahora se quiere permitir indicar al cliente si quiere que salgan los libros de los autores.
		[HttpGet("filtrar")]
		[AllowAnonymous]
		public async Task<ActionResult> Filtrar([FromQuery] AutorFiltroDTO autorFiltroDTO)
		{
			var queryable = context.Autores.AsQueryable();

			if (!string.IsNullOrEmpty(autorFiltroDTO.Nombres))
			{
				queryable = queryable.Where(x => x.Nombres.Contains(autorFiltroDTO.Nombres));
			}

			if (!string.IsNullOrEmpty(autorFiltroDTO.Apellidos))
			{
				queryable = queryable.Where(x => x.Apellidos.Contains(autorFiltroDTO.Apellidos));
			}

			var autores = await queryable
					.OrderBy(x => x.Nombres)
					.Paginar(autorFiltroDTO.PaginacionDTO).ToListAsync();

			if (autorFiltroDTO.IncluirLibros)
			{
				var autoresDTO = mapper.Map<IEnumerable<AutorConLibrosDTO>>(autores);
				return Ok(autoresDTO);
			}
			else
			{
				var autoresDTO = mapper.Map<IEnumerable<AutorDTO>>(autores);
				return Ok(autoresDTO);
			}
			
		}
		
		-Se va al endpoint se le da Desde Swagger a true a lo de incluirLibros y en la respuesta se ve que se incluyen los autores con sus libros.
		-Se va a preguntar tambien si el autor tiene foto.
		if (autorFiltroDTO.TieneFoto.HasValue)
		{
			if (autorFiltroDTO.TieneFoto.Value)
			{
				queryable = queryable.Where(x => x.Foto != null);
			}
			else
			{
				queryable = queryable.Where(x => x.Foto == null);
			}
		}
		
		-Ahora se va a mirar si TieneLibros y para eso se usa otra tabla y se va a usar para ello la propeidad de navegacion.
		if (autorFiltroDTO.TieneLibros.HasValue)
		{
			if (autorFiltroDTO.TieneLibros.Value)
			{
				queryable = queryable.Where(x => x.Libros.Any());
			}
			else
			{
				queryable = queryable.Where(x => !x.Libros.Any());
			}
		}
		
		-Se va a filtrar info relacionada al libro. Por ejemplo, se quieren autores que tengan un libro de C#.
		if (!string.IsNullOrEmpty(autorFiltroDTO.TituloLibro))
		{
			queryable = queryable.Where(x =>
				x.Libros.Any(y => y.Libro!.Titulo.Contains(autorFiltroDTO.TituloLibro)));
		}
		
	143. Orden dinámico
		-Nos falta ordenar los rdos por campo especifico y es normal en apps de tiendas que ordenas productos por fecha, precio....
		-En nuestro caso se quiero permitir organizar los rdos de autores por nombre o apellido.
		-Se peude solucionar con un if pero se quiere poder usar libreria que se puede pasar un string al OrderBy.
		-Se instala nueva libreria System.Linq.Dynamic.Core
		-En AutoresController se inyecta el ILogger.
		private readonly ApplicationDbContext context;
		private readonly IMapper mapper;
		private readonly IAlmacenadorArchivos almacenadorArchivos;
		private readonly ILogger<AutoresController> logger;
		private const string contenedor = "autores";

		public AutoresController(ApplicationDbContext context, IMapper mapper, IAlmacenadorArchivos almacenadorArchivos, ILogger<AutoresController> logger)
		{
			this.context = context;
			this.mapper = mapper;
			this.almacenadorArchivos = almacenadorArchivos;
			this.logger = logger;
		}
		
		-Si por si acaso esa libreria arroja un error, quiero guardarla usando el logger. La libreria puede arrojar un error en caso de que pasemos campo que no existe.
		-Es necesario importar System.Linq.Dynamic.Core-
		-Se va al endpoint de filtrar.
		ANTES
		[HttpGet("filtrar")]
		[AllowAnonymous]
		public async Task<ActionResult> Filtrar([FromQuery] AutorFiltroDTO autorFiltroDTO)
		{
			var queryable = context.Autores.AsQueryable();

			if (!string.IsNullOrEmpty(autorFiltroDTO.Nombres))
			{
				queryable = queryable.Where(x => x.Nombres.Contains(autorFiltroDTO.Nombres));
			}

			if (!string.IsNullOrEmpty(autorFiltroDTO.Apellidos))
			{
				queryable = queryable.Where(x => x.Apellidos.Contains(autorFiltroDTO.Apellidos));
			}

			if (autorFiltroDTO.IncluirLibros)
			{
				queryable = queryable
					.Include(x => x.Libros)
					.ThenInclude(x => x.Libro);
			}

			if (autorFiltroDTO.TieneFoto.HasValue)
			{
				if (autorFiltroDTO.TieneFoto.Value)
				{
					queryable = queryable.Where(x => x.Foto != null);
				}
				else
				{
					queryable = queryable.Where(x => x.Foto == null);
				}
			}

			if (autorFiltroDTO.TieneLibros.HasValue)
			{
				if (autorFiltroDTO.TieneLibros.Value)
				{
					queryable = queryable.Where(x => x.Libros.Any());
				}
				else
				{
					queryable = queryable.Where(x => !x.Libros.Any());
				}
			}

			if (!string.IsNullOrEmpty(autorFiltroDTO.TituloLibro))
			{
				queryable = queryable.Where(x =>
					x.Libros.Any(y => y.Libro!.Titulo.Contains(autorFiltroDTO.TituloLibro)));
			}

			var autores = await queryable
					.OrderBy(x => x.Nombres)
					.Paginar(autorFiltroDTO.PaginacionDTO).ToListAsync();

			if (autorFiltroDTO.IncluirLibros)
			{
				var autoresDTO = mapper.Map<IEnumerable<AutorConLibrosDTO>>(autores);
				return Ok(autoresDTO);
			}
			else
			{
				var autoresDTO = mapper.Map<IEnumerable<AutorDTO>>(autores);
				return Ok(autoresDTO);
			}
			
		}	
		
		
		DESPUES
		[HttpGet("filtrar")]
		[AllowAnonymous]
		public async Task<ActionResult> Filtrar([FromQuery] AutorFiltroDTO autorFiltroDTO)
		{
			var queryable = context.Autores.AsQueryable();

			if (!string.IsNullOrEmpty(autorFiltroDTO.Nombres))
			{
				queryable = queryable.Where(x => x.Nombres.Contains(autorFiltroDTO.Nombres));
			}

			if (!string.IsNullOrEmpty(autorFiltroDTO.Apellidos))
			{
				queryable = queryable.Where(x => x.Apellidos.Contains(autorFiltroDTO.Apellidos));
			}

			if (autorFiltroDTO.IncluirLibros)
			{
				queryable = queryable
					.Include(x => x.Libros)
					.ThenInclude(x => x.Libro);
			}

			if (autorFiltroDTO.TieneFoto.HasValue)
			{
				if (autorFiltroDTO.TieneFoto.Value)
				{
					queryable = queryable.Where(x => x.Foto != null);
				}
				else
				{
					queryable = queryable.Where(x => x.Foto == null);
				}
			}

			if (autorFiltroDTO.TieneLibros.HasValue)
			{
				if (autorFiltroDTO.TieneLibros.Value)
				{
					queryable = queryable.Where(x => x.Libros.Any());
				}
				else
				{
					queryable = queryable.Where(x => !x.Libros.Any());
				}
			}

			if (!string.IsNullOrEmpty(autorFiltroDTO.TituloLibro))
			{
				queryable = queryable.Where(x =>
					x.Libros.Any(y => y.Libro!.Titulo.Contains(autorFiltroDTO.TituloLibro)));
			}

			if (!string.IsNullOrEmpty(autorFiltroDTO.CampoOrdenar))
			{
				var tipoOrden = autorFiltroDTO.OrdenAscendente ? "ascending" : "descending";

				try
				{
					queryable = queryable.OrderBy($"{autorFiltroDTO.CampoOrdenar} {tipoOrden}");
				} 
				catch (Exception ex){
					queryable = queryable.OrderBy(x => x.Nombres);
					logger.LogError(ex.Message, ex);
				}
			}
			else
			{
				queryable = queryable.OrderBy(x => x.Nombres);
			}

			var autores = await queryable
					.Paginar(autorFiltroDTO.PaginacionDTO).ToListAsync();

			if (autorFiltroDTO.IncluirLibros)
			{
				var autoresDTO = mapper.Map<IEnumerable<AutorConLibrosDTO>>(autores);
				return Ok(autoresDTO);
			}
			else
			{
				var autoresDTO = mapper.Map<IEnumerable<AutorDTO>>(autores);
				return Ok(autoresDTO);
			}
			
		}
		
		-Se coge y se prueba. Antes se crea Autor.
		POST 
		{
		  "nombres": "Zoilo",
		  "apellidos": "Acevedo",
		  "identificacion": "123"
		}
		
		-Por defecto, se ordena por nombre. Si se pone CampoOrdenar "Nombres" y en OrdenAscendete se pone false, nombres iran en desc. Si se pone Apellidos idem.
		-Se prueba.
		
	144. Borrado Lógico y Filtros Globales
		-En apps del mundo, real es normal que no boreemos registros, sino marcarlos como borrados. Se suele hacer asi por temas de auditoria.
		-Se quiere poder seguir accediendo a los datos, una vez han sido "borrados".
		-Si se quiere aplicar borrado logico a los comentarios de un libro, se hace porque si alguien violenta normal con comentario,
		 se quiere que quede registro de comentario como evidencia.
		-Se agrega columna a la Entidad Comentario que indica si esta borrado o no.
		public bool EstaBorrado { get; set; }
		
		-Se agrega nueva migracion: Add-Migration ComentariosBorradoLogico.
		-Se ve que se agrega nueva columna cuyo valor por defecto es false porque asi todo comentario todo comentario que exista quedará como NoBorrado.
		-Se ejecuta Update-Database.
		-Se va a ComentariosController y se actualiza el metodo DELETE.
		Esto
		context.Remove(comentarioDB);
		await context.SaveChangesAsync();
		
		Por esto
		comentarioDB.EstaBorrado = true;
		context.Update(comentarioDB);
		await context.SaveChangesAsync();
		
		-Se listan los libros desde Swagger para coger el id de un libro y agregar un comentario.
		-Se va al endpoint de comentarios para ver los comentarios de ese libro y se coge el id del comntario con groseria.
		-Se va al endpoint del delete con el id del comentario y id del libro para borrar.
		-Se va a SQL Server a la tabla de Comentarios y se ve que EstaBorrado = 1
		-En el endpoint del GET se sigue viendo el comentario.
		-Para evitar que comentario borrado salga, pues se puede aplicar filtrado global.
		-El filtro global es el que se va a aplicar siempre sobre una entidad.
		-Asi cada vez que se haga querya  la tabla, por defecto se aplica un filtro.
		-En este caso, se aplica filtro que traiga comentarios no borrados.
		-Se va a ApplicationDbContext y se mete esto.
		ANTES
		protected override void OnModelCreating(ModelBuilder modelBuilder)
		{
			base.OnModelCreating(modelBuilder);
			// modelBuilder.Entity<Autor>().Property(x=>x.Nombre).HasMaxLength(150);
		}
		
		DESPUES
		protected override void OnModelCreating(ModelBuilder modelBuilder)
		{
			base.OnModelCreating(modelBuilder);
			// modelBuilder.Entity<Autor>().Property(x=>x.Nombre).HasMaxLength(150);

			modelBuilder.Entity<Comentario>().HasQueryFilter(b => !b.EstaBorrado);
		}
		
		-Se prueba el endñpoint GET del comentario del libro.
		
	145. Implementando Caché con OutputCache
		-Cada vez que se consulta la data de cualquier tabla siemrpe se va a la tabla de BBDD a consultar info.
		-Esto no tiene por qué ser estrategico porque si la data no ha cambiado entonces no tiene sentido tomar la data de BBDD.
		-Cache significa colcoar la data en un lugar de rapido acceso. Por ejemplo, datos en memoria:
			1) Tener app mas rapida.
			2) permitir que BBDD se concentre en otras tareas y no estar consumiendo sus recursos sin necesidad.
			
		-Se implementa cache en WebAPI y se llama OutputCache.
		-Permite guardar en caché respuestas de una accion.
		-Se va a Program.
		-Se mete un tiempo de expiracion para el cache.
		-Si activas el cache en la accion de obtener actores, esos actores se van a mantener en memoria en tal sentido que durante 15 sg 
		 las siguientes peticiones HTTP van a obtener respuesta del cache, luego cache expirara y la siguiente epticion va a llegar a accion y consultara BBDD.
		builder.Services.AddOutputCache(opciones =>
		{
			opciones.DefaultExpirationTimeSpan = TimeSpan.FromSeconds(15);
		});
		
		-Se va a Middlewares que tiene que mirar que la data esta en cache y devuelva dicha data sin que se ejecute la accion.
		 Despues de UseCors:
		 app.UseOutputCache();
		 
		-Se va a AutoresController y se añade esto en el GET: [OutputCache]
		-Cuando cache no tiene la data que buscamos, se activara un breakpoint que metamos en ese metodo, si tiene data, no se activa.
		age: 11 es que ha vivido esa data 11 sg en el cache.
		
		-Se mete [OutputCache] en ObtenerAutor.
		-filtrar endpoint no recibe esto porque realiza consultas distitnas... En post y put tpoco.
		-Se va a Comentarios Controller. Se mete en los dos GET.
		-LibroSController idem.
		-Si se prueba en ObtenrAutor en AutoresContreoller se tendra data distinta en caché segun el id del autor.
		-Se prueba endpoint con 14 por ejemplo y se activa, luego con 5 se activa tmbien. Si dice 14 no se activa. Tenemos caches distintos segun id del autor.
		
	146. Limpiando el Cache
		-Se cambia el program el tiempo de cache a 60sg.
		//área de servicios

		builder.Services.AddOutputCache(opciones =>
		{
			opciones.DefaultExpirationTimeSpan = TimeSpan.FromSeconds(60);
		});
		
		-Se loggea y crea un nuevo autor.
		POST
		{
		  "nombres": "Autor",
		  "apellidos": "Cache",
		  "identificacion": "123"
		}
		
		-Si se ejecuta el GET, se ve que aun está el caché en vigencia ya que dice que tiene un age de 40 sg.
		 Hasta que no expire, no se peude ver autor que acabamos de crear.
		 Esto problema porque usuario crea registro y no lo ve.
		 Pasada la expiracion, se crea.
		 Se puede `revenir esto limpiando cache de forma manual
		
		-Se inyecta servicio en AuotresController.
		 private readonly ApplicationDbContext context;
		 private readonly IMapper mapper;
		 private readonly IAlmacenadorArchivos almacenadorArchivos;
		 private readonly ILogger<AutoresController> logger;
		 private readonly IOutputCacheStore outputCacheStore;
		 private const string contenedor = "autores";

		 public AutoresController(ApplicationDbContext context, IMapper mapper, 
			 IAlmacenadorArchivos almacenadorArchivos, ILogger<AutoresController> logger,
			 IOutputCacheStore outputCacheStore)
		 {
			 this.context = context;
			 this.mapper = mapper;
			 this.almacenadorArchivos = almacenadorArchivos;
			 this.logger = logger;
			 this.outputCacheStore = outputCacheStore;
		 }
		 
		-Se crea una propeidad privada de chache que va a ser una llave que permite borrar la cache de Autores.
		private const string cache = "autores-obtener";
		
		-En OutputCache se usa ese nombre de la llave que es como un Tag: 
		-Se mete a los dos getters y la idea es que cuando cree un autor, actualice o borre, pues se limpie cache.
		-En el post se mete asi.
		ANTES
		[HttpPost]
		public async Task<ActionResult> Post(AutorCreacionDTO autorCreacionDTO) {
			var autor = mapper.Map<Autor>(autorCreacionDTO);
			context.Add(autor);
			await context.SaveChangesAsync();
			var autorDTO = mapper.Map<AutorDTO>(autor);
			return CreatedAtRoute("ObtenerAutor", new { id = autor.Id }, autorDTO);
		}
		
		DESPUES
		[HttpPost]
		public async Task<ActionResult> Post(AutorCreacionDTO autorCreacionDTO) {
			var autor = mapper.Map<Autor>(autorCreacionDTO);
			context.Add(autor);
			await context.SaveChangesAsync();
			await outputCacheStore.EvictByTagAsync(cache, default);
			var autorDTO = mapper.Map<AutorDTO>(autor);
			return CreatedAtRoute("ObtenerAutor", new { id = autor.Id }, autorDTO);
		}
		
		-Se hace idem con el otro post, put, patch, delete despeus del SaveChanges.
		-Se prueba en Swagger.
		-Cogemos, loggeamos y se crea nuevo autor y se ve en el GET si se refresca.
		{
		  "nombres": "Autor",
		  "apellidos": "De Swagger 3",
		  "identificacion": "1234"
		}
		
		-Se mete esto mismo para libros y comentarios
		private const string cache = "libros-obtener";
		
		
	147. Introducción al caché distribuido
		-El cache nos permite tener la data en un lugar de rapido acceso para que asi nuestra app responda a las peticiones del usuario 
		 de manera mas rapida. 
		-Hay algo que podria ser problema porque nuestra estrategia de cache se basa en colocar en memoria los datos que deseamos guardar en cache.
		-2 desventajas:
			-Si reiniciamos servidor, se pierden todos los datos de cache. Puede hacer que app lenta en lo que se vuelve a colcoar data en cache.
			-Si hay varias instancia de niestro webAPI siendo ejecutadas de manera simultanea. Para apps de alta demanda es normal tener misma app
			 ejecutandose varias veces en servidores distintos de tal forma que se peudan repartir entre si a los usuarios.
			-Si tienes 1M de usuarios usando misma app, mejor teenr 500.000 usuarios usando una app y el otro medio millon usando la otra app.
			-Sin embargo, reto importante. Como pueden ambas apps compartir cache? Si cache es por app cmo hemos estado haciendo hasta ahora, 
			 pues seria problematico porque un usuario puede estar usando una app u otra indistintamente. Es decir, un usuario una peticion
			 a nuestra app y esa peticion puede caer en instancia 1 o 2 de nuestro webAPI. Para hacer uso efectivo de cache, necesitamos una estrategia que
			 nos permita compartir una capa de cache entre distintas instancias de nuestro webAPI.
			 Para solucionar estos dos problemas, se usa el caché distribuido.
			 Esto es una capa de caché compartida por avrias apps, probablemente, en servidores distintos.
			 Lo podemos visualizar como una bbdd rapida y externa que nuestras apps pueden compartir.
			 Es difernete al OutputCache que hemos estado usando hasta ahora, que aunque era rapido, noe ra externo a nuestra instancia de nuestra app.
		-Existen varios tipos de herramientas para implementar Cache Distribuido, una de ellas es Redis.
		-Redis es tecnologia de codigo abierto que permite guardar datos en memoria.
		-Se va a usar para cache pero se puede usar para nuestra BBDD.
		-Se usa Redis para implementar nuestra estrategia de cache distribuido.
		-Opciones:
			-Redis en nuestra maquina: permite hacer pruebas en tiempo de desarrollo. O incluso si montamos nuestro WebAPI 
			 en IIS, nada detiene para suarlo en PROD.
			-Redis en la nube: Azure Cache for Redis que es solucion de Microsoft para poder usar Redis en Azure.
			 Se sua servicio gratis en la nube para usar REDIS.
			 
	
	148. Creando una Base de Datos en REDIS
		-Vamos a conmfigurar nuestro servidor de Redis en la nube de forma gratuita. Genial para hacer pruebas. Es limitado pero es suficiente para lo que queremos hacer.
		-se le da a Try redis y se da de alta.
		-Se crea la base de datos y se ve que hay un endpoint publico.
		-Y hay un password.
		-Se le puede dar a Open with Redis Insight que es como un cliente que nos permite interactar con BBDD de Redis.
		-Esto permite tener un cliente a traves del cual podemos visualizar las entradas de mi BBDD de Redis.
		-Se puede abrir web o descargando.
	
	149. Utilizando Redis en ASP.NET Core
		-Se busca el endpoint publico y secopia.
		-Se va al app.settings.Development.json.
		"redis": "redis-14763.c57.us-east-1-4.ec2.redns.redis-cloud.com:14763,password=TdsB1nOQ6PQQ7PgausYiLpGij33BZdxU"
		
		-Se instalan dos paquetes nugget.
		Microsoft.Extensions.Caching.StackExchangeRedis
		Microsoft.AspNetCore.OutputCaching.StackExchangeRedis
		
		-Se va a Program, se comenta el OutputCache y se mete evrsion para Redis.
		builder.Services.AddStackExchangeRedisOutputCache(opciones =>
		{
			opciones.Configuration = builder.Configuration.GetConnectionString("redis");
		});
		
		-Si ejecutamos la app y ejecutamos el getter de autores y vamos a REdis ya tengo la primera entrada...
		-Se tiene ahi la data en json.
		-En AuotresController en GET se mete breakPoint y se expira al minuto y luego se ejecutara y ya entrara al breakpoint.y en execute se trae data de redis
		 y no de mi bbdd. Estop permite descargar el uso de mi bbdd y que no se este usando tanto.
		 
	150. Introducción a los filtros
		-Los filtros nos ayudan a correr código en determinados momentos del ciclo de vida del procesamiento de una petición HTTP.
		-Hasta ahora, nos hemos enfocado en las acciones, sin embargo, antes y después de ejecutar una accion de un controlador, tenemos la opcion
		 de ejecutar codigo usando filtros. Son utiles cuando tenemos neecsidad de ejecutar una logica en varias acciones de varios controladores 
		 y se quiere evitar tener codigo reeptido.
		-Uno de los filtros es el filtro de autorizacion que permite bloquear accesos a un recuros cuando un usuario no esta logeado o no tiene credenciales
		 adecuadas, como que no sea un administrador.
		-Esta logica no es especifica de una sola accion.
		-Multiples accioens de multiples controladores se peuden beneficiar de poder indicar que solo usuarios que se han autenticado en nuestro webAPI peuden 
		 consumir una accion determinada.
		 
		-Hay filtros de autorizacion que determinan si un usuario puede consumir una accion en especifico.
		-Filtros de recursos que se ejecutan despues de la etapa de autorizacion. Podemos usarlos para valdiaciones generales o para implementar una capa
		 de cache personalizada. La idea de estos filtros es que ademas peudan detener la tuberia de filtros.
		 De tal modo que, ni los demas filtros, ni las acciones del controlador se ejecuten.
		-Filtros de accion se eejcutan juasto antes y despues de la ejecucion de una accion. Se peuden usar para manipular argumentos de una accion o a la info
		 retoirnada por los mismos.
		-Filtros de excepcion. Se ejecutan cuando hubo una excepcion no atrapada en un try-catch durante la ejecucion de accioj, filtro de accion, creacion de una accion y 
         durante el binding de modelo.
		-Filtro de resultado: se ejecutan antes y despues de la ejecucion de un ActionResult. 
		
		-Una manera tipica de aplciar un filtro, es a nivel de una accion. 
		-La idea es que la logica de dicho filtro se va a ejecutar cuando se vaya a procesar una peticion HTTP sobre la accion marcada con el filtro.
		-Los filtros tambien se pueden colocar a nivel de controladores, de tal forma que apliquen a todas las acciones de dicho controlador.
		 Estoa filtros se colocan como atributos, ya sea en las acciones o controladores correspondientes.
		-Tambien se pueden aplciar filtros a nivel de todo el webAPI de tal forma que dicho filtro se aplique a todas las acciones de todos los controladores de nuestro proyecto.
	
	151. Creando nuestro primer filtro
		-Existen distintos tipos de filtro que se ejecutan en diferentes momentos del ciclo de vida del procesamiento una paeticion HTTP.
		-Se va a crear el mas simple que es el filtro de accion.
		-Es el que se ejecuta antes y despeus de una accion.
		-Para rear filtro de accion tenemos que crear una clase la cual va a implementar las interfaces IActionFilter o IActionAsyncFIlter (usa asincronia).
		-En nuetsro caso, se sua IActionFilter.
		-Se va a Utilidades y se mete clase: MiFiltroDeAccion.
		-OActionExcuting antes de la accion. OnActionExecuted despues de la accion.
		public class MiFiltroDeAccion : IActionFilter
		{
			private readonly ILogger<MiFiltroDeAccion> logger;

			public MiFiltroDeAccion(ILogger<MiFiltroDeAccion> logger)
			{
				this.logger = logger;
			}
			//Antes de la acción
			public void OnActionExecuting(ActionExecutingContext context)
			{
				logger.LogInformation("Ejecutando la acción");
			}

			//Después de la acción
			public void OnActionExecuted(ActionExecutedContext context)
			{
				logger.LogInformation("Acción ejecutada");
			}

		}
		
		-Se quiere aplicar este filtro a una accion de AutoresController. Se aplcia a la GET. Dado que el filtro de accion usa el sistema 
		 de inyeccion de dependencias, para poder consfigurarlo aqui hay que incluir esto: [ServiceFilter<MiFiltroDeAccion>()]
		 Como se usa este FiltroDeaccion con un ServiceFilter, queire decir que lo estamos necesitando como un servicio.
		 
		-Se va a Prorgam para configurar el filtro como un servicio: builder.Services.AddScoped<MiFiltroDeAccion>();
		-Se prueba el endpoint de GET autores.
		
	152. Filtros Que Aceptan Parámetros
		-Los filtors aceotan argumentos y es util cuando tenemos filtro el cual se quiere usar en distntas acciones o distintos controladores 
		 pero queremos pasarle un argumento.  Es parecido al Authorize que se le pasa un valor.
		 Algo asi para filtro personalizado.
		
		-Un ejemplo de esto es que se quieran agregar cabeceras a la respuesta HTTP personalizada por accion.
		-Patra esto se peude crear un filtro que herede de un atributo.
		-Se crea una clase en Utilidades.
		-ActionFilterAttribute que es un atributo para definir un filtro de accion que va a aceptar argumentos.
		-Se va apermitir definir cabeceras personalziadas para ser agregadas en als respuesta http y se va a agregar el nombre de la cebecera y su valor.
		-Con el OnReusltExecuting yo puedo ejecutar una accion antes o despeus de la ajecucion de la accion.
		public class FiltroAgregarCabecerasAttribute : ActionFilterAttribute
		{
			private readonly string nombre;
			private readonly string valor;

			public FiltroAgregarCabecerasAttribute(string nombre, string valor)
			{
				this.nombre = nombre;
				this.valor = valor;
			}

			public override void OnResultExecuting(ResultExecutingContext context)
			{
				//Antes de la ejecución de la acción
				context.HttpContext.Response.Headers.Append(nombre, valor);
				base.OnResultExecuting(context);
				//Después de la ejecución de la acción
			}
		}
		
		-Vamos a AutoresController y se agrega a nivel de controlador: [FiltroAgregarCabeceras("controlador", "autores")]
		-Se va al endpoint GET de AutoresController: [FiltroAgregarCabeceras("acción", "obtener-autores")]
		-Esta el filtro a nivel de la accion y a nivel de contorlador. Quiere decir que se va a anexar a todas las acciones del controlador.
		-Todas tiene eso en la repsuesta de la accion HTTP, mientras que en la accion de GET se agrega lo personalziado para esa accion.
		
	153. Filtros Globales
		-El filtro Global se ejecuta en todas las acciones de la app.
		-Si se quiere medir el tiempo de ejecucion de todas las acciones del WebAPI,
		 pues en vez de modificar cada accion, mejor crear un filtro global.
		-Se agrega una clase en Utildiades. Es asincrono.
		-Con el await next() inicio la ejecucion del filtro o de la siguiente accion
		public class FiltroTiempoEjecucion : IAsyncActionFilter
		{
			private readonly ILogger<FiltroTiempoEjecucion> logger;

			public FiltroTiempoEjecucion(ILogger<FiltroTiempoEjecucion> logger)
			{
				this.logger = logger;
			}

			public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
			{
				//Antes de la ejecución de la acción
				var stopWatch = Stopwatch.StartNew();
				logger.LogInformation($"INICIO Acción: {context.ActionDescriptor.DisplayName}");

				await next();

				//Después de la ejecución de la acción
				stopWatch.Stop();
				logger.LogInformation($"FIN Acción: {context.ActionDescriptor.DisplayName} - Tiempo: {stopWatch.ElapsedMilliseconds} ms");
			}
		}
		
		-Se va la clase program y se configura el filtro como un filtro global.
		builder.Services.AddControllers(opciones =>
		{
			opciones.Filters.Add<FiltroTiempoEjecucion>();
		}).AddNewtonsoftJson();
		
		-En el getter de autoresController se suspende la ejecucion del cache porque si esta activo, no se ejecuta la accion.
		-Sino se ejecuta la accion, no se ejecuta el filtro de accion.
		
		-Se prueba FiltroGlobal en Swagger.
	
	154. Filtro para Centralizar Validaciones Repetidas
		-En aalgunas de las acciones, hay validacioens repetidas.
		-En LibrosController, en el post y en el put, hay mismas validaciones.
		-Hay varias formas de centralizar esto.
		-Simplemente se podrían colocar estas validaciones en un método en LibrosController y ya.
		-Se quiere enseñar cómo utilizar un filtro para sacar las validaciones de ahí y hacer una acción más simple.
		-Se crea en Utilidades una nueva Clase.
		-Se tiene que utilizar el DbContext asi que se inyecta la dependencia en el ctor.
		-Las acciones deben ocurrir antes de yo realizar la accion.
		ACCION POST - Antes
		[HttpPost]
		public async Task<ActionResult> Post(LibroCreacionDTO libroCreacionDTO)
		{
			if(libroCreacionDTO.AutoresIds is null || libroCreacionDTO.AutoresIds.Count == 0)
			{
				ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds),
					"No se puede crear un libro sin autores");
				return ValidationProblem();
			}

			var autoresIdsExisten = await context.Autores
									.Where(x => libroCreacionDTO.AutoresIds.Contains(x.Id))
									.Select(x => x.Id).ToListAsync();

			if (autoresIdsExisten.Count != libroCreacionDTO.AutoresIds.Count)
			{
				var autoresNoExisten = libroCreacionDTO.AutoresIds.Except(autoresIdsExisten); ;
				var autoresNoExistenString = string.Join(",", autoresNoExisten);
				var mensajeError = $"Los siguientes autores no existen: {autoresNoExistenString}";
				ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds), mensajeError);
				return ValidationProblem();
			}

			var libro = mapper.Map<Libro>(libroCreacionDTO);
			AsignarOrdenAutores(libro);

			context.Add(libro);
			await context.SaveChangesAsync();
			await outputCacheStore.EvictByTagAsync(cache, default);

			var libroDTO = mapper.Map<LibroDTO>(libro);

			return CreatedAtRoute("ObtenerLibro", new { id = libro.Id }, libroDTO);
		}
		
		ACCION PUT Antes
		[HttpPut("{id:int}")]
		public async Task<ActionResult> Put(int id, LibroCreacionDTO libroCreacionDTO)
		{
			if (libroCreacionDTO.AutoresIds is null || libroCreacionDTO.AutoresIds.Count == 0)
			{
				ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds),
					"No se puede crear un libro sin autores");
				return ValidationProblem();
			}

			var autoresIdsExisten = await context.Autores
									.Where(x => libroCreacionDTO.AutoresIds.Contains(x.Id))
									.Select(x => x.Id).ToListAsync();

			if (autoresIdsExisten.Count != libroCreacionDTO.AutoresIds.Count)
			{
				var autoresNoExisten = libroCreacionDTO.AutoresIds.Except(autoresIdsExisten); ;
				var autoresNoExistenString = string.Join(",", autoresNoExisten);
				var mensajeError = $"Los siguientes autores no existen: {autoresNoExistenString}";
				ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds), mensajeError);
				return ValidationProblem();
			}

			var libroDB = await context.Libros
						  .Include(x => x.Autores)
						  .FirstOrDefaultAsync(x => x.Id == id);

			if(libroDB is null)
			{
				return NotFound();
			}

			libroDB = mapper.Map(libroCreacionDTO, libroDB);
			AsignarOrdenAutores(libroDB);

			await context.SaveChangesAsync();
			await outputCacheStore.EvictByTagAsync(cache, default);
			return NoContent();
		}
		
		-Este es el cacho de código que trabajamos en la clase.
		if (libroCreacionDTO.AutoresIds is null || libroCreacionDTO.AutoresIds.Count == 0)
		{
			ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds),
				"No se puede crear un libro sin autores");
			return ValidationProblem();
		}

		var autoresIdsExisten = await context.Autores
								.Where(x => libroCreacionDTO.AutoresIds.Contains(x.Id))
								.Select(x => x.Id).ToListAsync();

		if (autoresIdsExisten.Count != libroCreacionDTO.AutoresIds.Count)
		{
			var autoresNoExisten = libroCreacionDTO.AutoresIds.Except(autoresIdsExisten); ;
			var autoresNoExistenString = string.Join(",", autoresNoExisten);
			var mensajeError = $"Los siguientes autores no existen: {autoresNoExistenString}";
			ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds), mensajeError);
			return ValidationProblem();
		}
		
		-Hay que validar que se nos envia a la accion del put un LibroCreacionDTO.
		-Sino existe la variable de tipo libroCreacionDTO y ademas no es de ese tipo, entonces se va a retornar un error.
		-Se quiere centralizar como se va a convertir eso en un ProblemDetail.
		-Nueva clase en Utilidades ModelStateDictionaryExtensions.
		public static class ModelStateDictionaryExtensions
		{
			public static BadRequestObjectResult ConstruirProblemDetail (
				this ModelStateDictionary modelState)
			{
				var problemDetails = new ValidationProblemDetails(modelState)
				{
					Title = "One or more validation errors occurred.",
					Status = StatusCodes.Status400BadRequest
				};

				return new BadRequestObjectResult(problemDetails);
			}
		}
		
		-Esto se ha centralizado aca para que en FiltroValidacionLiro se pueda poner context.Result y asignar un valor al resultado, estoy haciendo un cortocircuito
		 a la tuberia de filtros de tal forma que evitamos que se ejecute la accion y los demas filtros.
		 
		-Este es el resultado de la clase que se estaba construyendo.
		public class FiltroValidacionLibro : IAsyncActionFilter
		{
			private readonly ApplicationDbContext dbContext;

			public FiltroValidacionLibro(ApplicationDbContext dbContext)
			{
				this.dbContext = dbContext;
			}

			public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
			{
				if (!context.ActionArguments.TryGetValue("libroCreacionDTO", out var value) || value is not LibroCreacionDTO libroCreacionDTO)
				{
					context.ModelState.AddModelError(string.Empty, "El modelo enviado no es válido");
					context.Result = context.ModelState.ConstruirProblemDetail();
					return;
				}

				if (libroCreacionDTO.AutoresIds is null || libroCreacionDTO.AutoresIds.Count == 0)
				{
					context.ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds),
						"No se puede crear un libro sin autores");
					context.Result = context.ModelState.ConstruirProblemDetail();
					return;
				}

				var autoresIdsExisten = await dbContext.Autores
										.Where(x => libroCreacionDTO.AutoresIds.Contains(x.Id))
										.Select(x => x.Id).ToListAsync();

				if (autoresIdsExisten.Count != libroCreacionDTO.AutoresIds.Count)
				{
					var autoresNoExisten = libroCreacionDTO.AutoresIds.Except(autoresIdsExisten); ;
					var autoresNoExistenString = string.Join(",", autoresNoExisten);
					var mensajeError = $"Los siguientes autores no existen: {autoresNoExistenString}";
					context.ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds), mensajeError);
					context.Result = context.ModelState.ConstruirProblemDetail();
					return;
				}
				await next();
			}
		}
		
		-Si se asan las validaciones, se sigue ejecutando el resto de la tuberia de filtros.
		-Se quiere usar este filtro en el PUT de LibrosController.
		DESPUES POST
		[HttpPost]
		[ServiceFilter<FiltroValidacionLibro>]
		public async Task<ActionResult> Post(LibroCreacionDTO libroCreacionDTO)
		{
			var libro = mapper.Map<Libro>(libroCreacionDTO);
			AsignarOrdenAutores(libro);

			context.Add(libro);
			await context.SaveChangesAsync();
			await outputCacheStore.EvictByTagAsync(cache, default);

			var libroDTO = mapper.Map<LibroDTO>(libro);

			return CreatedAtRoute("ObtenerLibro", new { id = libro.Id }, libroDTO);
		}
		
		DESPUES PUT
		[HttpPut("{id:int}")]
		[ServiceFilter<FiltroValidacionLibro>]
		public async Task<ActionResult> Put(int id, LibroCreacionDTO libroCreacionDTO)
		{
			var libroDB = await context.Libros
						  .Include(x => x.Autores)
						  .FirstOrDefaultAsync(x => x.Id == id);

			if(libroDB is null)
			{
				return NotFound();
			}

			libroDB = mapper.Map(libroCreacionDTO, libroDB);
			AsignarOrdenAutores(libroDB);

			await context.SaveChangesAsync();
			await outputCacheStore.EvictByTagAsync(cache, default);
			return NoContent();
		}
		
		-Se ve que se ha reducido mucho el código al centralizar las validaciones en un filtro.
		-FiltroValidacionLibro se va a configurar como un servicio: builder.Services.AddScoped<FiltroValidacionLibro>();
		-Hay que ir a Swagger, loggearse y despues ir al POST de Libros.
		-Creo el registro:
		{
		  "titulo": "Mi Libro",
		  "autoresIds": [
			4
		  ]
		}
		
		-Ahora se mete esto y se prueba a crear:
		{
		  "titulo": "Mi Libro"
		}
		
		-salta ya error.
		-Si se hace esto:
		{
		  "titulo": "Mi Libro",
		  "autoresIds": [
			4, 400
		  ]
		}
		
		-Salta error. Se ha podido centralizar la validacion de un libro para limpiar un poco y evitar repetir codigo en LibrosController.
		
	155. Manejo de Errores
		-No siempre la app va a funcionar correctamente.
		-En ocasiones, se van a arrojar errores. 
		-Es importante tener una politica de manejo de errores.
		-Quizas se quieran guardar los errores en BBDD para examinarlos en el futuro.
		-Es importante en PROD, para tener pleno conocimeinto acerca de errores que clienets estan experimentando.
		-Existen varias formas de hacer esto.
		-En este caso, se usa MiddleWare.
		-Se va a crear una entidad Error.
		-Se va a Entidades, se agrega Error.
		-Se mete un StackTrace recordando que es la secuencia de ejecucion de code que llevó al error.
		public class Error
		{
			public Guid Id { get; set; }
			public required string MensajeDeError { get; set; }
			public string? StackTrace { get; set; }
			public DateTime Fecha { get; set; }
		}
		
		-Se va al ApplicationDbContext y se coloca la nueva tabla de Errores: public DbSet<Error> Errores { get; set; }
		-Se va al Package Manager para ejecutar la migracion: Add-Migration TablaErrores
		-Despues, Update-Database.
		-Ahora se va a usar el MiddleWare que se mencionaba para ejecutar codigo al momeno de que haya excepcion no manejada.
		-Se va al area de middlewares de Program.
		app.UseExceptionHandler(exceptionHandlerApp => exceptionHandlerApp.Run(async context =>
		{
			var exceptionHandlerFeature = context.Features.Get<IExceptionHandlerFeature>();
			var excepcion = exceptionHandlerFeature?.Error!;

			var error = new Error()
			{
				MensajeDeError = excepcion.Message,
				StackTrace = excepcion.StackTrace,
				Fecha = DateTime.UtcNow
			};

			var dbContext = context.RequestServices.GetRequiredService<ApplicationDbContext>();
			dbContext.Add(error);
			await dbContext.SaveChangesAsync();
			await Results.InternalServerError(new
			{
				tipo = "error",
				mensaje = "Ha ocurrido un error inesperado",
				estatus = 500
			}).ExecuteAsync(context);
		}));
		
		-Se va a colocar una excepcion en el sobrecargado método de obtener-autores: throw new NotImplementedException();
		-Se va a la tabla de Errores y se ve que aun esta vacio.
		-Se ejecuta ese endpoint.
		
	156. Versionando el WebAPI
		-Las app raramente son estaticas. Aunque las construimos una vez, es posible que haya que hacerle ajustes a la misma.
		 En ocasiones, esos ajustes, requieren un cambio radical en las partes internas del software.
		-Actualizar un webAPI es facil, desde el punto de vista de hacer un despliegue es posible que haya clientes de nuestro webAPI a los que se les haga dificil  imposible
		 actualizar su sistema para que se ajuste a los cambios que vamos a introducir. Esto aplica cuando webAPI es utilizado por apps que no controlamos
		 Esto implica tener que versionar nuestro webAPI.
		-Versionar es hacer versiones de la app.
		-Existen versiones de Office, pues nuestro webAPI tiene sus versiones.
		-El cliente indica la version de la app con la que desea trabajar.
		-Como va a indicar el cliente tal cosa? Por queryString, por cabacerea, por URL...
		-Se suele poner por URL y es comun. Ene se caso, se definen endpoints como los siguientes. api/v1/autores.
		-Otra forma de versionar el webAPI es usando la cabecera de la peticion HTTP. De esta forma, se mantienen las URL intactas 
		 y lo que cambia es la cabecera que enviamos.
		-No todo cambio implica una nueva version.
		-Imagina el escenario donde pasamos de hacer los mapeos manualemente a hacerlos con AutoMapper. Esto es transaparente para cleintes y 
		 por tanto, no implica neecsidad de crear una nueva version.
		-Si hay un cambio que afecta a clientes, como campo nuevo para crear nueva entidad, eso debe ir en nueva version porque eso es un cambio que necesariamente modifica  
		 el codigo del cliente.
		-Si se hace webAPI abierto a terceros, los cuales pagaran por uso, hay que tener estrategia de versionamiento, ya se apor URL, campo de cabecera de epticion HTTP.
		-Es mejor opcion por URL porque asi es evidente la version con la que se trabaja a partir del endpoint.
		
	157. Versionando el WebApi con la URL
		-Se va a poner todos los controladores como que son de la version 1.
		-Se va a controllers y se mete una folder V1
		-Se meten los contorladores ahi dentro.
		-Se mete en cada controlador esto en los namespaces: namespace BibliotecaAPI.Controllers.V1;. Se actualizan rutas: [Route("api/v1/usuarios")]. Esto en cada controlador.
		-Hay que modificar también los nombres de rutas: [HttpGet("{ids}", Name = "ObtenerAutoresPorIdsV1")]
		 return CreatedAtRoute("ObtenerAutoresPorIdsV1", new { ids = idsString }, autoresDTO);
		
		-Se hace el cambio en todos los controladores.
		
		-Ahora se levanta Swagger.
		-Si se quiere introducir cambio en webapi. Se quiere que usuarios cuando vayan a obtener autor por id, que indique si dicho autor va a traer sus lirbos.
		-Ahora por defecto trae sus libros y por defecto va a ser falso.
		-Eso es un cambio que modifica el comportamiento externo de webapi.
		-En v2 se va a arrojar otro rdo que es autor pero sin libros.
		-En controllers: carpeta V2. Se copian y se pegan los controladores a esa carpeta.
		-Se cambia en los ficheros v1 por V2.
		-se compila para comprobar.
		
		-Se va a AutoresController para agregar el cambio.
		ANTES
		[HttpGet("{id:int}", Name = "ObtenerAutorV2")] // api/autores/id
		[AllowAnonymous]
		[EndpointSummary("Obtiene autor pod Id")]
		[EndpointDescription("Obtiene un autor por Id. Incluye sus libros. Si el autor no existe, se retorna 404.")]
		[ProducesResponseType<AutorConLibrosDTO>(StatusCodes.Status200OK)]
		[ProducesResponseType(StatusCodes.Status404NotFound)]
		//[OutputCache(Tags = [cache])]
		public async Task<ActionResult<AutorConLibrosDTO>> Get([Description("El id del autor")] int id)
		{
			var autor = await context.Autores
				.Include(x => x.Libros)
					.ThenInclude(x => x.Libro)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (autor is null)
			{
				return NotFound();
			}

			var autorDTO = mapper.Map<AutorConLibrosDTO>(autor);

			return autorDTO;

		}
		
		DESPUES
		-Se ejecuta ejecucion diferida con AsQueryable.
		[HttpGet("{id:int}", Name = "ObtenerAutorV2")] // api/autores/id
		[AllowAnonymous]
		[EndpointSummary("Obtiene autor pod Id")]
		[EndpointDescription("Obtiene un autor por Id. Incluye sus libros. Si el autor no existe, se retorna 404.")]
		[ProducesResponseType<AutorConLibrosDTO>(StatusCodes.Status200OK)]
		[ProducesResponseType(StatusCodes.Status404NotFound)]
		//[OutputCache(Tags = [cache])]
		public async Task<ActionResult<AutorConLibrosDTO>> Get([Description("El id del autor")] int id, bool incluirLibros = false)
		{
			var queryable = context.Autores.AsQueryable();

			if (incluirLibros)
			{
				queryable = queryable.Include(x => x.Libros)
					.ThenInclude(x => x.Libro);
			}
			var autor = await queryable.FirstOrDefaultAsync(x => x.Id == id);

			if (autor is null)
			{
				return NotFound();
			}

			var autorDTO = mapper.Map<AutorConLibrosDTO>(autor);

			return autorDTO;

		}
		
		-Se ve que para los lcientes que contrataron la versión 1 ahí está pero los que contrataron la versión 2 pues es diferente...
		-Es una forma de hacer clientes por cambio de contrato...
	
	158. Evitando Repetición de código al versionar
		-Puede que no guste la repeticion de code entre la version de un controlador y otro.
		-Cuando se creo  v2, se copio, pego y se hizo el cambio que correspondia en V2. Esto no es nada malo porque difernetes versiones, son para distintos clientes y podemos tener mayor 
		 tranquilidad que los cambios que vamos a hacer para una version, no tengan efectos inesperados en otras versiones de WebAPI.
		 De todos modos, se enseña forma de evitar esto.
		-En servicios, se mete carpeta V1. Se mete por ejemplo la funcionalidad de obteenrAutores.
		-Se copia el metodo de "obtener-autores".
		-Se va a la clase ServicioAutores, ctrl + punto, Extraer interfaz.
		public class ServicioAutores : IServicioAutores
		{
			private readonly ApplicationDbContext context;
			private readonly IHttpContextAccessor httpContextAccessor;
			private readonly IMapper mapper;

			public ServicioAutores(ApplicationDbContext context, IHttpContextAccessor httpContextAccessor, IMapper mapper)
			{
				this.context = context;
				this.httpContextAccessor = httpContextAccessor;
				this.mapper = mapper;
			}

			public async Task<IEnumerable<AutorDTO>> Get([FromQuery] PaginacionDTO paginacionDTO)
			{
				//throw new NotImplementedException();
				var queryable = context.Autores.AsQueryable();
				await httpContextAccessor.HttpContext!.InsertarParametrosPaginacionEnCabecera(queryable);
				var autores = await queryable
					.OrderBy(x => x.Nombres)
					.Paginar(paginacionDTO).ToListAsync();
				var autoresDTO = mapper.Map<IEnumerable<AutorDTO>>(autores);
				return autoresDTO;
			}
		}
		
		IServicioAutores
		public interface IServicioAutores
		{
			Task<IEnumerable<AutorDTO>> Get(PaginacionDTO paginacionDTO);
		}
	
		Se deja asi el Get:
		public async Task<IEnumerable<AutorDTO>> Get(PaginacionDTO paginacionDTO)
		{
			var queryable = context.Autores.AsQueryable();
			await httpContextAccessor.HttpContext!.InsertarParametrosPaginacionEnCabecera(queryable);
			var autores = await queryable
				.OrderBy(x => x.Nombres)
				.Paginar(paginacionDTO).ToListAsync();
			var autoresDTO = mapper.Map<IEnumerable<AutorDTO>>(autores);
			return autoresDTO;
		}
		
		-Se va AutoresController de la carpeta V2 de Controllers.
		-Se inyecta esto en el ctor: IServicioAutores servicioAutores
		-Ahora se sustituye lo que se tenía en el get de obtener-autores a esto:
		[HttpGet] // /api/autores/
		[AllowAnonymous]
		//[OutputCache(Tags = [cache])]
		[ServiceFilter<MiFiltroDeAccion>()]
		[FiltroAgregarCabeceras("accion", "obtener-autores")]
		public async Task<IEnumerable<AutorDTO>> Get([FromQuery] PaginacionDTO paginacionDTO)
		{
			return await servicioAutoresV1.Get(paginacionDTO);
		}
		
		-Mismo se hace en AutoresController de V1.
		-Se deberia hacer con todas las acciones del controlador que se repiten.
		-Se va a program para configurar els ervicio recien creado.
		-Se mete AddScopped porque comos e nos recomienda usarlo porque dependemos de ApplicationDBContext.
		builder.Services.AddScoped<BibliotecaAPI.Servicios.V1.IServicioAutores, BibliotecaAPI.Servicios.V1.ServicioAutores>();
		
	
	159. Swagger y Versionamiento
		-Si se turviesen 10 versiones de WebAPI esto seria inmanejable para verlo en Swagger.
		-Se va a configurar Swagger para que peuda trabaar con versioens de manera que solo se muestren los endpoints de la version que seleccione.
		-Se va a aproevchar que se estan configurando los controladores en namespaces que tienen el nombre de la version.
		-Se van a agrupar los controladores segun namespace en la que se encuentren.
		-Se va a clase program y se va a configurar un documento de Swagger por version.
		opciones.SwaggerDoc("v1", new Microsoft.OpenApi.Models.OpenApiInfo
		{
			Version = "v1",
			Title = "Biblioteca API",
			Description = "Este es un web api para trabajar con datos de autores y libros",
			Contact = new Microsoft.OpenApi.Models.OpenApiContact
			{
				Email = "felipe@hotmail.com",
				Name = "Felipe Gavilán",
				Url = new Uri("https://gavilan.blog")
			},
			License = new Microsoft.OpenApi.Models.OpenApiLicense
			{
				Name = "MIT",
				Url = new Uri("https://opensource.org/license/mit/")
			}
		});

		opciones.SwaggerDoc("v2", new Microsoft.OpenApi.Models.OpenApiInfo
		{
			Version = "v2",
			Title = "Biblioteca API",
			Description = "Este es un web api para trabajar con datos de autores y libros",
			Contact = new Microsoft.OpenApi.Models.OpenApiContact
			{
				Email = "felipe@hotmail.com",
				Name = "Felipe Gavilán",
				Url = new Uri("https://gavilan.blog")
			},
			License = new Microsoft.OpenApi.Models.OpenApiLicense
			{
				Name = "MIT",
				Url = new Uri("https://opensource.org/license/mit/")
			}
		});
		
		-En SwaggerUI se quiere indicar cual va a ser el endpoint para swagger 
		app.UseSwaggerUI(opciones =>
		{
			opciones.SwaggerEndpoint("/swagger/v1/swagger.json", "Biblioteca API V1");
			opciones.SwaggerEndpoint("/swagger/v2/swagger.json", "Biblioteca API V2");
		});
		
		-Se levanta app para ver que va OK.
		-Program queda así:
		using BibliotecaAPI.Datos;
		using BibliotecaAPI.Entidades;
		using BibliotecaAPI.Servicios;
		using BibliotecaAPI.Swagger;
		using BibliotecaAPI.Utilidades;
		using Microsoft.AspNetCore.Diagnostics;
		using Microsoft.AspNetCore.Identity;
		using Microsoft.EntityFrameworkCore;
		using Microsoft.IdentityModel.Tokens;
		using Microsoft.OpenApi.Models;
		using Swashbuckle.AspNetCore.SwaggerGen;
		using System.Text;

		namespace BibliotecaAPI
		{
			public class Program
			{
				public static void Main(string[] args)
				{
					var builder = WebApplication.CreateBuilder(args);

					var diccionarioConfiguraciones = new Dictionary<string, string>
					{
						{ "quien_soy", "un diccionario en memoria" }
					};

					builder.Configuration.AddInMemoryCollection(diccionarioConfiguraciones!);

					//área de servicios

					//builder.Services.AddOutputCache(opciones =>
					//{
					//    opciones.DefaultExpirationTimeSpan = TimeSpan.FromSeconds(60);
					//});

					builder.Services.AddStackExchangeRedisOutputCache(opciones =>
					{
						opciones.Configuration = builder.Configuration.GetConnectionString("redis");
					});

					var origenesPermitidos = builder.Configuration.GetSection("origenesPermitidos").Get<string[]>()!;

					builder.Services.AddCors(opciones =>
					{
						opciones.AddDefaultPolicy(opcionesCORS =>
						{
							opcionesCORS.WithOrigins(origenesPermitidos).AllowAnyMethod().AllowAnyHeader()
							.WithExposedHeaders("cantidad-total-registros");
						});
					});

					builder.Services.AddOptions<PersonaOpciones>()
						.Bind(builder.Configuration.GetSection(PersonaOpciones.Seccion))
						.ValidateDataAnnotations()
						.ValidateOnStart();

					builder.Services.AddOptions<TarifaOpciones>()
						.Bind(builder.Configuration.GetSection(TarifaOpciones.Seccion))
						.ValidateDataAnnotations()
						.ValidateOnStart();

					builder.Services.AddSingleton<ProcesamientoPago>();

					builder.Services.AddAutoMapper(typeof(Program));

					builder.Services.AddControllers(opciones =>
					{
						opciones.Filters.Add<FiltroTiempoEjecucion>();
					}).AddNewtonsoftJson();

					builder.Services.AddDbContext<ApplicationDbContext>(opciones => opciones.UseSqlServer("name=DefaultConnection"));

					builder.Services.AddIdentityCore<Usuario>()
						.AddEntityFrameworkStores<ApplicationDbContext>()
						.AddDefaultTokenProviders();

					builder.Services.AddScoped<UserManager<Usuario>>();
					builder.Services.AddScoped<SignInManager<Usuario>>();
					builder.Services.AddTransient<IServiciosUsuarios, ServiciosUsuarios>();
					//builder.Services.AddTransient<IAlmacenadorArchivos, AlmacenadorArchivosAzure>();
					builder.Services.AddTransient<IAlmacenadorArchivos, AlmacenadorArchivosLocal>();
					builder.Services.AddScoped<MiFiltroDeAccion>();
					builder.Services.AddScoped<FiltroValidacionLibro>();
					builder.Services.AddScoped<BibliotecaAPI.Servicios.V1.IServicioAutores, BibliotecaAPI.Servicios.V1.ServicioAutores>();

					builder.Services.AddHttpContextAccessor();

					builder.Services.AddAuthentication().AddJwtBearer(opciones =>
					{
						opciones.MapInboundClaims = false;
						opciones.TokenValidationParameters = new TokenValidationParameters
						{
							ValidateIssuer = false,
							ValidateAudience = false,
							ValidateLifetime = true,
							ValidateIssuerSigningKey = true,
							IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["llavejwt"]!)),
							ClockSkew = TimeSpan.Zero
						};
					});

					builder.Services.AddAuthorization(opciones =>
					{
						opciones.AddPolicy("esadmin", politica => politica.RequireClaim("esadmin"));
					});

					builder.Services.AddSwaggerGen(opciones =>
					{
						opciones.SwaggerDoc("v1", new Microsoft.OpenApi.Models.OpenApiInfo
						{
							Version = "v1",
							Title = "Biblioteca API",
							Description = "Este es un web api para trabajar con datos de autores y libros",
							Contact = new Microsoft.OpenApi.Models.OpenApiContact
							{
								Email = "felipe@hotmail.com",
								Name = "Felipe Gavilán",
								Url = new Uri("https://gavilan.blog")
							},
							License = new Microsoft.OpenApi.Models.OpenApiLicense
							{
								Name = "MIT",
								Url = new Uri("https://opensource.org/license/mit/")
							}
						});

						opciones.SwaggerDoc("v2", new Microsoft.OpenApi.Models.OpenApiInfo
						{
							Version = "v2",
							Title = "Biblioteca API",
							Description = "Este es un web api para trabajar con datos de autores y libros",
							Contact = new Microsoft.OpenApi.Models.OpenApiContact
							{
								Email = "felipe@hotmail.com",
								Name = "Felipe Gavilán",
								Url = new Uri("https://gavilan.blog")
							},
							License = new Microsoft.OpenApi.Models.OpenApiLicense
							{
								Name = "MIT",
								Url = new Uri("https://opensource.org/license/mit/")
							}
						});

						opciones.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
						{
							Name = "Authorization",
							Type = SecuritySchemeType.ApiKey,
							Scheme = "Bearer",
							BearerFormat = "JWT",
							In = ParameterLocation.Header
						});

						opciones.OperationFilter<FiltroAutorizacion>();

						//opciones.AddSecurityRequirement(new OpenApiSecurityRequirement
						//{
						//    {
						//        new OpenApiSecurityScheme
						//        {
						//            Reference = new OpenApiReference
						//            {
						//                Type = ReferenceType.SecurityScheme,
						//                Id = "Bearer"
						//            }
						//        },
						//        new string[]{ }
						//    }
						//});
					});

					var app = builder.Build();

					// área de middlewares

					app.UseExceptionHandler(exceptionHandlerApp => exceptionHandlerApp.Run(async context =>
					{
						var exceptionHandlerFeature = context.Features.Get<IExceptionHandlerFeature>();
						var excepcion = exceptionHandlerFeature?.Error!;

						var error = new Error()
						{
							MensajeDeError = excepcion.Message,
							StackTrace = excepcion.StackTrace,
							Fecha = DateTime.UtcNow
						};

						var dbContext = context.RequestServices.GetRequiredService<ApplicationDbContext>();
						dbContext.Add(error);
						await dbContext.SaveChangesAsync();
						await Results.InternalServerError(new
						{
							tipo = "error",
							mensaje = "Ha ocurrido un error inesperado",
							estatus = 500
						}).ExecuteAsync(context);
					}));
					app.UseSwagger();
					app.UseSwaggerUI(opciones =>
					{
						opciones.SwaggerEndpoint("/swagger/v1/swagger.json", "Biblioteca API V1");
						opciones.SwaggerEndpoint("/swagger/v2/swagger.json", "Biblioteca API V2");
					});

					app.UseStaticFiles();

					app.UseCors();

					app.UseOutputCache();

					app.MapControllers();

					app.Run();
				}
			}
		}
		
		-Se tiene que crear una convención que va a agrupar los controladores por versiones para que Swagger tome esa info y diga si estoy en v1, 
		 quiero v1 y si estoy en v2 idem....
		-Se crea clase emn la carpeta de Swagger. Se implementa esta interfaz: IControllerModelConvention
		public class ConvencionAgrupaPorVersion : IControllerModelConvention
		{
			public void Apply(ControllerModel controller)
			{
				throw new NotImplementedException();
			}
		}
		
		-Se hace la agrupacion:
		public class ConvencionAgrupaPorVersion : IControllerModelConvention
		{
			public void Apply(ControllerModel controller)
			{
				//Ejemplo: "Controllers.V1"
				var namespaceDelControlador = controller.ControllerType.Namespace;
				var version = namespaceDelControlador!.Split(".").Last().ToLower();
				controller.ApiExplorer.GroupName = version;
			}
		}
		
		-Ahora se aplica esta convención en program.
		builder.Services.AddControllers(opciones =>
		{
			opciones.Filters.Add<FiltroTiempoEjecucion>();
			opciones.Conventions.Add(new ConvencionAgrupaPorVersion());
		}).AddNewtonsoftJson();
		
		-se prueba en Swagger
		
	160. Introducción a HATEOAS	
		-Cuando se entra a página web te vas a encontrar un conjunto de elementos que te van a ayudar a navegar a dicho sitio web.
		-Esto hace que ahsta navegar a una página web sea hasta intuitivo.
		-Web API no tien esta caracteristica. Nos hemos mantenido haciendo peticionesHTTP hacia endpoints específicos, ls cuales, conocemos de antemano
		 o aunque los veamos por ejemplo en Swagger, no siempre sabemos si podemos usarlos o no.
		-Se soluciona con HATEOAS.
		-Es La Hipermedia como motor del estado de la app.
		-Es una restriccion de REST que sirve para ayudar a los clientes de nuestro webapi a navegar por nuestros recursos y saber qué son capaces 
		 de hacer.
		-Por ejemplo, se peuden indicar endpoints para neustros recursos, junto con los métodos HTTP que 
		 el usuario pueda realizar sobre los mismos. 
		-Aqui la idea es que las respuesta de nuestro webapi vana  contener info que represntan las difernetes acciones que el cliente puede realizar.
		-De un endpount, por ejemplo, se devuelve un listado de Autores. Cada autor va a tener un link para poder hacer un HTTPGET a dicho autor en especifico.
		-Tambien se podrán obtener links para savber cómo crear, borrar y actualizar autroes. 
		-Además de los links y los métodos HTTP se brinda pequeña descripción que sirve para indicar la acción.
	
	161. Implementando HATEOAS
		-La manera más simple es crear una clase base con los siguientes datos: link, pequeña descripcion  y el emtodo HHTP.
		-Se mete en DTOs.
		-Como quiero que sea inmutable porque realmente no busco nada, permitiendo que se cambien los datos 
		 una vez creados, pues meto un record.
		-Se mete record de orden u ordinal.
		public record DatosHATEOASDTO(string Enlace, string Descripcion, string Metodo);
		
		-Se crea clase base de la que van a heredar DTOs.
		public class RecursoDTO
		{
			public List<DatosHATEOASDTO> Enlaces { get; set; } = [];
		}
		
		-Ya podemos hacer el primer ejemplo de HATEOAS.
		-Desde un endpoint se devolveran los endpoints de nuestro webapi.
		-Se va a V1 y se le llama RootController.
		-Devuelve las rutas que el usuario puede usar.
		-Algo normal en HATEOAS es colocar el lugar donde se encuentra el usuario. Se devuelve la ruta ObtenerRootV1.
		-Se le ha puesto un nombre para generar de una forma muy fácil la URL.
		-Url es una clase auxiliar que nos permite formar la URL desde un controlador.
		-La convencion es llamarle self a la ruta que se llama asi misma.
		[ApiController]
		[Route("api/v1")]
		public class RootController : ControllerBase
		{
			[HttpGet(Name = "ObtenerRootV1")]
			public IEnumerable<DatosHATEOASDTO> Get()
			{
				var dateHATEOAS = new List<DatosHATEOASDTO>();

				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("ObtenerRootV1", new { })!, Descripcion: "self", Metodo: "GET"));

				return dateHATEOAS;
			}
		}
		
		-Se levanta y se ve que el endpoint devuelve la ruta de si misma.
	
	162. Agregando Otras Rutas
		-Se sigue implementando HATEOAS
		-Hay que colocar nombre a todas las rutas de WebAPI.
		-Iremos a V1.
		-Se empieza por AutoresColeccionController.
		[HttpPost(Name = "CrearAutoresV1")]
		-En AutoresController: 
			[HttpGet(Name = "ObtenerAutoresV1")]
			[HttpGet(Name = "ObtenerAutoresV1")]
			[HttpPost(Name = "CrearAutorV1")]
			[HttpPost("con-foto", Name = "CrearAutorConFotoV1")]
			[HttpPut("{id:int}", Name = "ActualizarAutorV1")] // api/autores/1 
			[HttpPatch("{id:int}", Name = "PatchAutorV1")]
			[HttpDelete("{id:int}", Name = "BorrarAutorV1")] // api/autores/1 
		
		-Se han cambiado nombres por detras de camaras para todos los endpoints de V1. Nosotros lo hacemos a lo nuestro...
		-Se vuelve a RootController para colocar las rutas que hemos creado. Por lo menos rutas que se corresponden con acciones que no son para un recuros especifico.
		 Es decir, no se coloca aqui la posibilidad de actualizar un autor o borrarlo porque eso pertenece al autor en si. En el root se listan acciones generales como crear un autor, un libro...
		 dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("ObtenerAutoresV1", new { })!, Descripcion: "autores-obtener", Metodo: "GET"));
		 No se va a meter Obteenr autor por Id. Se meten las acciones que no tenagn id de algo como autor, libro...
		
		[ApiController]
		[Route("api/v1")]
		public class RootController : ControllerBase
		{
			[HttpGet(Name = "ObtenerRootV1")]
			public IEnumerable<DatosHATEOASDTO> Get()
			{
				var dateHATEOAS = new List<DatosHATEOASDTO>();

				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("ObtenerRootV1", new { })!, Descripcion: "self", Metodo: "GET"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("ObtenerAutoresV1", new { })!, Descripcion: "autores-obtener", Metodo: "GET"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("CrearAutorV1", new { })!, Descripcion: "autor-crear", Metodo: "POST"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("CrearAutoresV1", new { })!, Descripcion: "autores-crear", Metodo: "POST"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("CrearLibroV1", new { })!, Descripcion: "libro-crear", Metodo: "POST"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("ObtenerUsuariosV1", new { })!, Descripcion: "usuarios-obtener", Metodo: "GET"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("RegistroUsuarioV1", new { })!, Descripcion: "usuario-registrar", Metodo: "POST"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("LoginUsuarioV1", new { })!, Descripcion: "usuario-login", Metodo: "POST"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("ActualizarUsuarioV1", new { })!, Descripcion: "usuario-actualizar", Metodo: "PUT"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("RenovarTokenV1", new { })!, Descripcion: "token-renovar", Metodo: "GET"));


				return dateHATEOAS;
			}
		}
		
		-Se prueba. En el root saca las distintas rutas...
		
	163. Removiendo las rutas las cuales el usuario no puede usar
		-Si miramos las rutas que nos devuelve nuestro controlador root, hay rutas que no tenemos por qué tenr permiso de acceder.
		-A menos que yo no sea admin, no pueod crear un Autor.
		-A menos que esté logueado, no puedo renovar token o actualizar el usuario.
		-Por tanto, lo que podemos hacer es mostrar acciones que usuario tenga eprmiso de usar.
		-Se mete Authorize y AllowAnonymous.
		[ApiController]
		[Route("api/v1")]
		[Authorize]
		public class RootController : ControllerBase
		{
			[HttpGet(Name = "ObtenerRootV1")]
			[AllowAnonymous]
			public IEnumerable<DatosHATEOASDTO> Get()
			{
				var dateHATEOAS = new List<DatosHATEOASDTO>();

				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("ObtenerRootV1", new { })!, Descripcion: "self", Metodo: "GET"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("ObtenerAutoresV1", new { })!, Descripcion: "autores-obtener", Metodo: "GET"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("CrearAutorV1", new { })!, Descripcion: "autor-crear", Metodo: "POST"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("CrearAutoresV1", new { })!, Descripcion: "autores-crear", Metodo: "POST"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("CrearLibroV1", new { })!, Descripcion: "libro-crear", Metodo: "POST"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("ObtenerUsuariosV1", new { })!, Descripcion: "usuarios-obtener", Metodo: "GET"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("RegistroUsuarioV1", new { })!, Descripcion: "usuario-registrar", Metodo: "POST"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("LoginUsuarioV1", new { })!, Descripcion: "usuario-login", Metodo: "POST"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("ActualizarUsuarioV1", new { })!, Descripcion: "usuario-actualizar", Metodo: "PUT"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("RenovarTokenV1", new { })!, Descripcion: "token-renovar", Metodo: "GET"));


				return dateHATEOAS;
			}
		}
		
		-Se usa esta combi cuando necesitamos acceder a info acerca de los claims del usuario porque voy a querer saber 
		 si el usuario es admin o no.
		 Con el authorizationService puedo saber si el usuario es admin o no.
		-Con esto ya probamos.
		[ApiController]
		[Route("api/v1")]
		[Authorize]
		public class RootController : ControllerBase
		{
			private readonly IAuthorizationService authorizationService;

			public RootController(IAuthorizationService authorizationService)
			{
				this.authorizationService = authorizationService;
			}

			[HttpGet(Name = "ObtenerRootV1")]
			[AllowAnonymous]
			public async Task<IEnumerable<DatosHATEOASDTO>> Get()
			{
				var dateHATEOAS = new List<DatosHATEOASDTO>();

				var esAdmin = await authorizationService.AuthorizeAsync(User, "esadmin");

				// Acciones que cualquiera puede realizar
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("ObtenerRootV1", new { })!, Descripcion: "self", Metodo: "GET"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("ObtenerAutoresV1", new { })!, Descripcion: "autores-obtener", Metodo: "GET"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("RegistroUsuarioV1", new { })!, Descripcion: "usuario-registrar", Metodo: "POST"));
				dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("LoginUsuarioV1", new { })!, Descripcion: "usuario-login", Metodo: "POST"));

				if (User.Identity!.IsAuthenticated)
				{
					dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("ActualizarUsuarioV1", new { })!, Descripcion: "usuario-actualizar", Metodo: "PUT"));
					dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("RenovarTokenV1", new { })!, Descripcion: "token-renovar", Metodo: "GET"));
				}

				if (esAdmin.Succeeded)
				{   
					// Acciones que sólo usuarios ADMIN pueden realizar
					dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("CrearAutorV1", new { })!, Descripcion: "autor-crear", Metodo: "POST"));
					dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("CrearAutoresV1", new { })!, Descripcion: "autores-crear", Metodo: "POST"));
					dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("CrearLibroV1", new { })!, Descripcion: "libro-crear", Metodo: "POST"));
					dateHATEOAS.Add(new DatosHATEOASDTO(Enlace: Url.Link("ObtenerUsuariosV1", new { })!, Descripcion: "usuarios-obtener", Metodo: "GET"));
				}


				return dateHATEOAS;
			}
		}
		
		-Para probar esto no se puede usar Swagger porque hemos configurado para que aquellos endpoints que tengan un AllowAnonymous no se les envíe el root por tema de caché.
		-Con Postman OK. GET http://localhost:5065/api/v1
		-Solo se tienen los endpoints aquellos las personas que no estan autenticadas pueden ver.
		-Si le doy a Authorization Token hay alguno mas....
		-Si le metemos Authorization Beare-Token ve mas cosas.
		-Segun lo que le metamos a la ruta vemos mas o menos cosas....
	
	164. Enlaces HATEOAS en un DTO
		-Se trabaja a nivel de Controladores.
		-Se trabaja en AutoresController con la opcion de obtener 1 autor.
		-Se retorna un AutorConLibrosDTO. Se tiene AutorDTO y se hereda de RecursoDTO que tiene un listado de enlaces..
		public class AutorDTO : RecursoDTO
		{
			public int Id { get; set; }
			public required string NombreCompleto { get; set; }
			public string? Foto { get; set; }
		}
		
		-Cone sto, se peude anexar enlaces a un Autor.
		-Debajo del endpoint de GET Autor por Id, se mete este metodo privado.
		-Se generan los enlaces propios de un autor en particular.
		-Aqui se peude actualizar un autor, hacerle un patch, o borrarlo.
		-No e sobligatorio meter lo de Enlace, Descripcion...pero mejor por claridad.
		private void GenerarEnlaces(AutorDTO autorDTO){
			autorDTO.Enlaces.Add(
				new DatosHATEOASDTO(
					Enlace: Url.Link("ObtenerAutorV1", new { id = autorDTO.Id })!,
					Descripcion: "self",
					Metodo: "GET"
					));

			autorDTO.Enlaces.Add(
				new DatosHATEOASDTO(
					Enlace: Url.Link("ActualizarAutorV1", new { id = autorDTO.Id })!,
					Descripcion: "autor-actualizar",
					Metodo: "PUT"
					));

			autorDTO.Enlaces.Add(
				new DatosHATEOASDTO(
					Enlace: Url.Link("PatchAutorV1", new { id = autorDTO.Id })!,
					Descripcion: "autor-patch",
					Metodo: "PATCH"
					));

			autorDTO.Enlaces.Add(
				new DatosHATEOASDTO(
					Enlace: Url.Link("BorrarAutorV1", new { id = autorDTO.Id })!,
					Descripcion: "autor-borrar",
					Metodo: "DELETE"
					));
		}
		
		-Se llama al metodo en esta funcion y se prueba.
		[HttpGet("{id:int}", Name = "ObtenerAutorV1")] // api/autores/id
		[AllowAnonymous]
		[EndpointSummary("Obtiene autor pod Id")]
		[EndpointDescription("Obtiene un autor por Id. Incluye sus libros. Si el autor no existe, se retorna 404.")]
		[ProducesResponseType<AutorConLibrosDTO>(StatusCodes.Status200OK)]
		[ProducesResponseType(StatusCodes.Status404NotFound)]
		//[OutputCache(Tags = [cache])]
		public async Task<ActionResult<AutorConLibrosDTO>> Get([Description("El id del autor")] int id)
		{
			var autor = await context.Autores
				.Include(x => x.Libros)
					.ThenInclude(x => x.Libro)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (autor is null)
			{
				return NotFound();
			}

			var autorDTO = mapper.Map<AutorConLibrosDTO>(autor);

			GenerarEnlaces(autorDTO);

			return autorDTO;

		}
		
		-Se le mete en el GET por Id el 4 y se ve lo que se peude hacer con este...
	
	165. Enlaces de HATEOAS en un Listado
		-Se vana  colocar los enlaces de HATEOAS en un listado.
		-Por ejemplo, en el listado de Autores.
		-Se agrega el enlace a cad auno de los DTOs.
		ANTES
		[HttpGet(Name = "ObtenerAutoresV1")] // /api/autores/
		[AllowAnonymous]
		//[OutputCache(Tags = [cache])]
		[ServiceFilter<MiFiltroDeAccion>()]
		[FiltroAgregarCabeceras("accion", "obtener-autores")]
		public async Task<IEnumerable<AutorDTO>> Get([FromQuery] PaginacionDTO paginacionDTO)
		{
			return await servicioAutoresV1.Get(paginacionDTO);
		}
		
		DESPUES
		[HttpGet(Name = "ObtenerAutoresV1")] // /api/autores/
		[AllowAnonymous]
		//[OutputCache(Tags = [cache])]
		[ServiceFilter<MiFiltroDeAccion>()]
		[FiltroAgregarCabeceras("accion", "obtener-autores")]
		public async Task<IEnumerable<AutorDTO>> Get([FromQuery] PaginacionDTO paginacionDTO)
		{
			var dtos = await servicioAutoresV1.Get(paginacionDTO);
			foreach (var dto in dtos)
			{
				GenerarEnlaces(dto);
			}

			return dtos;
		}
		
		-Se va al GET de Autores y esta cada autor con cada enlace de lo que podemos hacer con cada autor...
		-Aqui no podemos ver que se puede crear un autor y eso no lo puedo hacer desde aqui porque no puedo hacer dtos.Enlaces porque Enlaces es una propiedad 
		 de un IEnumerable de AutorDTO.
		
		-Se puede crear un tipo de dato el cual vamos a retorna desde nuestra accion.
		-Se crea en DTOs: ColeccionDeRecursosDTO
		-Se hereda de RecursoDTO para que tenga los enlaces 
		-where T: RecursoDTO. Osea que solo se peude usar para HATEOAS.
		public class ColeccionDeRecursosDTO<T>: RecursoDTO where T : RecursoDTO
		{
			public IEnumerable<T> Valores { get; set; } = [];
		}
		
		-Ahora se va a AutoresController y se modifica. -Se pasa el enlace de crear autor.
		ANTES
		[HttpGet(Name = "ObtenerAutoresV1")] // /api/autores/
		[AllowAnonymous]
		//[OutputCache(Tags = [cache])]
		[ServiceFilter<MiFiltroDeAccion>()]
		[FiltroAgregarCabeceras("accion", "obtener-autores")]
		public async Task<IEnumerable<AutorDTO>> Get([FromQuery] PaginacionDTO paginacionDTO)
		{
			var dtos = await servicioAutoresV1.Get(paginacionDTO);
			foreach (var dto in dtos)
			{
				GenerarEnlaces(dto);
			}

			return dtos;
		}
		
		AHORA
		[HttpGet(Name = "ObtenerAutoresV1")] // /api/autores/
		[AllowAnonymous]
		//[OutputCache(Tags = [cache])]
		[ServiceFilter<MiFiltroDeAccion>()]
		[FiltroAgregarCabeceras("accion", "obtener-autores")]
		public async Task<ColeccionDeRecursosDTO<AutorDTO>> Get([FromQuery] PaginacionDTO paginacionDTO)
		{
			var dtos = await servicioAutoresV1.Get(paginacionDTO);
			foreach (var dto in dtos)
			{
				GenerarEnlaces(dto);
			}

			var resultado = new ColeccionDeRecursosDTO<AutorDTO> { Valores = dtos };

			resultado.Enlaces.Add(new DatosHATEOASDTO(
				Enlace: Url.Link("ObtenerAutoresV1", new { })!,
				Descripcion: "self",
				Metodo: "GET"
				));

			resultado.Enlaces.Add(new DatosHATEOASDTO(
				Enlace: Url.Link("CrearAutorV1", new { })!,
				Descripcion: "autor-crear",
				Metodo: "POST"
				));

			resultado.Enlaces.Add(new DatosHATEOASDTO(
				Enlace: Url.Link("CrearAutorConFotoV1", new { })!,
				Descripcion: "autor-crear-con-foto",
				Metodo: "POST"
				));

			return resultado;
		}
		
		-Se ve que abajo del todo están estos enlaces.
	
	166. Excluir HATEOAS con un Query String
		-Se ve que emtodos como este retornan mucha info. HATEOAS es parte de lo que hace nuestro WEBAPI Restful.
		-Quizas, no a todo el mundo le interesa tener toda esta info.
		-Lo que se hara es la posibilidad de incluir HATEOAS al usuario de manera opcional.
		-Se va al endpint anterior y se hace esto.
		[HttpGet(Name = "ObtenerAutoresV1")] // /api/autores/
		[AllowAnonymous]
		//[OutputCache(Tags = [cache])]
		[ServiceFilter<MiFiltroDeAccion>()]
		[FiltroAgregarCabeceras("accion", "obtener-autores")]
		public async Task<ActionResult> Get([FromQuery] PaginacionDTO paginacionDTO, [FromQuery] bool incluirHATEOAS = false)
		{
			var dtos = await servicioAutoresV1.Get(paginacionDTO);

			if (incluirHATEOAS)
			{
				foreach (var dto in dtos)
				{
					GenerarEnlaces(dto);
				}

				var resultado = new ColeccionDeRecursosDTO<AutorDTO> { Valores = dtos };

				resultado.Enlaces.Add(new DatosHATEOASDTO(
					Enlace: Url.Link("ObtenerAutoresV1", new { })!,
					Descripcion: "self",
					Metodo: "GET"
					));

				resultado.Enlaces.Add(new DatosHATEOASDTO(
					Enlace: Url.Link("CrearAutorV1", new { })!,
					Descripcion: "autor-crear",
					Metodo: "POST"
					));

				resultado.Enlaces.Add(new DatosHATEOASDTO(
					Enlace: Url.Link("CrearAutorConFotoV1", new { })!,
					Descripcion: "autor-crear-con-foto",
					Metodo: "POST"
					));

				return Ok(resultado);
			}

			return Ok(dtos);
		}
		
		-Se salva y se ejecuta y se prueba el booleano.
		
	167. HATEOAS y Filtros (Parte 1)
		-Aunque el queryStroing funciona, esta accion de ObtenerAutoresV1, ete metodo, que lo unico que hace es obtener listado de Autores, se ha vuelto demasiado complicada.
		 Tiene muchas lineas 	de codigo para una funcionalidad tan simple.
		-Existe una forma mejor de organziar el code usando filtros.
		-Los filtros permiten ejecutar funcionalidad personalziada en distintos momentos del ciclo de vida del procesamiento
          de una peticion HTTP. Uno de los filtros que estudiabamos, servia para ser eejcutado antes y despues de un resultado de accion
		-Nosinteresa ejecutar funcioalidad antes de un resultado de accion.
		-Vamos a tener un code que va a tomar la respuesta geenrada por la accion y 
		 de ser necesario, le va a agregar los links del HATEOAS.
		-Esto va a hacer que nuestras acciones sean mucho mas limpias.
		-Se va a crear un filtro de rdo.
		-Estos filtros de rdo seran uno por cada tipo, el cual queramos que tenga la habilidad de usar HATEOAS.
		-Va a haber logica comun, la cual queremos centralizar en una clase base.
		-En Utilidades se mete HATEOASFilterAttribute.
		-El metodo va a determinar si en la peticion debemos incluri HATEOAS o no.
		-Si la respuesta no fue exitosa y tenemos un 404, no hay enlace HATEOAS que agregar.
		-En DebeIncluirHATEOAS estoy diciendo que si el resultado que viene de la accion no es un ObjectResult. Es decir, sino es un objeto que tiene un resultado como
		 ListadoDeAutores, ListadoDeLibros, se retorna falso.
		-Si es falso se castea a Result y ese result se `pasa  a EsRespuestaExitosa para hacer analisis...
		public class HATEOASFilterAttribute: ResultFilterAttribute
		{
			protected bool DebeIncluirHATEOAS(ResultExecutingContext context)
			{
				if (context.Result is not ObjectResult result || !EsRespuestaExitosa(result))
				{
					return false;
				}

				if (!context.HttpContext.Request.Headers.TryGetValue("IncluirHATEOAS", out var cabecera))
				{
					return false;
				}

				return string.Equals(cabecera, "Y", StringComparison.OrdinalIgnoreCase);
			}

			private bool EsRespuestaExitosa(ObjectResult result)
			{
				if (result.Value is null)
				{
					return false;
				}

				if (result.StatusCode.HasValue && !result.StatusCode.Value.ToString().StartsWith("2"))
				{
					return false;
				}

				return true;
			}
		}
		
		-Ahora hayq ue crear clase que permita generar enlaces de HATEOAS.
		-Cada version de webapi puede tener enlaces distintos, pues en Servicios V1 se crea clase llamada GeneradorEnlaces.
		-Me voya AutoresController y me llevo el método privado de GenerarEnlaces.
		public class GeneradorEnlaces : IGeneradorEnlaces (principio de inversion de dependencias)
		{
			private readonly LinkGenerator linkGenerator;
			private readonly IAuthorizationService authorizationService;
			private readonly IHttpContextAccessor httpContextAccessor;

			public GeneradorEnlaces(LinkGenerator linkGenerator, IAuthorizationService authorizationService, IHttpContextAccessor httpContextAccessor)
			{
				this.linkGenerator = linkGenerator;
				this.authorizationService = authorizationService;
				this.httpContextAccessor = httpContextAccessor;
			}

			public async Task GenerarEnlaces(AutorDTO autorDTO)
			{
				var usuario = httpContextAccessor.HttpContext!.User;
				var esAdmin = await authorizationService.AuthorizeAsync(usuario, "esadmin");
				GenerarEnlaces(autorDTO, esAdmin.Succeeded);
			}

			private void GenerarEnlaces(AutorDTO autorDTO, bool esAdmin)
			{
				autorDTO.Enlaces.Add(
					new DatosHATEOASDTO(
						Enlace: linkGenerator.GetUriByRouteValues(httpContextAccessor.HttpContext!, "ObtenerAutorV1", new { id = autorDTO.Id })!,
						Descripcion: "self",
						Metodo: "GET"
						));

				if (esAdmin)
				{
					autorDTO.Enlaces.Add(
						new DatosHATEOASDTO(
							Enlace: linkGenerator.GetUriByRouteValues(httpContextAccessor.HttpContext!, "ActualizarAutorV1", new { id = autorDTO.Id })!,
							Descripcion: "autor-actualizar",
							Metodo: "PUT"
							));

					autorDTO.Enlaces.Add(
						new DatosHATEOASDTO(
							Enlace: linkGenerator.GetUriByRouteValues(httpContextAccessor.HttpContext!, "PatchAutorV1", new { id = autorDTO.Id })!,
							Descripcion: "autor-patch",
							Metodo: "PATCH"
							));

					autorDTO.Enlaces.Add(
						new DatosHATEOASDTO(
							Enlace: linkGenerator.GetUriByRouteValues(httpContextAccessor.HttpContext!, "BorrarAutorV1", new { id = autorDTO.Id })!,
							Descripcion: "autor-borrar",
							Metodo: "DELETE"
							));
				}

			}
		}
		
		-Se va a crear un filtro para llamar a esta funcion de GenerarEnlaces.
		-Se mete en Utilidades carpeta de V1. Y se mete la clase HATEOASAutorAttribute.
		-Esto es un filtro de resultados que se va a ejecutar antes y despues de la ejecucion del ActionResult. Da chance de formatear dicho ActionResult.
		-Ese formateo va a ser agregarle el enlace de HATEOAS si cliente quiere.
		public class HATEOASAutorAttribute: HATEOASFilterAttribute
		{
			private readonly IGeneradorEnlaces generadorEnlaces;

			public HATEOASAutorAttribute(IGeneradorEnlaces generadorEnlaces)
			{
				this.generadorEnlaces = generadorEnlaces;
			}

			public override async Task OnResultExecutionAsync(ResultExecutingContext context, ResultExecutionDelegate next)
			{
				var incluirHATEOAS = DebeIncluirHATEOAS(context);

				if (!incluirHATEOAS)
				{
					await next();
					return;
				}

				var result = context.Result as ObjectResult;
				var modelo = result!.Value as AutorDTO ??
						throw new ArgumentNullException("Se esperaba una instancia de AutorDTO");

				await generadorEnlaces.GenerarEnlaces(modelo);
				await next();
			}

		}
		
		-Toca configurar los servicios correspondientes en program.cs.
		builder.Services.AddScoped<BibliotecaAPI.Servicios.V1.IGeneradorEnlaces,
            BibliotecaAPI.Servicios.V1.GeneradorEnlaces>();

		builder.Services.AddScoped<HATEOASAutorAttribute>();
		
		-En ObtenerAutorPorId....Se mete esto: [ServiceFilter<HATEOASAutorAttribute>()]
		-Se deja asi el metodo:
		[HttpGet("{id:int}", Name = "ObtenerAutorV1")] // api/autores/id
		[AllowAnonymous]
		[EndpointSummary("Obtiene autor pod Id")]
		[EndpointDescription("Obtiene un autor por Id. Incluye sus libros. Si el autor no existe, se retorna 404.")]
		[ProducesResponseType<AutorConLibrosDTO>(StatusCodes.Status200OK)]
		[ProducesResponseType(StatusCodes.Status404NotFound)]
		//[OutputCache(Tags = [cache])]
		[ServiceFilter<HATEOASAutorAttribute>()]
		public async Task<ActionResult<AutorConLibrosDTO>> Get([Description("El id del autor")] int id)
		{
			var autor = await context.Autores
				.Include(x => x.Libros)
					.ThenInclude(x => x.Libro)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (autor is null)
			{
				return NotFound();
			}

			var autorDTO = mapper.Map<AutorConLibrosDTO>(autor);

			return autorDTO;

		}
		
		-Se prueba.
		-Se va a POSTMAN:
		GET http://localhost:5065/api/v1/autores/4
		headers => IncluirHATEOAS: Y.
	
	
	168. HATEOAS y Filtros (Parte 2)
		-Se va a crear filtro para trabajar con listado de Autores CON LA ACCION DE oBTENERaUTORESv1
		-por el tema de incluirhateoas se ha aumentado su complejidad.
		Antes
		[HttpGet(Name = "ObtenerAutoresV1")] // /api/autores/
		[AllowAnonymous]
		//[OutputCache(Tags = [cache])]
		[ServiceFilter<MiFiltroDeAccion>()]
		[FiltroAgregarCabeceras("accion", "obtener-autores")]
		public async Task<ActionResult> Get([FromQuery] PaginacionDTO paginacionDTO, [FromQuery] bool incluirHATEOAS = false)
		{
			var dtos = await servicioAutoresV1.Get(paginacionDTO);

			if (incluirHATEOAS)
			{
				foreach (var dto in dtos)
				{
					GenerarEnlaces(dto);
				}

				var resultado = new ColeccionDeRecursosDTO<AutorDTO> { Valores = dtos };

				resultado.Enlaces.Add(new DatosHATEOASDTO(
					Enlace: Url.Link("ObtenerAutoresV1", new { })!,
					Descripcion: "self",
					Metodo: "GET"
					));

				resultado.Enlaces.Add(new DatosHATEOASDTO(
					Enlace: Url.Link("CrearAutorV1", new { })!,
					Descripcion: "autor-crear",
					Metodo: "POST"
					));

				resultado.Enlaces.Add(new DatosHATEOASDTO(
					Enlace: Url.Link("CrearAutorConFotoV1", new { })!,
					Descripcion: "autor-crear-con-foto",
					Metodo: "POST"
					));

				return Ok(resultado);
			}

			return Ok(dtos);
		}
		
		DESPUES
		
		
		-En GenradorDeEnlaces se mete este método:
		public async Task<ColeccionDeRecursosDTO<AutorDTO>> GenerarEnlaces(List<AutorDTO> autores)
		{
			var resultado = new ColeccionDeRecursosDTO<AutorDTO> { Valores = autores };
			var usuario = httpContextAccessor.HttpContext!.User;
			var esAdmin = await authorizationService.AuthorizeAsync(usuario, "esadmin");

			foreach (var dto in autores)
			{
				GenerarEnlaces(dto, esAdmin.Succeeded);
			}

			resultado.Enlaces.Add(new DatosHATEOASDTO(
				Enlace: linkGenerator.GetUriByRouteValues(httpContextAccessor.HttpContext!, "ObtenerAutoresV1", new { })!,
				Descripcion: "self",
				Metodo: "GET"
				));

			if (esAdmin.Succeeded)
			{
				resultado.Enlaces.Add(new DatosHATEOASDTO(
					Enlace: linkGenerator.GetUriByRouteValues(httpContextAccessor.HttpContext!, "CrearAutorV1", new { })!,
					Descripcion: "autor-crear",
					Metodo: "POST"
					));

				resultado.Enlaces.Add(new DatosHATEOASDTO(
					Enlace: linkGenerator.GetUriByRouteValues(httpContextAccessor.HttpContext!, "CrearAutorConFotoV1", new { })!,
					Descripcion: "autor-crear-con-foto",
					Metodo: "POST"
					));
			}

			return resultado;
		}
		
		-Se crea en Utilidades > V1 > HATEOASAutoresAttribute
		-Es igual que el de Autor...
		-Se mete esta signatura en IGeneradorEnlaces con Ctrl + Punto:
		public async Task<ColeccionDeRecursosDTO<AutorDTO>> GenerarEnlaces(List<AutorDTO> autores)
		
		public interface IGeneradorEnlaces
		{
			Task GenerarEnlaces(AutorDTO autorDTO);
			Task<ColeccionDeRecursosDTO<AutorDTO>> GenerarEnlaces(List<AutorDTO> autores);
		}
		
		-HATEOASAutoresAttribute
		public class HATEOASAutoresAttribute : HATEOASFilterAttribute
		{
			private readonly IGeneradorEnlaces generadorEnlaces;

			public HATEOASAutoresAttribute(IGeneradorEnlaces generadorEnlaces)
			{
				this.generadorEnlaces = generadorEnlaces;
			}

			public override async Task OnResultExecutionAsync(ResultExecutingContext context, ResultExecutionDelegate next)
			{
				var incluirHATEOAS = DebeIncluirHATEOAS(context);

				if (!incluirHATEOAS)
				{
					await next();
					return;
				}

				var result = context.Result as ObjectResult;
				var modelo = result!.Value as List<AutorDTO> ??
						throw new ArgumentNullException("Se esperaba una instancia de List<AutorDTO>");

				context.Result = new OkObjectResult(await generadorEnlaces.GenerarEnlaces(modelo));
				await next();
			}
		}
		
		-En program se mete esto:
		builder.Services.AddScoped<HATEOASAutoresAttribute>();
		
		-En AutoresController, ObtenerAutoresV1 se deja asi:
		[HttpGet(Name = "ObtenerAutoresV1")] // /api/autores/
		[AllowAnonymous]
		//[OutputCache(Tags = [cache])]
		[ServiceFilter<MiFiltroDeAccion>()]
		[FiltroAgregarCabeceras("accion", "obtener-autores")]
		[ServiceFilter<HATEOASAutoresAttribute>()]
		public async Task<IEnumerable<AutorDTO>> Get([FromQuery] PaginacionDTO paginacionDTO)
		{
			return await servicioAutoresV1.Get(paginacionDTO);
		}
		
		-Esto se borra:
		private void GenerarEnlaces(AutorDTO autorDTO){
			autorDTO.Enlaces.Add(
				new DatosHATEOASDTO(
					Enlace: Url.Link("ObtenerAutorV1", new { id = autorDTO.Id })!,
					Descripcion: "self",
					Metodo: "GET"
					));

			autorDTO.Enlaces.Add(
				new DatosHATEOASDTO(
					Enlace: Url.Link("ActualizarAutorV1", new { id = autorDTO.Id })!,
					Descripcion: "autor-actualizar",
					Metodo: "PUT"
					));

			autorDTO.Enlaces.Add(
				new DatosHATEOASDTO(
					Enlace: Url.Link("PatchAutorV1", new { id = autorDTO.Id })!,
					Descripcion: "autor-patch",
					Metodo: "PATCH"
					));

			autorDTO.Enlaces.Add(
				new DatosHATEOASDTO(
					Enlace: Url.Link("BorrarAutorV1", new { id = autorDTO.Id })!,
					Descripcion: "autor-borrar",
					Metodo: "DELETE"
					));
		}
		
		-Se prueba: GET http://localhost:5065/api/v1/autores con la cabecera.
		
	169. Resumen
		-Se ha aprendido escenarios avanzados de WebAPI que no es que se tenga que aplicar a WebAPI pero conveniente saber.
		-Se aprendió de Swagger para tener una interfaz de usuario que permita usar la webapi de forma sencilla.
		-Paginacion permite segementar rdos de l webapi.
		-Se peuden guardar imagenes en la nube y localmente.
		-El cache eprmite tener una capa de aceso rapida de datos que ayuda a aligerar la carga de BBDD y hacer la app mas rapida.
		-Los filtros ayudan a ejecutar funcionalidad relacionada a nuestras acciones pero fuera de las acciones.
		-El versionamiento es fundamental para webapi y ser vendido a terceros, pues permite que nuestros clientes tengan esta habilidad a la 
		 hora de consumir nuestro servicio.
		-HATEOAS permite indicarle a los usuarios de manera programatica lo que pueden hacer en nuestro webapi.
	
Sección 9: Pruebas Automáticas
	170. Introducción
		-Es un concepto fundamental en la ingeneiria de software.
		-Estas ayudan a verificar el correcto funcionamiento de nuestras apps.
	
	171. Limpiando el proyecto
		-Utilidades > V1 > Borrar FiltroAgregarCabecerasAttribute.cs
		-Utilidades > V1 > FiltroTiempoEjecucion.cs
		-Utilidades > V1 > MiFiltroDeAccion.cs
		-En Program se comenta lo de Redis.
		//builder.Services.AddStackExchangeRedisOutputCache(opciones =>
		//{
		//    opciones.Configuration = builder.Configuration.GetConnectionString("redis");
		//});
		
		-Descomentar esto:
		builder.Services.AddOutputCache(opciones =>
		{
			opciones.DefaultExpirationTimeSpan = TimeSpan.FromSeconds(60);
		});
		
		-Asi no hay que darle mantenimiento a lo de Redis que está en la nube.
		-Se cambia:
		ANTES
		builder.Services.AddControllers(opciones =>
		{
			opciones.Filters.Add<FiltroTiempoEjecucion>();
			opciones.Conventions.Add(new ConvencionAgrupaPorVersion());
		}).AddNewtonsoftJson();
		
		DESPUES
		builder.Services.AddControllers(opciones =>
		{
			opciones.Conventions.Add(new ConvencionAgrupaPorVersion());
		}).AddNewtonsoftJson();
		
		-Se borra:
		builder.Services.AddScoped<MiFiltroDeAccion>();
		
		-Se compila para ver donde hay errores.
		-Se cambia esto en AutoresController.
		ANTES
		[HttpGet(Name = "ObtenerAutoresV1")] // /api/autores/
		[AllowAnonymous]
		//[OutputCache(Tags = [cache])]
		[ServiceFilter<MiFiltroDeAccion>()]
		[FiltroAgregarCabeceras("accion", "obtener-autores")]
		[ServiceFilter<HATEOASAutoresAttribute>()]
		public async Task<IEnumerable<AutorDTO>> Get([FromQuery] PaginacionDTO paginacionDTO)
		{
			return await servicioAutoresV1.Get(paginacionDTO);
		}
		
		DESPUES
		[HttpGet(Name = "ObtenerAutoresV1")] // /api/autores/
		[AllowAnonymous]
		[OutputCache(Tags = [cache])]
		[ServiceFilter<HATEOASAutoresAttribute>()]
		public async Task<IEnumerable<AutorDTO>> Get([FromQuery] PaginacionDTO paginacionDTO)
		{
			return await servicioAutoresV1.Get(paginacionDTO);
		}
		
		ANTES => Se descomenta Outputcache.
		[HttpGet("{id:int}", Name = "ObtenerAutorV1")] // api/autores/id
		[AllowAnonymous]
		[EndpointSummary("Obtiene autor pod Id")]
		[EndpointDescription("Obtiene un autor por Id. Incluye sus libros. Si el autor no existe, se retorna 404.")]
		[ProducesResponseType<AutorConLibrosDTO>(StatusCodes.Status200OK)]
		[ProducesResponseType(StatusCodes.Status404NotFound)]
		//[OutputCache(Tags = [cache])]
		[ServiceFilter<HATEOASAutorAttribute>()]
		public async Task<ActionResult<AutorConLibrosDTO>> Get([Description("El id del autor")] int id)
		{
			var autor = await context.Autores
				.Include(x => x.Libros)
					.ThenInclude(x => x.Libro)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (autor is null)
			{
				return NotFound();
			}

			var autorDTO = mapper.Map<AutorConLibrosDTO>(autor);

			return autorDTO;

		}
		
		ANTES
		[ApiController]
		[Route("api/v1/autores")]
		[Authorize(Policy = "esadmin")]
		[FiltroAgregarCabeceras("controlador", "autores")]
		public class AutoresController : ControllerBase
		
		
		DESPUES
		[ApiController]
		[Route("api/v1/autores")]
		[Authorize(Policy = "esadmin")]
		public class AutoresController : ControllerBase
		
		ANTES
		[HttpGet] // /api/autores/
		[AllowAnonymous]
		//[OutputCache(Tags = [cache])]
		[ServiceFilter<MiFiltroDeAccion>()]
		[FiltroAgregarCabeceras("accion", "obtener-autores")]
		public async Task<IEnumerable<AutorDTO>> Get([FromQuery] PaginacionDTO paginacionDTO)
		{
			return await servicioAutoresV1.Get(paginacionDTO);
		}
		
		DESPUES
		[HttpGet] // /api/autores/
		[AllowAnonymous]
		[OutputCache(Tags = [cache])]
		public async Task<IEnumerable<AutorDTO>> Get([FromQuery] PaginacionDTO paginacionDTO)
		{
			return await servicioAutoresV1.Get(paginacionDTO);
		}
		
		ANTES V2
		[ApiController]
		[Route("api/v2/autores")]
		[Authorize(Policy = "esadmin")]
		[FiltroAgregarCabeceras("controlador", "autores")]
		public class AutoresController : ControllerBase
		
		DESPUES
		[ApiController]
		[Route("api/v2/autores")]
		[Authorize(Policy = "esadmin")]
		public class AutoresController : ControllerBase
		
		-Se aacab de compilar y listo.
		
	172. ¿Qué es una prueba?
		-De ascuerdo con la RAE, es un ensayo o experimento que se hace de algo, para saber cómo resultará en su forma definitiva.
		-La finalidad de hacer una prueba es conocer el resultado de un conjunto de acciones.
		-Cuando escribimos software es para un proposito, para resolver un problema. por ende, es natural que
		 después de escribir el software queramos comprobar que resuelve el problema que queramos que resuelva.
		-Para esto, se prueba el software que consiste en utilizarlo para evr que funciona.
		-Esta prueba varia según el tipo de software.
		-Para probar un software hay que usarlo: sea pagina web, app mopvil, app cpnsola o webServie.
		-probar la app implica correrla en un dispositiva y usarla.
		-Salvo app triviales, las apps del mundo real tienden a resolver variso problema sy tienen varias opciones.
		-Para probar el software hay que probar todas als funcionalidades de dicho software.
		-Esto es tedioso y propenso a errores. 
		-probar todas las funcionalidades del software lleva muchas horas...
		-Al tiempo que lo hacemos podemos olvidarnos de ciertas pruebas.
		-Esto se resuelve haciendo pruebas automáticas.
	
	173. Pruebas Automáticas
		-Si una prueba es un ensayo que se hace de algo para saber cómo resultará en su forma definitiva, una prueba atomatica consiste en automatizar ese ensayo.
		-Es un software que prueba nuestro software.
		-Una de las principales ventajas de  las pruebas automáticas es que ellas preuban todo lo que le digamos que prueben, todas las veces que queramos.
		-Eso da la confianza de cambiar código del software y saber que pulsando un boton podemos probar de forma automatica nuestra app para ver que siga funcionando bien.
		-Pasa que haces cmabio en software y la app deja de funcionar.
		-Con pruebas automaticas se ven fallos de forma automatica.
		
		** CUALIDADES DE UNA BUENA PRUEBA AUTOMÁTICA **
		-Una prueba automática debe ser razonablemente consistente. El resultado de una rueba solo cmabia cuando el software cambia.
		 Si corremos una prueba y esta es exitosa y sin hacer ningun cambio en el software, volvemos a hacer la misma prueba, esta debería ser exitosa.
		 Puede haber ocasiones donde existen variaciones en el rdo de una prueba sin que software haya cambiado. Esto puede suceder cuando se depende de servicio
		 externo para la prueba como un WebService.
		 
		-Una prueba no depende de otra. Son independientes.
		-Una buena prueba no realiza cambios externos. Una prueba no debe realziar cambios en el sistema. Debe probar y dejar la prueba coo estaba.
		 En algunos casos, esto n es tan viable y se acepta cierta flexibilidad. por ejemplo, cuando vamos a hacer prueba de bbdd, no es viable en cada prueba 
		 automatica que  cree y destruya la bbdd. Eneste caso, podemos ser flexibles y que se construya una bbdd durante la corrida de las pruebas
		 y que dicha bbdd sea destruida al final de la ejecucion de suite de pruebas.
		 Una prueba automatica es una funcion la cual prueba alguna parte de nuestra app.
		 Si tenemos software de ventas, un ejemplo de una prueba automatica puede ser una funcion la parte de la app donde se crea un producto.
		 Otra prueba automatica podria ser una funcion que pruebe la parte del pago de los productos que quiera el usuario final comprar.
		-Al conjunto de pruebas automáticas se le llama suite de pruebas.
		
		** PARTES DE UNA PRUEBA AUTOMÁTICA **
		-Se divide en tres partes o etapas.
		-Preparar, probar y verificar.
		-Preparar. La priemra parte de una prueba prepara el ambiente para poder desarrollar la prueba. Esta preparación puede consistir en 
		 generar la data de prueba, generar objetos de prueba...
		-Probar. En esta etaopa ejecutamos la dfuncionalidad de nuestro software la que se quiere probar. Esta prueba peude consistir en ejecutar una funcion, disparar un proceso
		 que interactue con una pagina web como si fuera un usuario....
		-Verificar. Se queire verificar que obtuvimos de la prueba el rdo esperado. 
		
		** EJEMPO DE PRUEBA AUTOMÁTICA A NIVEL CONCEPTUAL **
		-Supongtamos que trabaja,os para un banco y tenemos la tarea de probar un software que hace transferencias bancarias entre dos pruebas.
		-Cual es una forma de preaprar una prueba automatica que verifique una transferencia exitosa??
		-Recordamos las tres etpas.
		-Preparación. para probar una transferencia entre dos cuentas, necesitamos dos cuenats y una de ellas con saldo. En esta etapa, hay que preparar dos cuenats ficticias.
		 Quizas se necesite una BBDD real o ficticias.
		-Probar. Dado que ya tenemos als dos cuentas ahora necesitamos ejecutar la funcion la cual realzia la accion que queremos probar. Para nuestro caso, una fucnion
		 que toem como parámetros las dos cuentas y el monto a transferir.
		-Verificar. necesitamos una manera de comprobar que el dinero ha apsado de una cuenta a otra. Dependiendo de cómo funcione nuestro software, esto quizas se pueda ver a nivel de las cuentas
		 en BBDD.
		
		-De un modo u otro, las pruebas que se hagan tendrán una estructura similar a esta.
		-Sin embargo, no todas als pruebas son iguales.
		-Existen pruebas que prueban partes aisladas del software.
		-Existen pruebas que trabajan con distintas partes de la app de forma simultánea.
		-Existen pruebas unitaria, pruebas de integración y pruebas de extremo a extremo.
		
	174. Pruebas Unitarias
		-Una prueba unitaria se encarga de probar una undiad de trabajo.
		-Una caracteristica de estas pruebas es que intentan probar una pequeña y aislada parte del software sin importarle las dependencia externas.
		-Estas son bastante rápidas.
		-Es normal ver tests suites copmpuestos de alta proporción de pruebas unitarias.
		-Una pryueba unitaria tiende a probar una función de una clase.
		-Es nromal escribir bastantes pruebas unitarias las cuales verifican disitntos comportamentos de una funcion.
		
	175. Nuestra Primera Prueba Automática
		-Se va a crear un proyecto de pruebas para colocar las pruebas automáticas.
		-hay avrias opciones pero se va a crear MSTest.
		-Desde la solucion click derecho nuevo proyecto.
		-Se le llama BibliotecaAPITests.
		-Se agrega una referencia del proeycto de pruebas al proyecto de BibliotecaAPi para  que asi yo peuda hacer refrencia a als clases
		 que se encuentran en BibliotecaAPI y asi poder probarlas.
		-Click derecho > Añadir Referencia de proyecto..
		-Se va a la carpeta de Validaciones y lo que se quiere probar es la clase PrimeraLetraMayuscualAttribute.
		-Es una clase simple con laa que se puede empezar a probar.
		-ya luego se prueban cosas mas complejas...
		-Es una clase que valdia que la priemra letra de un string sea mayuscula.
		-Hay code que se peude ejecutar si el valor es nulo o si es vacio....
		-Hay otro code que se peude ejecutar en el caso que la priemra letra del string no se mayus.
		-Y luego el return ultimo que se ejecuta si la letra es mayus.
		-Hay avrios escenarios y hay que proabr cada escenario que se encuentra en el metodo para asi probar 
		 que funciona correctamente.
		
		-Se va a Test1 que viene por defecto y representa el emtodo una prueba. 
		-Ene sos métodos de prueba se peuden crear las pruebas automaticas.
		-Se borra ese fichero y se crea carpeta PruebasUnitarias.
		-Se imita la estructura que se tiene en BibliotecaAPI.
		-meto por ejemplo la carpeta de Validaciones y dentro la clase de prueba. pro convencion el nombre de una clase de pruebas e sigual al nombre de la clase que se va a probar
		 terminado en Test o pruebas: PrimeraLetraMayusculaAttriburePruebas
		-El nombre de la prueba debe describir claramente lo que se va a probar.
		-Se usa el nombre del emtodo que se va a probar IsValid_RetornaExitoso_SiValueEsVacio. Es el nombre del metodo + lo que speras que ocuraa + bajo qué condicion 
		 esto que quiero que ocurra va a ocurrir.
		-retorna exitoso si value es vacio.
		-Una prueba es preparacion, prueba y verificacion. 
		[TestClass]
		public class PrimeraLetraMayusculaAttributePruebas
		{
			[TestMethod]
			public void IsValid_RetornaExitoso_SiValueEsVacio()
			{
				//Preparación

				//Prueba

				//Verificación
			}
		}
		
		-En prepaarcion se instancia la clase que quiero probar. Se tien parametro VallidationContext que se necesita instanciar.
		-Se pone en la medida que se pueda string.Empty. Asi la intencion es que fuera valor vacio y que no se pudo por descuido.
		-Para realizar la prueba, se ve que el emtodo es protected y no se puede usar desde fuera de la clase.
		-Se usa metodo especial que permite invocar el IsValid.
		-No se puede invocar directamente. Se usa GetValidationResult.
		-Para la verificacion se sua Assert para realziar verificaciones y se valdia que el valor esperado sea igual que lo que se obtiene.
		-Sino son iguales, la pruyeba falla.
		-Si son iguales, prueba exitosa.
		[TestMethod]
		public void IsValid_RetornaExitoso_SiValueEsVacio()
		{
			//Preparación
			var primeraLetraMayusculaAttribute = new PrimeraLetraMayusculaAttribute();
			var validationContext = new ValidationContext(new object());
			var value = string.Empty;

			//Prueba
			var resultado = primeraLetraMayusculaAttribute.GetValidationResult(value, validationContext);

			//Verificación
			Assert.AreEqual(expected: ValidationResult.Success, actual: resultado);
		}
		
		-Para ejecutar: test > Text Explorer > Se tiene ahi las pruebas automaticas. 
		-Se ejecuta todo y se ve que es exitoso.
		-Se mete esto para que falle: Assert.AreEqual(expected: 1, actual: 2);
		-otra forma click derecho y correr pruebas....
		
	176. Ejecutando una Misma prueba con Distintos Valores
		-Se va a PrimeraLetraMayusculaAttribute.
		-Cuando value es vacio se nos retorna exitoso, pero si value es nulo lo mismo debe ocurrir y hay que probarlo.
		[TestMethod]
		public void IsValid_RetornaExitoso_SiValueEsNulo()
		{
			//Preparación
			var primeraLetraMayusculaAttribute = new PrimeraLetraMayusculaAttribute();
			var validationContext = new ValidationContext(new object());
			string value = null!;

			//Prueba
			var resultado = primeraLetraMayusculaAttribute.GetValidationResult(value, validationContext);

			//Verificación
			Assert.AreEqual(expected: ValidationResult.Success, actual: resultado);
			// Assert.AreEqual(expected: 1, actual: 2);
		}
		
		
		-Esto no es lo mejor porque se repite mucho code entre las dos pruebas. Es casi idem.
		-Existe mejor manera de hacer esto y es usando el atributo DataRow.
		-Con DataRow se peude parametrizar algunos valores de mi prueba automática para asi poder ejecutar la misma
		 prueba con distitnos valores.
		-Se colocan los mismos valores que quiero que tenga mi value en DataRow. se mete como argumento de la funcion y lo que se pasa por datarow se le pasa a al argumento.
		-Se peude correr la funcion tres veces. Una pro cada valor del DataRow.
		-Se ve que la prueba automatica se ha tranformado en tres.
		-En DataRow no se peude poner String.Empty porque no pidemos usar ese campo de strung  en atributo...
		ANTES
		[TestMethod]
		public void IsValid_RetornaExitoso_SiValueEsVacio()
		{
			//Preparación
			var primeraLetraMayusculaAttribute = new PrimeraLetraMayusculaAttribute();
			var validationContext = new ValidationContext(new object());
			var value = string.Empty;

			//Prueba
			var resultado = primeraLetraMayusculaAttribute.GetValidationResult(value, validationContext);

			//Verificación
			Assert.AreEqual(expected: ValidationResult.Success, actual: resultado);
			// Assert.AreEqual(expected: 1, actual: 2);
		}
		
		DESPUES
		[TestMethod]
		[DataRow("")]
		[DataRow("   ")]
		[DataRow(null)]
		public void IsValid_RetornaExitoso_SiValueEsVacioONUlo(string value)
		{
			//Preparación
			var primeraLetraMayusculaAttribute = new PrimeraLetraMayusculaAttribute();
			var validationContext = new ValidationContext(new object());

			//Prueba
			var resultado = primeraLetraMayusculaAttribute.GetValidationResult(value, validationContext);

			//Verificación
			Assert.AreEqual(expected: ValidationResult.Success, actual: resultado);
			// Assert.AreEqual(expected: 1, actual: 2);
		}
		
		-Se ejecuta prueba.
		
	177. Agregando Más Pruebas Unitarias
		-Ya hemos probado que si el valor es vacio, blanco un espacio en blanco, retorna exitoso.
		-Se va a evr que si la priemra letra delñ String es mayuscula, se retorna exitoso igual.
		-Se copia y se pega el otro metodo pero solo tengo un DataRow.
		-Se corren todas las pruebas aunque puede ejecutarse solo una.
		-Cambiar esto:
		ANTES
		[TestMethod]
		[DataRow("")]
		[DataRow("   ")]
		[DataRow(null)]
		public void IsValid_RetornaExitoso_SiValueEsVacioONUlo(string value)
		{
			//Preparación
			var primeraLetraMayusculaAttribute = new PrimeraLetraMayusculaAttribute();
			var validationContext = new ValidationContext(new object());

			//Prueba
			var resultado = primeraLetraMayusculaAttribute.GetValidationResult(value, validationContext);

			//Verificación
			Assert.AreEqual(expected: ValidationResult.Success, actual: resultado);
			// Assert.AreEqual(expected: 1, actual: 2);
		}

		[TestMethod]
		[DataRow("Felipe")]
		public void IsValid_RetornaExitoso_SiLaPrimeraLetraEsMayusculas(string value)
		{
			//Preparación
			var primeraLetraMayusculaAttribute = new PrimeraLetraMayusculaAttribute();
			var validationContext = new ValidationContext(new object());

			//Prueba
			var resultado = primeraLetraMayusculaAttribute.GetValidationResult(value, validationContext);

			//Verificación
			Assert.AreEqual(expected: ValidationResult.Success, actual: resultado);
			// Assert.AreEqual(expected: 1, actual: 2);
		}
		
		DESPUES
		[TestMethod]
		[DataRow("")]
		[DataRow("   ")]
		[DataRow(null)]
		[DataRow("Felipe")]
		public void IsValid_RetornaExitoso_SiValueNoTieneLaPriemraLetraMinuscula(string value)
		{
			//Preparación
			var primeraLetraMayusculaAttribute = new PrimeraLetraMayusculaAttribute();
			var validationContext = new ValidationContext(new object());

			//Prueba
			var resultado = primeraLetraMayusculaAttribute.GetValidationResult(value, validationContext);

			//Verificación
			Assert.AreEqual(expected: ValidationResult.Success, actual: resultado);
			// Assert.AreEqual(expected: 1, actual: 2);
		}
		
		-Con ese titulo se cubren todos esos escenarios y no repetimos code.
		-Se prueba de nuevo.
		
		-Se hace prueba con Rdo distitno.
		-Se copia y se pega la prueba.
		[TestMethod]
		[DataRow("felipe")]
		public void IsValid_RetornaError_SiValueTieneLaPrimeraLetraMinuscula(string value)
		{
			//Preparación
			var primeraLetraMayusculaAttribute = new PrimeraLetraMayusculaAttribute();
			var validationContext = new ValidationContext(new object());

			//Prueba
			var resultado = primeraLetraMayusculaAttribute.GetValidationResult(value, validationContext);

			//Verificación
			Assert.AreEqual(expected: "La primera letra debe ser mayúscula", actual: resultado!.ErrorMessage);
		}
		
		-Se corren las pruebas.
		
	178. Probando EF Core
		-La aplicación usa EF Core en casi todo los controladores.
		-Para probar un controlador hay que lidiar con EF Core.
		-Varias formas de proceder:
		
		-Opción 1: No usar EF Core en nuestros controladores, sino usar interfaz.
		 Asi, podemos probar el codigo de las acciones sin tocar EF Core necesariamente.
		
		-Opción 2: Usar un proveedore en memoria
		 permite tener una bbdd en memoria la cual es rapida y por tanto, nos permite hacer pruebas que involucren a EF Core.
		-Ninguna de las dos opciones es mejro que la otra.
		-Es un tema de preferencia.
		-Se prefiere la segund aocion. USaremos un proveedor en memoria para no lidiar con una BBDD real con EF Core en pruebas automaticas.
		
	179. Preparándose para probar Controladores
		-Se va a crear una clase auxiliar para trabajar comodamente con EF Core para pruebas automaticas.
		-Se instala el proveedor en memoria en el proyecto de Tests
		-Se busca este paquete: Microsoft.EntityFrameworkCore.InMemory
		-Esto permite usar EF Core en memoria.
		-Se crea clase en ua capeta que se llamará Utilidades.
		-El método va a ser protected porque solo quiero usarlo desde clases derivadas.
		-Este metodo permite de manera sencilla el DbContext.
		-Pasamos el nombre porque podemos tener difernetes bases de datos en memoria que la diferencia es su nmbre.
		 Por tanto, si quiero obtener varias veces un ApplicationDbContext que se corresponda con bbdd especifica pues simplemente le paso
		 el nombre.
		 
		-Si quiero tener dos bbdd difernetes, pues le paso dos nombres distintos.
		-Retorno el dbContext que voy a poder utilizar desde cualquier metodo que herede de esa clase. Es decir, desde cualquier prueba automatica que herede de esa clase.
		-Otro metodo se crea para configruar AutoMapper.
		public class BasePruebas
		{
			protected ApplicationDbContext ConstrirContext(string nombreBD)
			{
				var opciones = new DbContextOptionsBuilder<ApplicationDbContext>()
					.UseInMemoryDatabase(nombreBD).Options;

				var dbContext = new ApplicationDbContext(opciones);
				return dbContext;
			}

			protected IMapper ConfigurarAutoMapper()
			{
				var config = new MapperConfiguration(opciones =>
				{
					opciones.AddProfile(new AutoMapperProfiles());
				});

				return config.CreateMapper();
			}
		}
		
	180. Probando el Controlador de Autores - Obtener por Id
		-Se va a probar el controlador Autores de obtener el autor por su id.
		-Nos enfocamos en la V1 del controlador.
		-El metodo devuelve un autor sie ste existe y sino existe se retorna un 404.
		-Se tiene que probar ambos escensarios. Este controlador de Autores tiene muchas dependencias y entre ellas 
		 se tiene AppilcatioDbCOntext y AutoMapper y ambas son utilizadas en este metodo.
		-Por eso, era importante crear la claseBasePruebas donde de forma  sencilla se obtiene instancia de ApplicationDbContext y IMapper.
		-En pruebasUnitarias, nuevo Folder > Controllers > V1
		-Se crea AutoreControllersPruebas.
		-Se hereda de ClasePruebas.
		-Se usa clase base para crear el ApplicationDbContext.
		-Se genera un nombre aleatorio para la BBDD.
		-Hay otras dependencias que teiene el controlador de Autores.
		-Al AutoresController en algunas dependencias se le podría apsar nulo porque se que mi metodo de ObtenerPorId no uso esas deendencias.
		-Como se que en la BBDD no hay un autor con Id = 1? Porque se acaba de crear el contexto.
		-Esa BBDD no existe porque me  acabo de inventar su nombre.
		-La tabla autores estarña vacía.
		-Estamos realziando la prueba adecuada.
		[TestClass]
		public class AutoresControllersPruebas: BasePruebas
		{
			[TestMethod]
			public async Task get_Retorna404_CuandoAutorConIdNoExiste()
			{
				//Preparación
				var nombreBD = Guid.NewGuid().ToString();
				var context = ConstruirContext(nombreBD);
				var mapper = ConfigurarAutoMapper();
				IAlmacenadorArchivos almacenadorArchivos = null!;
				ILogger<AutoresController> logger = null!;
				IOutputCacheStore outputCacheStore = null!;
				IServicioAutores serviciosAutores = null!;

				var controller = new AutoresController(context, mapper, almacenadorArchivos, logger, outputCacheStore, serviciosAutores);

				//Prueba
				var respuesta = await controller.Get(1);

				//Verificación
				var resultado = respuesta.Result as StatusCodeResult;
				Assert.AreEqual(expected: 404, actual: resultado!.StatusCode);
			}
		}
		
		-Se corren prueba sy va OK.
		-La seghunda prueba es verificar que xiste un autor cuando existe de verdad.
		-Copy/paste.
		-No es correcto crear ela utor con cun post en al prueba.
		-Si hay fallo, no quiero que esta prueba automatica que prueba el GET del autor por id, falle por un  fallo en POST. Si falla, que sea por error en el metodo 
		 que queiro probar, no en un metodo que uso de forma auxiliar para culmianr la rpeparacion
		-Es mas estrategico crear la tabla de autores. Es decir, insertarlos y asi consumir el emtodo GET.
		-Si queiro el POST, creo prueba automatica que cree en POST.
		-Es recomendable no usar el mismo contexto con el que se crearon los autores que con el que se van a consultar.
		-En respuesta.Value que teng AutorConLibroDTO y puedo validar el Id del Autor que estoy obteniendo.
		 [TestMethod]
		 public async Task get_Retorna404_CuandoAutorConIdExiste()
		 {
			 //Preparación
			 var nombreBD = Guid.NewGuid().ToString();
			 var context = ConstruirContext(nombreBD);
			 var mapper = ConfigurarAutoMapper();
			 IAlmacenadorArchivos almacenadorArchivos = null!;
			 ILogger<AutoresController> logger = null!;
			 IOutputCacheStore outputCacheStore = null!;
			 IServicioAutores serviciosAutores = null!;

			 context.Autores.Add(new Autor { Nombres = "Felipe", Apellidos = "Gavilán" });
			 context.Autores.Add(new Autor { Nombres = "Claudia", Apellidos = "Rodríguez" });

			 await context.SaveChangesAsync();

			 var context2 = ConstruirContext(nombreBD);

			 var controller = new AutoresController(context2, mapper, almacenadorArchivos, logger, outputCacheStore, serviciosAutores);

			 //Prueba
			 var respuesta = await controller.Get(1);

			 //Verificación
			 var resultado = respuesta.Value;
			 Assert.AreEqual(expected: 1, actual: resultado!.Id);
		 }
		 
		-Lanzamos pruebas.
		
	181. probando la Creación de un Autor
		-Hay que recordar que el metodo de crear un autor hace uso de outputCacheStore.
		-la dependencia ahora la estamos pasando como nula.
		-La linea de codigo daria error si la pasamos como nulo.
		-Daría error de referencia nula.
		-Se debe ofrecer una implementación de IOuputCahceStore para evitar errores.
		-Se peude usar una loibreria como ESubstitute o algo así.
		-Esto permite crear implementaciones de interfaces de una manera rápida para pruebas.
		-Otra forma es crear nuestra propia implementación.
		-Ambas son válidas.
		-La elección suele ser un tema de preferencia.
		-Debido al uso tan simple que le damos al IOuputCacheStore, 
		-Se va a usar una implementación personalizada.
		-En el siguiente video se verá cómo usar ESubstitute.
		-Se va a crear una clase que implemente la interfaz IOutputCacheStore.
		-Se va a ir a la carpeta Utilidades y se crea carpeta que se llame Dobles.
		-En el contexto de pruebas automáticas los dobles son clase, sitpos...que permiten suplantar otro tipo
		-Se va a usar implementación falsa del iOutputCacheStore para suplantar esa dependencia que tiene mi clase y asi poder controlarla.
		-Se le llama OutputCacheStoreFalso.
		-Se implementa la interfaz y lo bueno es que no tengo que haer implementación realista de esta clase.
		-ValueTask.CompletedTask quiere decir que estoy retornando que la tarea ha sido completada.
		-No hay que hacer nada porque no quiero probar nada con respecto a OutputCacheStore.
		-Simplemente, se quiere evitar que en el post de CrearAutor de error outputCacheStore.EvictByTagAsync....
		public class OutputCacheStoreFalso : IOutputCacheStore
		{
			public ValueTask EvictByTagAsync(string tag, CancellationToken cancellationToken)
			{
				return ValueTask.CompletedTask;
			}

			public ValueTask<byte[]?> GetAsync(string key, CancellationToken cancellationToken)
			{
				throw new NotImplementedException();
			}

			public ValueTask SetAsync(string key, byte[] value, string[]? tags, TimeSpan validFor, CancellationToken cancellationToken)
			{
				throw new NotImplementedException();
			}
		}
		
		-Se va hacia AutoresControllerPruebas y se crea una nueva prueba automática.
		-Ojo con el casteo que podría devolver nulo....
		-Se va a ver por qué se crea un contexto nuevo peroe s para evitar trabajar con contexto que fue alterado en el post y se crea uno nuevo y se peude trabajar con uno nuevo.
		[TestMethod]
		public async Task Post_DebeCrearAutor_CuandoEnviamosAutor()
		{
			//Preparación
			var nombreBD = Guid.NewGuid().ToString();
			var context = ConstruirContext(nombreBD);
			var mapper = ConfigurarAutoMapper();
			IAlmacenadorArchivos almacenadorArchivos = null!;
			ILogger<AutoresController> logger = null!;
			IOutputCacheStore outputCacheStore = new OutputCacheStoreFalso();
			IServicioAutores serviciosAutores = null!;

			var nuevoAutor = new AutorCreacionDTO { Nombres = "nuevo", Apellidos = "autor" };

			var controller = new AutoresController(context, mapper, almacenadorArchivos, logger, outputCacheStore, serviciosAutores);

			//Prueba
			var respuesta = await controller.Post(nuevoAutor);

			//Verificación
			var resultado = respuesta as CreatedAtRouteResult;
			Assert.IsNotNull(resultado);

			var contexto2 = ConstruirContext(nombreBD);
			var cantidad = await contexto2.Autores.CountAsync();
			Assert.AreEqual(expected: 1, actual: cantidad);
		}
		
		-Se prueba.
		
	182. Verificando que usemos una dependencia
		-Se usó una clase personalziada para crearun doble que suplante el OutputCacheStore.
		-Esto permitió ignorar dicha dependencia y probar lo que queríamos probar que era la creación de un Autor.
		-Existe la posibilidad de que deseemos verificar que a la dependencia se le haya dado uso.
		-Vamos a AuotresController y en el get de ObtenerAutroes y vemos que estamos suando el servicioAutores. 
		-Dado que estamos haciendo pruebas unitarias, me quiero concentrar en probar el controlador de Autores.
		-Por tanto, no me interesa probar el IServicioAutroes o su implementación sino ver que funciona bien.
		-Ahora la funcion es bien limitada, es simplemente invocar el get de ServicioAutores.
		-Se quiere probar que cuando se invoca este metodo, se hace llamado al get este y se le pasa la paginacionDTO.
		-Se puede crear doble del IServicoiAutores. Y en esa implementación cuando invoque el GET pues puedo guardar propeidad interna que he hecho a ese llamado
		 para luego desde la prueba automática verificar que dicho llamado fue hecho.
		-Se puede usar una librería que hace eso por nosotros.
		-Es mejor asi porque mañana ademas de querer usar esa funcionalidad de que una dependencia fue llamada para servicioAutores, quizas
		 luego se quiera lo mismo para Almecandor de Archivos o el IOuputCacheStore y no se quiere implementar manualmente, sino mejor una librería
		 que lo haga por mi.
		-La librería que se usara´es NSubstitute.
		-Se va a los nuggets de Tests y se mete.
		-Con esto basicamente lo que se crea es un mock.
		-Un mock es un doble, es decir, es una forma de suplantar un servicio o clase o interfaz pero
		 que incluye funcioanldiad como que si fue lalamdo con paginacionDTO o fue llamado una vez, dos....
		-Para la prueba se va a usar un doble pero usando NSubstitute.
		-Eso tiene la funcionaldiad de permititrme saber si el método GET fue invocado, si se le mandó paginacionDTO....
		[TestMethod]
		public async Task Get_DebeLlamarGetDelServicioAutores()
		{
			//Preparación
			var nombreBD = Guid.NewGuid().ToString();
			var context = ConstruirContext(nombreBD);
			var mapper = ConfigurarAutoMapper();
			IAlmacenadorArchivos almacenadorArchivos = null!;
			ILogger<AutoresController> logger = null!;
			IOutputCacheStore outputCacheStore = null!;
			IServicioAutores servicioAutores = Substitute.For<IServicioAutores>();

			var controller = new AutoresController(context, mapper, almacenadorArchivos, logger, outputCacheStore, serviciosAutores);

			var paginacionDTO = new PaginacionDTO(2, 3);

			//Prueba
			await controller.Get(paginacionDTO);

			//Verificación
			await servicioAutores.Received(1).Get(paginacionDTO);
		}
		
		-Se prueba y va OK.
		-Se va a AutoresController y se comprueba que esto tira comentando el return:
		[HttpGet(Name = "ObtenerAutoresV1")] // /api/autores/
		[AllowAnonymous]
		[OutputCache(Tags = [cache])]
		[ServiceFilter<HATEOASAutoresAttribute>()]
		public async Task<IEnumerable<AutorDTO>> Get([FromQuery] PaginacionDTO paginacionDTO)
		{
			 return new List<AutorDTO>();
			// return await servicioAutoresV1.Get(paginacionDTO);
		}
		
		-Ahora se corre la prueba y da error y se ve en el error:
		Actually received no matching calls
		
		-El metodo no recivió mninguna llamada que tuviera el parametro paginacionDTO con pagina 2 y records 3
		-Ahora se prueba esto:
		[HttpGet(Name = "ObtenerAutoresV1")] // /api/autores/
		[AllowAnonymous]
		[OutputCache(Tags = [cache])]
		[ServiceFilter<HATEOASAutoresAttribute>()]
		public async Task<IEnumerable<AutorDTO>> Get([FromQuery] PaginacionDTO paginacionDTO)
		{
			var nuevaPaginacionDTO = new PaginacionDTO(1, 1);
			return await servicioAutoresV1.Get(nuevaPaginacionDTO);
		}
		
		-Da error: 
		NSubstitute.Exceptions.ReceivedCallsException: Expected to receive exactly 1 call matching:
			Get(PaginacionDTO { Pagina = 2, RecordsPorPagina = 3 })
		Actually received no matching calls.
		Received 1 non-matching call (non-matching arguments indicated with '*' characters):
			Get(*PaginacionDTO { Pagina = 1, RecordsPorPagina = 1 }*)
		
        -Recibió una llamada pero es una llamada que no coincidía con el parametro que esperaba porque se esperaba que paginacionDTO tuviera pagina 2 y recordPorPagina = 3.
		-Pero recibió 1 y 1...
		-Por tanto, se descubre que se cometió un error de pasarle el parámetro incorrecto al método GET.
		
		-Es util que puedo verificar que mis dependencias aunque no me interese su funcionamiento interno en elcontexto de una prueba unitaria,
		 si que garantizo que sea llamada la cantidad de vecees correcta y se pase arguento correcto.
		 
		-Se deja como estaba.
		[HttpGet(Name = "ObtenerAutoresV1")] // /api/autores/
		[AllowAnonymous]
		[OutputCache(Tags = [cache])]
		[ServiceFilter<HATEOASAutoresAttribute>()]
		public async Task<IEnumerable<AutorDTO>> Get([FromQuery] PaginacionDTO paginacionDTO)
		{
			return await servicioAutoresV1.Get(paginacionDTO);
		}
		
	183. ¿Por qué usar varios contextos? - Evitando Falsos Positivos
		-A veces cuando se hace una prueba a veces es aconsejable usar un segundo contexto.
		-Como con un caso que se crean los autore sy en otro contexto se pasa a AutoresController.
		-Asi, se logra tener un ambiente de pruebas parecido a PROD.
		-En segundo lugar, se evitan falsos positivos.
		-Con respecto a tener un ambiente de pruebas similar a PROD, eso e simportante porque en vida real el contexto que 	crea los datos es difernete al contexto
		 que los consulta de BBDD. Eso es porque tipicamente esas operacioens se hacen en peticiones HTTP difernetes.
		-Por tanto, es ideal, dentro de lo posible, imitar el ambiente de PROD durante pruebas.
		-Es conveniente tener dos contextos distitnos, uno para crea ry otro para lectura.
		-Lo de evitar falsos positivos es mas profundo.
		-Falso positivo es una prueba de que a pesar de que codigo no funcione correctamente, la prueba pasa.
		-Se va a probar la funcion que permite obtener autor por Id. 
		-En esta funcion se estan incluyendo lo libros.
		-Se quiere probar que si un autor tiene dos libros, se devuelve dficho autor con sus libros.
		-Se clona el metodo, Get_RetornaAutor_CuandoAutorConIdExiste
		-Se peinsa que no se sabe que es buen prática usar un contexto distinto y se va a aplicar el mismo contexto para lectura y escritura.
		-Tanto para agregar el autor como para leer los autores.
		[TestMethod]
		public async Task Get_RetornaAutorConLibros_CuandoAutorTieneLibros()
		{
			//Preparación
			var nombreBD = Guid.NewGuid().ToString();
			var context = ConstruirContext(nombreBD);
			var mapper = ConfigurarAutoMapper();
			IAlmacenadorArchivos almacenadorArchivos = null!;
			ILogger<AutoresController> logger = null!;
			IOutputCacheStore outputCacheStore = null!;
			IServicioAutores serviciosAutores = null!;

			var libro1 = new Libro { Titulo = "Libro 1" };
			var libro2 = new Libro { Titulo = "Libro 2" };

			var autor = new Autor()
			{
				Nombres = "Felipe",
				Apellidos = "Gavilán",
				Libros = new List<AutorLibro>
				{
					new AutorLibro{Libro = libro1},
					new AutorLibro{Libro = libro2},
				}
			};

			context.Add(autor);

			await context.SaveChangesAsync();

			// var context2 = ConstruirContext(nombreBD);

			var controller = new AutoresController(context, mapper, almacenadorArchivos, logger, outputCacheStore, serviciosAutores);

			//Prueba
			var respuesta = await controller.Get(1);

			//Verificación
			var resultado = respuesta.Value;
			Assert.AreEqual(expected: 1, actual: resultado!.Id);
			Assert.AreEqual(expected: 2, actual: resultado.Libros.Count);
		}
		
		-Se ejecuta y va OK.
		-Voy a comentar el Include y es correcto que no me retorne los libros en el metodo GET de ObtenerAutorV1 de AutoresController.
		var autor = await context.Autores
			//.Include(x => x.Libros)
			//    .ThenInclude(x => x.Libro)
			.FirstOrDefaultAsync(x => x.Id == id);
		
		-Como puede ser que al probar esa prueba sea exitosa si le estoy dciiendo que espera obteenr los dos libros y vienene de ese GET que not eine el include??
		-See sta usando el contexto contaminado y ese contexto ya sabe de la existencia de Autor y Lirbos ye sta en memoria. Por tanto, incluso aunque no incluyamos el include
		 no importa porque el contexto ya lo sabe y lo tiene en memoria.
		 y por eso nos lo devuelve. Y por eso hay que suar un contexto nuevo para evitar esa contaminacion.
		 del contexto que provoca un falso positivo.
		 
		-Se descomenta el context2 y teniendo lo del Include comentado de ObtenerAutorV1 falla.
		-Se descomenta context2 y se le pasa context 2.
		[TestMethod]
		public async Task Get_RetornaAutorConLibros_CuandoAutorTieneLibros()
		{
			//Preparación
			var nombreBD = Guid.NewGuid().ToString();
			var context = ConstruirContext(nombreBD);
			var mapper = ConfigurarAutoMapper();
			IAlmacenadorArchivos almacenadorArchivos = null!;
			ILogger<AutoresController> logger = null!;
			IOutputCacheStore outputCacheStore = null!;
			IServicioAutores serviciosAutores = null!;

			var libro1 = new Libro { Titulo = "Libro 1" };
			var libro2 = new Libro { Titulo = "Libro 2" };

			var autor = new Autor()
			{
				Nombres = "Felipe",
				Apellidos = "Gavilán",
				Libros = new List<AutorLibro>
				{
					new AutorLibro{Libro = libro1},
					new AutorLibro{Libro = libro2},
				}
			};

			context.Add(autor);

			await context.SaveChangesAsync();

			var context2 = ConstruirContext(nombreBD);

			var controller = new AutoresController(context2, mapper, almacenadorArchivos, logger, outputCacheStore, serviciosAutores);

			//Prueba
			var respuesta = await controller.Get(1);

			//Verificación
			var resultado = respuesta.Value;
			Assert.AreEqual(expected: 1, actual: resultado!.Id);
			Assert.AreEqual(expected: 2, actual: resultado.Libros.Count);
		}
		
		-Se vuelve a poner el include y thenInclude.
		
		-Se prueba y OK.
	
	184. Evitando repetir código
		-En AutoresControllerPruebas se está repitiendo código.
		-Este código de pruebas automáticas, aunque no se va a mandar a PROD, ciertamente es code que hay que aplicar beunas prácticas de Ingeniería de Software.
		-Es básic no repetir code.
		-La primera parte de Preparación se va a colocar como campos de la clase
		 y se va a inicializar en método especial llamado TestInitialize.
		-Este es el inicializador de pruebas y es metodo que se ejecuta antes de la ejecucion de cada una de las pruebas automaticas.
		-Aqui se inicializan clase, variables...que vayamos a necesitar en distintas pruebas para no repetir code.
		-En cada una de als preubas vamos a usar NSubstitute.
		//Preparación
		var nombreBD = Guid.NewGuid().ToString();
		var context = ConstruirContext(nombreBD);
		var mapper = ConfigurarAutoMapper();
		IAlmacenadorArchivos almacenadorArchivos = null!;
		ILogger<AutoresController> logger = null!;
		IOutputCacheStore outputCacheStore = null!;
		IServicioAutores servicioAutores = Substitute.For<IServicioAutores>();

		var controller = new AutoresController(context, mapper, almacenadorArchivos, logger, outputCacheStore, servicioAutores);
		
		-context y mapper no serán campos de la clase porque peudo construir contexto a partir de nombreDB.
		IAlmacenadorArchivos almacenadorArchivos = null!;
		ILogger<AutoresController> logger = null!;
		IOutputCacheStore outputCacheStore = null!;
		IServicioAutores servicioAutores = Substitute.For<IServicioAutores>();
		private string nombreBD = Guid.NewGuid().ToString();
		private AutoresController controller = null!;

		[TestInitialize]
		public void Setup()
		{
			var context = ConstruirContext(nombreBD);
			var mapper = ConfigurarAutoMapper();
			IAlmacenadorArchivos almacenadorArchivos = null!;
			ILogger<AutoresController> logger = null!;
			IOutputCacheStore outputCacheStore = null!;
			IServicioAutores servicioAutores = Substitute.For<IServicioAutores>();

			controller = new AutoresController(context, mapper, almacenadorArchivos, logger, outputCacheStore, servicioAutores);
		}
		
		-Al poner el context en el Setup es imposible suar ese conetxto fuera de ahí.
		-Y asi es dificil usar contexto contaminado.
		-se queda asi el fichero.
		using BibliotecaAPI.Controllers.V1;
		using BibliotecaAPI.Servicios;
		using BibliotecaAPI.Servicios.V1;
		using Microsoft.AspNetCore.OutputCaching;
		using Microsoft.Extensions.Logging;
		using BibliotecaAPITests.Utilidades;
		using Microsoft.AspNetCore.Mvc;
		using BibliotecaAPI.Entidades;
		using BibliotecaAPI.Utilidades.Dobles;
		using BibliotecaAPI.DTOs;
		using Microsoft.EntityFrameworkCore;
		using NSubstitute;

		namespace BibliotecaAPITests.PruebasUnitarias.Controllers.V1;

		[TestClass]
		public class AutoresControllersPruebas: BasePruebas
		{
			IAlmacenadorArchivos almacenadorArchivos = null!;
			ILogger<AutoresController> logger = null!;
			IOutputCacheStore outputCacheStore = null!;
			IServicioAutores servicioAutores = Substitute.For<IServicioAutores>();
			private string nombreBD = Guid.NewGuid().ToString();
			private AutoresController controller = null!;

			[TestInitialize]
			public void Setup()
			{
				var context = ConstruirContext(nombreBD);
				var mapper = ConfigurarAutoMapper();
				IAlmacenadorArchivos almacenadorArchivos = null!;
				ILogger<AutoresController> logger = null!;
				IOutputCacheStore outputCacheStore = null!;
				IServicioAutores servicioAutores = Substitute.For<IServicioAutores>();

				controller = new AutoresController(context, mapper, almacenadorArchivos, logger, outputCacheStore, servicioAutores);
			}

			[TestMethod]
			public async Task Geet_Retorna404_CuandoAutorConIdNoExiste()
			{
				//Prueba
				var respuesta = await controller.Get(1);

				//Verificación
				var resultado = respuesta.Result as StatusCodeResult;
				Assert.AreEqual(expected: 404, actual: resultado!.StatusCode);
			}

			[TestMethod]
			public async Task Get_RetornaAutor_CuandoAutorConIdExiste()
			{
				//Preparación
				var context = ConstruirContext(nombreBD);

				context.Autores.Add(new Autor { Nombres = "Felipe", Apellidos = "Gavilán" });
				context.Autores.Add(new Autor { Nombres = "Claudia", Apellidos = "Rodríguez" });

				await context.SaveChangesAsync();

				//Prueba
				var respuesta = await controller.Get(1);

				//Verificación
				var resultado = respuesta.Value;
				Assert.AreEqual(expected: 1, actual: resultado!.Id);
			}

			[TestMethod]
			public async Task Get_RetornaAutorConLibros_CuandoAutorTieneLibros()
			{
				//Preparación
				var context = ConstruirContext(nombreBD);
				var libro1 = new Libro { Titulo = "Libro 1" };
				var libro2 = new Libro { Titulo = "Libro 2" };

				var autor = new Autor()
				{
					Nombres = "Felipe",
					Apellidos = "Gavilán",
					Libros = new List<AutorLibro>
					{
						new AutorLibro{Libro = libro1},
						new AutorLibro{Libro = libro2},
					}
				};

				context.Add(autor);

				await context.SaveChangesAsync();

				//Prueba
				var respuesta = await controller.Get(1);

				//Verificación
				var resultado = respuesta.Value;
				Assert.AreEqual(expected: 1, actual: resultado!.Id);
				Assert.AreEqual(expected: 2, actual: resultado.Libros.Count);
			}

			[TestMethod]
			public async Task Get_DebeLlamarGetDelServicioAutores()
			{
				//Preparación
				var paginacionDTO = new PaginacionDTO(2, 3);

				//Prueba
				await controller.Get(paginacionDTO);

				//Verificación
				await servicioAutores.Received(1).Get(paginacionDTO);
			}

			[TestMethod]
			public async Task Post_DebeCrearAutor_CuandoEnviamosAutor()
			{
				//Preparación
				var context = ConstruirContext(nombreBD);
				var nuevoAutor = new AutorCreacionDTO { Nombres = "nuevo", Apellidos = "autor" };

				//Prueba
				var respuesta = await controller.Post(nuevoAutor);

				//Verificación
				var resultado = respuesta as CreatedAtRouteResult;
				Assert.IsNotNull(resultado);

				var contexto2 = ConstruirContext(nombreBD);
				var cantidad = await contexto2.Autores.CountAsync();
				Assert.AreEqual(expected: 1, actual: cantidad);
			}
		}
		
		-Se tiene un error en el POST.
		-Se camia esto en el Setup:
		ILogger<AutoresController> logger = Substitute.For<ILogger<AutoresController>>();
		IOutputCacheStore outputCacheStore = Substitute.For<IOutputCacheStore>();
		IServicioAutores servicioAutores = Substitute.For<IServicioAutores>();

		-Se deja asi:
		IAlmacenadorArchivos almacenadorArchivos = null!;
		ILogger<AutoresController> logger = null!;
		IOutputCacheStore outputCacheStore = null!;
		IServicioAutores servicioAutores = Substitute.For<IServicioAutores>();
		private string nombreBD = Guid.NewGuid().ToString();
		private AutoresController controller = null!;

		[TestInitialize]
		public void Setup()
		{
			var context = ConstruirContext(nombreBD);
			var mapper = ConfigurarAutoMapper();
			almacenadorArchivos = null!;
			logger = Substitute.For<ILogger<AutoresController>>();
			outputCacheStore = Substitute.For<IOutputCacheStore>();
			servicioAutores = Substitute.For<IServicioAutores>();

			controller = new AutoresController(context, mapper, almacenadorArchivos, logger, outputCacheStore, servicioAutores);
		}
		
		-Se prueba.
		
	185. Probando el PUT de Autores
		-Se va a probar el PUT de Autores.
		-Se esperan varias situaciones. Sino existe el autor, se espera rercibir un 404. Si el autor existe, se procede a actualizarlo.
		-Sino hay foto, no invocamos el IAlmacenadorArchivos.
		-En cualquier caso, si actualizamos el Autor con SaveChangesAsync y si llamamos el EvictByTagAsync del outputCacheStore y recibimos un 404.
		-Se va a AutoresControllerPruebas y se crea el etst que prueba el 404.
		-De la fase de Preparación casi todo se hace en el Setup.
		-Ni siquiera tengo que crear un Autor porque se facilita esta prueba cando no hay autores en la tabla de Autores.
		[TestMethod]
		public async Task Put_Retorna404_CuandoAutorNoExiste()
		{
			// Prueba
			var respuesta = await controller.Put(1, autorCreacionDTO: null!);

			// Verificación
			var resultado = respuesta as StatusCodeResult;
			Assert.AreEqual(404, resultado!.StatusCode);
		}
		
		-Se prueba.
		
		-Se crea otro método de prueba. Para actualizar un Autor este primero debe exisitr.
		-SingleAsync asegura que hay un Autor en la BBDD y te lo devuelve.
		-Sino mando foto quiero asegurar que nos e ejecute el Editar de IAlmacenadorArchivos y si se ejecute el EvitByTagAsync.
		-La ultima linea es que se quiere evitar llamar el Editar a toda costa....
		private const string contenedor = "autores";
		private const string cache = "autores-obtener";

		[TestMethod]
		public async Task Put_ActualizarAutor_CuandoEnviamosAutorSinFoto()
		{
			// Preparación
			var context = ConstruirContext(nombreBD);

			context.Autores.Add(new Autor
			{
				Nombres = "Felipe",
				Apellidos = "Gavilán",
				Identificacion = "Id"
			});

			await context.SaveChangesAsync();

			var autoreCreacionDTO = new AutorCreacionConFotoDTO
			{
				Nombres = "Felipe2",
				Apellidos = "Gavilán2",
				Identificacion = "Id2"
			};

			// Prueba
			var respuesta = await controller.Put(1, autoreCreacionDTO);

			// Verificación
			var resultado = respuesta as StatusCodeResult;
			Assert.AreEqual(204, resultado!.StatusCode);

			var context3 = ConstruirContext(nombreBD);
			var autorActualizado = await context3.Autores.SingleAsync();

			Assert.AreEqual(expected: "Felipe2", actual: autorActualizado.Nombres);
			Assert.AreEqual(expected: "Gavilán2", actual: autorActualizado.Nombres);
			Assert.AreEqual(expected: "Id2", actual: autorActualizado.Identificacion);
			await outputCacheStore.Received(1).EvictByTagAsync(cache, default);
			await almacenadorArchivos.DidNotReceiveWithAnyArgs().Editar(default, default!, default!);
		}
		
		-Se ejecuta y se prueba.
		
		-Mismo proceso pero para cuandoa ctualizamos con foto.
		[TestMethod]
		public async Task Put_ActualizarAutor_CuandoEnviamosAutorConFoto()
		{
			// Preparación
			var context = ConstruirContext(nombreBD);

			var urlAnterior = "URL-1";
			var urlNueva = "URL-2";
			almacenadorArchivos.Editar(default, default!, default!).ReturnsForAnyArgs(urlNueva);

			context.Autores.Add(new Autor
			{
				Nombres = "Felipe",
				Apellidos = "Gavilán",
				Identificacion = "Id",
				Foto = urlAnterior
			});

			await context.SaveChangesAsync();

			var formFile = Substitute.For<IFormFile>();

			var autoreCreacionDTO = new AutorCreacionConFotoDTO
			{
				Nombres = "Felipe2",
				Apellidos = "Gavilán2",
				Identificacion = "Id2",
				Foto = formFile
			};

			// Prueba
			var respuesta = await controller.Put(1, autoreCreacionDTO);

			// Verificación
			var resultado = respuesta as StatusCodeResult;
			Assert.AreEqual(204, resultado!.StatusCode);

			var context3 = ConstruirContext(nombreBD);
			var autorActualizado = await context3.Autores.SingleAsync();

			Assert.AreEqual(expected: "Felipe2", actual: autorActualizado.Nombres);
			Assert.AreEqual(expected: "Gavilán2", actual: autorActualizado.Nombres);
			Assert.AreEqual(expected: "Id2", actual: autorActualizado.Identificacion);
			Assert.AreEqual(expected: urlNueva, actual: autorActualizado.Foto);
			await outputCacheStore.Received(1).EvictByTagAsync(cache, default);
			await almacenadorArchivos.Received(1).Editar(urlAnterior, contenedor, formFile);
		}
		
		-Correr todas las pruebas.
		
	186. Probando el patch de Autores
		-Se tienen escenarios:
			-Cuando patchDoc is null
			-autorDB is null
			-!esvalido
			-Cuando todo funciona y se actualiza Autor.
		
		[TestMethod]
		public async Task Patch_Retorna400_CuandoPatchDocEsNulo()
		{
			// Prueba
			var respuesta = await controller.Patch(1, patchDoc: null!);

			// Verificación
			var resultado = respuesta as StatusCodeResult;
			Assert.AreEqual(400, resultado!.StatusCode);
		}
		
		[TestMethod]
		public async Task Patch_Retorna404_CuandoAutorNoExiste()
		{
			// Preparación
			var patchDoc = new JsonPatchDocument<AutorPatchDTO>();

			// Prueba
			var respuesta = await controller.Patch(1, patchDoc);

			// Verificación
			var resultado = respuesta as StatusCodeResult;
			Assert.AreEqual(404, resultado!.StatusCode);
		}
		
		-Hay que apsarle a la prueba un ObjectModelValidator para que no falle la validacion.
		[TestMethod]
		public async Task Patch_RetornaValidationProblem_CuandoHayErrorDeValidacion()
		{
			// Preparación
			var context = ConstruirContext(nombreBD);
			context.Autores.Add(new Autor
			{
				Nombres = "Felipe",
				Apellidos = "Gavilán",
				Identificacion = "Id"
			});

			await context.SaveChangesAsync();

			var objectValidator = Substitute.For<IObjectModelValidator>();
			controller.ObjectValidator = objectValidator;

			var mensajeDeError = "mensaje de error";
			controller.ModelState.AddModelError("", mensajeDeError);

			var patchDoc = new JsonPatchDocument<AutorPatchDTO>();

			// Prueba
			var respuesta = await controller.Patch(1, patchDoc);

			// Verificación
			var resultado = respuesta as ObjectResult;
			var problemDetails = resultado!.Value as ValidationProblemDetails;
			Assert.IsNotNull(problemDetails);
			Assert.AreEqual(expected: 1, actual: problemDetails.Errors.Keys.Count);
			Assert.AreEqual(expected: mensajeDeError, actual: problemDetails.Errors.Values.First().First());
		}
		
		-Se ejecuta todo.
		[TestMethod]
		public async Task Patch_ActualizaUnCampo_CuandoSeLeEnViaUnaOperacion()
		{
			// Preparación
			var context = ConstruirContext(nombreBD);
			context.Autores.Add(new Autor
			{
				Nombres = "Felipe",
				Apellidos = "Gavilán",
				Identificacion = "Id",
				Foto = "URL-1"
			});

			await context.SaveChangesAsync();

			var objectValidator = Substitute.For<IObjectModelValidator>();
			controller.ObjectValidator = objectValidator;

			var patchDoc = new JsonPatchDocument<AutorPatchDTO>();
			patchDoc.Operations.Add(new Operation<AutorPatchDTO>("replace", "/nombres", null, "Felipe2"));

			// Prueba
			var respuesta = await controller.Patch(1, patchDoc);

			// Verificación
			var resultado = respuesta as StatusCodeResult;
			Assert.AreEqual(expected: 204, resultado!.StatusCode);

			await outputCacheStore.Received(1).EvictByTagAsync(cache, default);

			var context2 = ConstruirContext(nombreBD);
			var autorBD = await context2.Autores.SingleAsync();

			Assert.AreEqual(expected: "Felipe2", autorBD.Nombres);
			Assert.AreEqual(expected: "Gavilán", autorBD.Apellidos);
			Assert.AreEqual(expected: "Id", autorBD.Identificacion);
			Assert.AreEqual(expected: "URL-1", autorBD.Foto);
		}
		
		-Se ejecuta todo.
		
	187. Probando el Delete de Autores
		-Dos posibilidades: retorna 404 cuando no existe el autor, retorna un 204 al borrar autor.
		[TestMethod]
		public async Task Delete_Retornar404_CuandoAutorNoExiste()
		{
			// Prueba 
			var respuesta = await controller.Delete(1);

			// Verificación
			var resultado = respuesta as StatusCodeResult;
			Assert.AreEqual(404, resultado!.StatusCode);
		}
		
		[TestMethod]
		public async Task Delete_BorrarAutor_CuandoAutorExiste()
		{
			// Preparación
			var urlFoto = "URL-1";

			var context = ConstruirContext(nombreBD);

			context.Autores.Add(new Autor { Nombres = "Autor1", Apellidos = "Autor1", Foto = urlFoto });
			context.Autores.Add(new Autor { Nombres = "Autor2", Apellidos = "Autor2" });

			await context.SaveChangesAsync();

			// Prueba 
			var respuesta = await controller.Delete(1);

			// Verificación
			var resultado = respuesta as StatusCodeResult;
			Assert.AreEqual(204, resultado!.StatusCode);

			var context2 = ConstruirContext(nombreBD);
			var cantidadAutores = await context2.Autores.CountAsync();
			Assert.AreEqual(expected: 1, actual: cantidadAutores);

			var autor2Existe = await context2.Autores.AnyAsync(x => x.Nombres == "Autor2");
			Assert.IsTrue(autor2Existe);

			await outputCacheStore.Received(1).EvictByTagAsync(cache, default);
			await almacenadorArchivos.Received(1).Borrar(urlFoto, contenedor);
		}
		
		-Se prueba.
		
	188. Probando un Método que usa el HttpContext
		-El método a probar es de LibrosController.
		-Se vaa  probar el ObtenerLibrosV1.
		-Se crea clase nueva en PruebasUnitarias > Controllers > V1.
		-Se le llama LibrosControllerPruebas.
		-Se quiere probar el correcto funcionamiento de una función que usa HttpContext.
		[TestMethod]
		public async Task Get_RetornarCeroLibros_CuandoNoHayLibros()
		{
			// Preparación
			var nombreBD = Guid.NewGuid().ToString();
			var context = ConstruirContext(nombreBD);
			var mapper = ConfigurarAutoMapper();
			IOutputCacheStore outputCacheStore = null!;

			var controller = new LibrosController(context, mapper, outputCacheStore);

			var paginacionDTO = new PaginacionDTO(1, 1);

			// Prueba
			var respuesta = await controller.Get(paginacionDTO);

			// Verificación
			Assert.AreEqual(expected: 0, actual: respuesta.Count());
		}
		
		-No se peude dejar asi esto porque llega un HttpContext nulo: var respuesta = await controller.Get(paginacionDTO);
		
		-Se añade antes de declarar paginacionDTO: controller.ControllerContext.HttpContext = new DefaultHttpContext();
		
		-Se prueba.
		
	189. Probando un Método que usa Claims
		-Se va a la clase ServiciosUsuarios y en el método ObtenerUsuario se ve que se usan Claims para obtener usuarios.
		-Se quiere hacer pruebas automaticas a este metodo para verificar su corecto funcionamiento.
		-Dentro de PruebasUnitarias, nueva pcarpeta: Servicios. Y se crea ServiciosUsuariosPruebas.
		-UserStore es una clase que permite indicar el comportamiento de las distitnas accioens de Identity.
		-Como se usa Identity con EF Core suele venir con un IUserStore que hace todo por nosotros. Pero tenemos la posibilidad de apsarle uno persnalizado para que asi
		 podmaos controlar como funciona Identity para hacer pruebas.
		[TestMethod]
		public async Task ObtenerUsuario_RetornaNulo_CuandoNohayClaimEmail()
		{
			// Preparación
			var httpContext = new DefaultHttpContext();
			contextAccessor.HttpContext.Returns(httpContext);

			// Prueba
			var usuario = await servicioUsuarios.ObtenerUsuario();

			// Verificación
			Assert.IsNull(usuario);
		}
		
		-Se prueba.
		
		-Ahora cuando se busque por email retorna el usuario esperado.
		-Ese Task.FormResult es para no tener que esperar de forma asincrona, para que se ejecute el metodo directo.
		[TestMethod]
		public async Task ObtenerUsuario_RetornaUsuario_CuandohayClaimEmail()
		{
			// Preparación
			var email = "prueba@hotmail.com";
			var usuarioEsperado = new Usuario { Email = email };

			userManager.FindByEmailAsync(email)!.Returns(Task.FromResult(usuarioEsperado));

			var claims = new ClaimsPrincipal(new ClaimsIdentity(new Claim[]
			{
				new Claim("email", email)
			}));

			var httpContext = new DefaultHttpContext() { User = claims };
			contextAccessor.HttpContext.Returns(httpContext);

			// Prueba
			var usuario = await servicioUsuarios.ObtenerUsuario();

			// Verificación
			Assert.IsNotNull(usuario);
			Assert.AreEqual(expected: email, actual: usuario.Email);
		}
		
		-Se prueba.
		
		-Se quiere verificar que si usuario no existe, se retorna nulo.
		[TestMethod]
		public async Task ObtenerUsuario_RetornaNulo_CuandoUsuarioNoExiste()
		{
			// Preparación
			var email = "prueba@hotmail.com";
			var usuarioEsperado = new Usuario { Email = email };

			userManager.FindByEmailAsync(email)!.Returns(Task.FromResult<Usuario>(null));

			var claims = new ClaimsPrincipal(new ClaimsIdentity(new Claim[]
			{
				new Claim("email", email)
			}));

			var httpContext = new DefaultHttpContext() { User = claims };
			contextAccessor.HttpContext.Returns(httpContext);

			// Prueba
			var usuario = await servicioUsuarios.ObtenerUsuario();

			// Verificación
			Assert.IsNull(usuario);
		}
		
		-Probar.
		
	190. Preparándose para probar Login y Registro
		-Se agrega nueva clase en PruebasUnitarias > Controllers > V1: UsuariosControllerPruebas.
		[TestClass]
		public class UsuariosControllerPruebas : BasePruebas
		{
			private string nombreBD = Guid.NewGuid().ToString();
			private UserManager<Usuario> userManager = null!;
			private SignInManager<Usuario> signInManager = null!;
			private UsuariosController controller = null!;

			[TestInitialize]
			public void Setup()
			{
				var context = ConstruirContext(nombreBD);
				userManager = Substitute.For<UserManager<Usuario>>(
					Substitute.For<IUserStore<Usuario>>(), null, null, null, null, null, null, null, null);

				var miConfiguracion = new Dictionary<string, string>
				{
					{
						"llavejwt", "askjdansjkdansjkdNJKANSDJKANSDJKASNDAJKSNDJ"
					}
				};

				var configuration = new ConfigurationBuilder()
					.AddInMemoryCollection(miConfiguracion!)
					.Build();

				var contextAccessor = Substitute.For<IHttpContextAccessor>();
				var userClaimsFactory = Substitute.For<IUserClaimsPrincipalFactory<Usuario>>();

				signInManager = Substitute.For<SignInManager<Usuario>>(userManager,
					contextAccessor, userClaimsFactory, null, null, null, null);

				var servicioUsuarios = Substitute.For<IServiciosUsuarios>();

				var mapper = ConfigurarAutoMapper();

				controller = new UsuariosController(userManager, configuration, signInManager, servicioUsuarios, context, mapper);
			}
		}
		
	191. Probando los Método de Registro y Login
		-Se va a usuariosControllerPruebas.
		-Se va a probar de que cuando intento registrarme, la oepración no es exitosa, tengo que obtener un ValidationProblem.
		-Se necesita indicar que cuando se corre el metodo CreateAsync, quiero devolver error.
		[TestMethod]
		public async Task Registrar_DevuelveValidationProblem_CuandoNoEsExitoso()
		{
			// Preparación
			var mensajeDeError = "prueba";
			var credenciales = new CredencialesUsuarioDTO 
			{ 
				Email = "prueba@hotmail.com",
				Password = "aA123456!"
			};

			userManager.CreateAsync(Arg.Any<Usuario>(), Arg.Any<string>())
				.Returns(IdentityResult.Failed(new IdentityError
				{
					Code = "prueba",
					Description = mensajeDeError
				}));

			// Prueba
			var respuesta = await controller.Registrar(credenciales);

			// Validación
			var resultado = respuesta.Result as ObjectResult;
			var problemDetails = resultado!.Value as ValidationProblemDetails;
			Assert.IsNotNull(problemDetails);
			Assert.AreEqual(expected: 1, actual: problemDetails.Errors.Keys.Count);
			Assert.AreEqual(expected: mensajeDeError, actual: problemDetails.Errors.Values.First().First());
		}
		
		-Se ejecuta.
		
		-Se prueba cuando registre funcione.
		[TestMethod]
		public async Task Registrar_DevuelveToken_CuandoEsExitoso()
		{
			// Preparación
			var credenciales = new CredencialesUsuarioDTO
			{
				Email = "prueba@hotmail.com",
				Password = "aA123456!"
			};

			userManager.CreateAsync(Arg.Any<Usuario>(), Arg.Any<string>())
				.Returns(IdentityResult.Success);

			// Prueba
			var respuesta = await controller.Registrar(credenciales);

			// Validación
			Assert.IsNotNull(respuesta.Value);
			Assert.IsNotNull(respuesta.Value.Token);
		}
		
		-Se prueban los tres escenarios de Login.
		-El primer escenario es que sino existe el usuario, devuelva login incorrecto.
		-Es diferente a que Login sea incorrecto de que sea usuario correcto pero password incorrecto.
		[TestMethod]
		public async Task Login_DevuelveValidationProblem_CuandoUsuarioNoExiste()
		{
			// Preparación
			var credenciales = new CredencialesUsuarioDTO
			{
				Email = "prueba@hotmail.com",
				Password = "aA123456!"
			};

			userManager.FindByEmailAsync(credenciales.Email)!.Returns(Task.FromResult<Usuario>(null!));

			// Prueba
			var respuesta = await controller.Login(credenciales);

			// Verificación
			var resultado = respuesta.Result as ObjectResult;
			var problemDetails = resultado!.Value as ValidationProblemDetails;
			Assert.IsNotNull(problemDetails);
			Assert.AreEqual(expected: 1, actual: problemDetails.Errors.Keys.Count);
			Assert.AreEqual(expected: "Login incorrecto", actual: problemDetails.Errors.Values.First().First());
		}
		
		-La siguiente prueba es que el Login sea incorrecto.
		-Pasamos la parte del FindByEmailAsync, peroe l CheckPassword tiene que devovler un error.
		[TestMethod]
		public async Task Login_DevuelveValidationProblem_CuandoLoginEsIncorrecto()
		{
			// Preparación
			var credenciales = new CredencialesUsuarioDTO
			{
				Email = "prueba@hotmail.com",
				Password = "aA123456!"
			};

			var usuario = new Usuario { Email = credenciales.Email}

			userManager.FindByEmailAsync(credenciales.Email)!.Returns(Task.FromResult<Usuario>(usuario));

			signInManager.CheckPasswordSignInAsync(usuario, credenciales.Password, false)
				.Returns(Microsoft.AspNetCore.Identity.SignInResult.Failed);
				)

			// Prueba
			var respuesta = await controller.Login(credenciales);

			// Verificación
			var resultado = respuesta.Result as ObjectResult;
			var problemDetails = resultado!.Value as ValidationProblemDetails;
			Assert.IsNotNull(problemDetails);
			Assert.AreEqual(expected: 1, actual: problemDetails.Errors.Keys.Count);
			Assert.AreEqual(expected: "Login incorrecto", actual: problemDetails.Errors.Values.First().First());
		}
		
		[TestMethod]
		public async Task Login_DevuelveToken_CuandoLoginEsCorrecto()
		{
			// Preparación
			var credenciales = new CredencialesUsuarioDTO
			{
				Email = "prueba@hotmail.com",
				Password = "aA123456!"
			};

			var usuario = new Usuario { Email = credenciales.Email };

			userManager.FindByEmailAsync(credenciales.Email)!.Returns(Task.FromResult<Usuario>(usuario));

			signInManager.CheckPasswordSignInAsync(usuario, credenciales.Password, false)
				.Returns(Microsoft.AspNetCore.Identity.SignInResult.Success);

			// Prueba
			var respuesta = await controller.Login(credenciales);

			// Verificación
			Assert.IsNotNull(respuesta.Value);
			Assert.IsNotNull(respuesta.Value.Token);
		}
		
		-Se corren todas las pruebas.
	
	192. Pruebas de Integración
		-las pruebas de integración verifican que las distitnas pares de un software trabajan correctamente en conjunto.
		-Una razon para suar als pruebas de integración es para probar toda la tubería de procesos que ocurrene n WebAPI.
		-Antes hemos inlucio las pruebas unitarias de un cntrolador peroe sta prueba no incluye las reglas de ruteo, filtros....que intervienen en al regla de procesos que buscan satisfacer
		 una petición HTTP.
		-Tampoco se ha validado si solo los usuarios admin pueden crear un autor.
		-Se necesitan las pruebas de integración para validar que esos otros elementos no causen problemas en la app.
		-Desde el punto de vista de  la organziación, lo normal es separar nuestars pruebas de integración y unitarias en distitnos proyectos.
		-Esta razón es porque las pruebas de integración peuden llegar a ser más lentas que las unitarias.
		-Esto peude ser moelsto para los desarrolladores. Las preubas automñaticas suelen correrse con frecuencia proque mientras más rápido se detecte un problema, 
		 más fácil es de solucionar.
		-Si las pruebas automáticas tardan en eejcutarse, peus desarrolladores van a evitar correrlas y se pone en peligro 
		 la calidad del software que se desarrolla.
		-Asi que, separar las preubas de integracion y unitarias es una forma de manteenr agrupadas las pruebas que tipicamente se vana a ejecutar rapidamente.
		-No es obligatorio separarlas en proeyctos difernetes para esto.
		-Se peude tener una carpeta de pruebas Uniatrias y otra de Pruebas de Integracion y correr pruebas por caropetas. Y esto ayuda a tener esa separacion sin tener
		 la complejdiad de manejar distitnos proeyctos de prueba.
		-Por tanto, vamosa  tener pruebas unitarias y de integracion en mismo proeycto, pero separado en carpetas distitnas.
		-En el caso de las pruebas de integración, no es comun hacer mcks de funcionalidades internas.
		-La idea es poder probar la interacción de distintas peizas de nuestro software.
		-Quizas existen componentes a los cuales se quiera hacer mock como llamadas a WebService de terceros que estan fuera de nuestro control.
		-Si por ejemplo, tenemos una clase qiue guarda archivos en Azure, es posible que queramso hacerle mock y evitamos tener que garantizar
		 que hay siempre un servicio disponible de Azure en donde guarda los archivos.
		 
		-A lo que no hayq ue hacer mock es a una BBDD.
		-Si usamos EF Core, se tiene al emnos dos opciones pataa hacer pruebas con BBDD. USar un proveedor en memoria como hemos visto que permite tener un motor de BBDD en memoria.
		 Este motor de bbdd en memoria no tiene las misma funcionaldiades que un motor de BBDD real como SQl Server pero tiene su utilidad.
		 
		-Ota opcion es usar un proveedor como LocalDB.
		-Aqui lo que se hace es que al inicio de correr las pruebas se crea una bbdd temporal.
		-Al final de las pruebas, es borrada.
		-Eso permite ralizar las pruebas automaticas con bbdd real.
		-Requiere codigo para configurarse pero es una buena opcion para pruebas de integracion y es rapido.
	
	193. Configurando las Pruebas de Integración en ASP.NET Core
		-En el proeycto de pruebas se instala un paquete Nugget.
		-Microsoft.AspNetCore.Mvc.Testing
		-Se va al csproj del proyecto de Test.
		-Se cambia esto: <Project Sdk="Microsoft.NET.Sdk">
		-Por esto: <Project Sdk="Microsoft.NET.Sdk.Web">
		-Se mete esto abajo del todo de la clae program...
		public partial class Program { }
		-Esto es para poder hacer referencia a la clase program.
		
		-Primero, se va a crear un metodo el cual va a permititr obtener una clase a traves de la cual vamos a poder correr webAPI en memoria
		-Desde el proyecto prueba vamos a cargar webAPI en memoria para pdoer usarlo.
		-Se va a  Utilidades > Clase BasePruebas y se crea metodo auxiliar.
		-Eso de ignorarSeguridad e simportante para cuando yo quiero hacer prueba de Integración pero no quieroe star dandole mente a soy admin o no
		-La mayoría de las veces yo quiero hacer una prueba normal sin tener que estar pensando en un token de una persona que sea admin.
		-Con ignorarSeguridad nos vamosa  saltar las reglas de segruidad. Quiero tener la opcion de no saltarmelas para cuando quiera probar por ejemplo
		 que para crear autor tengo que ser admin.
		-No puedo tener dos proveedores de EF Core al mismo tiempo.
		-Se va a quitar el proveedor actual.
		-Es obtener el servicio que es de tipo IDbContextOptionsConfigurations del ApllicationDbContext
		-Se quita el proveedor de SQl Server porque no podemos teenr dos proveedores al mismo tiempo y se crea o se configura el proveedor en memoria.
		-Si ignorarSeguridad es cierto se quieren hacer varias csas para saltar reglas de segrudiad.
		-Se crea una clase en Utilidades que va a permitir centralizar esto.
		 protected WebApplicationFactory<Program> ConstruirWebApplicationFactory(string nombreBD, bool ignorarSeguridad = true)
		 {
			 var factory = new WebApplicationFactory<Program>();

			 factory = factory.WithWebHostBuilder(builder =>
			 {
				 builder.ConfigureTestServices(services =>
				 {
					 ServiceDescriptor descriptorDBContext = services.SingleOrDefault(
					 d => d.ServiceType == typeof(IDbContextOptionsConfiguration<ApplicationDbContext>))!;

					 if (descriptorDBContext is not null)
					 {
						 services.Remove(descriptorDBContext);
					 }

					 services.AddDbContext<ApplicationDbContext>(opciones =>
						opciones.UseInMemoryDatabase(nombreBD));

					 if (ignorarSeguridad)
					 {

					 }
				 });
			 });
		 }
		 
		-Clase AllowAnonymousHandler.
		public class AllowAnonymousHandler : IAuthorizationHandler
		{
			public Task HandleAsync(AuthorizationHandlerContext context)
			{
				throw new NotImplementedException();
			}
		}
		
		-Aqui se permite tomar un requisito de seguridad y hacer algo con el.
		public class AllowAnonymousHandler : IAuthorizationHandler
		{
			public Task HandleAsync(AuthorizationHandlerContext context)
			{
				foreach (var requirement in context.PendingRequirements)
				{
					context.Succeed(requirement);
				}

				return Task.CompletedTask;
			}
		}
		
		-Se vuelve a BAsepruebas. Se quiere indicar que el usuario tiene claims también que es lo que lo marca como usuario registrado.
		-Se mete usuario falso y se mete en un filtro. Asi puedo teenr un filtro global que se va a ejecutar ante cualquier accion.
		-Antes de ejecutar cualquier accion, se asignan claims al usuario.
		-Se mete una clase en Utilidades:
		public class UsuarioFalsoFiltro : IAsyncActionFilter
		{
			public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
			{
				//Antes de la acción
				context.HttpContext.User = new ClaimsPrincipal(new ClaimsIdentity(new List<Claim>
				{
					new Claim("email", "ejemplo@hotmail.com")
				}, "prueba"));

				await next();

				// Después de la acción
			}
		}
		
		-Se vuelve a BasePruebas.
		protected WebApplicationFactory<Program> ConstruirWebApplicationFactory(string nombreBD, bool ignorarSeguridad = true)
		{
			var factory = new WebApplicationFactory<Program>();

			factory = factory.WithWebHostBuilder(builder =>
			{
				builder.ConfigureTestServices(services =>
				{
					ServiceDescriptor descriptorDBContext = services.SingleOrDefault(
					d => d.ServiceType == typeof(IDbContextOptionsConfiguration<ApplicationDbContext>))!;

					if (descriptorDBContext is not null)
					{
						services.Remove(descriptorDBContext);
					}

					services.AddDbContext<ApplicationDbContext>(opciones =>
					   opciones.UseInMemoryDatabase(nombreBD));

					if (ignorarSeguridad)
					{
						services.AddSingleton<IAuthorizationHandler, AllowAnonymousHandler>();

						services.AddControllers(opciones =>
						{
							opciones.Filters.Add(new UsuarioFalsoFiltro());
						});
					}
				});
			});

			return factory;
		}
		
		-Asi, este metodo permite en cualquier clase de prueba poder obtener representacion en memoria del WebAPi paraa si poder ejecutarlo 
		 y realiza puebas de integración.
	
	194. Nuestra priemra prueba de Integración
		-Se va a probar metodo de ObtenerPorId.
		-En AutoresController V1, se va a probar ObtenrPorId, recordando que tenemos dos posibilidades que autor no se encuentre y por tanto 
		 obtengamos 404 o que el autor si exista y obtengamos el Autor.
		
		-Se crea carpeta de PruebasDeIntegracion > Controllers > V1.
		-Dentro se mete AutoresControllerPruebas.cs
		-Se mete la url que apunta a mi controlador ya que vamos a tener una representación del WebAPI en memoria.
		-Se va a usar el HTTPClient para comunicarnos con el WebAPI.
		-Recordando que el HTTPCliente s una clase C# la cual me permite crealziar epticiones HHTP desde código C#.
		[TestClass]
		public class AutoresControllerPruebas : BasePruebas
		{
			private static readonly string url = "/api/v1/autores";
			private string nombreBD = Guid.NewGuid().ToString();

			[TestMethod]
			public async Task get_Devuelve404_CuandoAutorNoExiste()
			{
				// Preparación
				var factory = ConstruirWebApplicationFactory(nombreBD);
				var cliente = factory.CreateClient();

				// Prueba
				var respuesta = await cliente.GetAsync($"{url}/1");

				// Verificación
				var statusCode = respuesta.StatusCode;
				Assert.AreEqual(expected: HttpStatusCode.NotFound, actual: respuesta.StatusCode);
			}

		}
		
		-Ahora se prueba que si el Autor existe, se devuelve dicho autor.
		-Se mete esta propiedad en Basepruebas: 
		protected readonly JsonSerializerOptions jsonSerializerOptions
			= new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
			
		[TestMethod]
		public async Task get_DevuelveAutor_CuandoAutorExiste()
		{
			// Preparación
			var context = ConstruirContext(nombreBD);
			context.Autores.Add(new Autor { Nombres = "Felipe", Apellidos = "Gavilán" });
			context.Autores.Add(new Autor { Nombres = "Claudia", Apellidos = "Rodríguez" });
			await context.SaveChangesAsync();

			var factory = ConstruirWebApplicationFactory(nombreBD);
			var cliente = factory.CreateClient();

			// Prueba
			var respuesta = await cliente.GetAsync($"{url}/1");

			// Verificación
			respuesta.EnsureSuccessStatusCode();

			var autor = JsonSerializer.Deserialize<AutorConLibrosDTO>(
				await respuesta.Content.ReadAsStringAsync(), jsonSerializerOptions)!;

			Assert.AreEqual(expected: 1, actual: autor.Id);
		}
		
		-La clase program se deja asi:
		using BibliotecaAPI;
		using BibliotecaAPI.Datos;
		using BibliotecaAPI.Entidades;
		using BibliotecaAPI.Servicios;
		using BibliotecaAPI.Swagger;
		using BibliotecaAPI.Utilidades;
		using BibliotecaAPI.Utilidades.V1;
		using Microsoft.AspNetCore.Diagnostics;
		using Microsoft.AspNetCore.Identity;
		using Microsoft.EntityFrameworkCore;
		using Microsoft.IdentityModel.Tokens;
		using Microsoft.OpenApi.Models;
		using System.Text;

		//namespace BibliotecaAPI;


		var builder = WebApplication.CreateBuilder(args);

		var diccionarioConfiguraciones = new Dictionary<string, string>
		{
			{ "quien_soy", "un diccionario en memoria" }
		};

		builder.Configuration.AddInMemoryCollection(diccionarioConfiguraciones!);

		//área de servicios

		builder.Services.AddOutputCache(opciones =>
		{
			opciones.DefaultExpirationTimeSpan = TimeSpan.FromSeconds(60);
		});

		//builder.Services.AddStackExchangeRedisOutputCache(opciones =>
		//{
		//    opciones.Configuration = builder.Configuration.GetConnectionString("redis");
		//});

		var origenesPermitidos = builder.Configuration.GetSection("origenesPermitidos").Get<string[]>()!;

		builder.Services.AddCors(opciones =>
		{
			opciones.AddDefaultPolicy(opcionesCORS =>
			{
				opcionesCORS.WithOrigins(origenesPermitidos).AllowAnyMethod().AllowAnyHeader()
				.WithExposedHeaders("cantidad-total-registros");
			});
		});

		builder.Services.AddOptions<PersonaOpciones>()
			.Bind(builder.Configuration.GetSection(PersonaOpciones.Seccion))
			.ValidateDataAnnotations()
			.ValidateOnStart();

		builder.Services.AddOptions<TarifaOpciones>()
			.Bind(builder.Configuration.GetSection(TarifaOpciones.Seccion))
			.ValidateDataAnnotations()
			.ValidateOnStart();

		builder.Services.AddSingleton<ProcesamientoPago>();

		builder.Services.AddAutoMapper(typeof(Program));

		builder.Services.AddControllers(opciones =>
		{
			opciones.Conventions.Add(new ConvencionAgrupaPorVersion());
		}).AddNewtonsoftJson();

		builder.Services.AddDbContext<ApplicationDbContext>(opciones => opciones.UseSqlServer("name=DefaultConnection"));

		builder.Services.AddIdentityCore<Usuario>()
			.AddEntityFrameworkStores<ApplicationDbContext>()
			.AddDefaultTokenProviders();

		builder.Services.AddScoped<UserManager<Usuario>>();
		builder.Services.AddScoped<SignInManager<Usuario>>();
		builder.Services.AddTransient<IServiciosUsuarios, ServiciosUsuarios>();
		//builder.Services.AddTransient<IAlmacenadorArchivos, AlmacenadorArchivosAzure>();
		builder.Services.AddTransient<IAlmacenadorArchivos, AlmacenadorArchivosLocal>();
		builder.Services.AddScoped<FiltroValidacionLibro>();
		builder.Services.AddScoped<BibliotecaAPI.Servicios.V1.IServicioAutores, BibliotecaAPI.Servicios.V1.ServicioAutores>();

		builder.Services.AddScoped<BibliotecaAPI.Servicios.V1.IGeneradorEnlaces,
					BibliotecaAPI.Servicios.V1.GeneradorEnlaces>();

		builder.Services.AddScoped<HATEOASAutorAttribute>();
		builder.Services.AddScoped<HATEOASAutoresAttribute>();

		builder.Services.AddHttpContextAccessor();

		builder.Services.AddAuthentication().AddJwtBearer(opciones =>
		{
			opciones.MapInboundClaims = false;
			opciones.TokenValidationParameters = new TokenValidationParameters
			{
				ValidateIssuer = false,
				ValidateAudience = false,
				ValidateLifetime = true,
				ValidateIssuerSigningKey = true,
				IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["llavejwt"]!)),
				ClockSkew = TimeSpan.Zero
			};
		});

		builder.Services.AddAuthorization(opciones =>
		{
			opciones.AddPolicy("esadmin", politica => politica.RequireClaim("esadmin"));
		});

		builder.Services.AddSwaggerGen(opciones =>
		{
			opciones.SwaggerDoc("v1", new Microsoft.OpenApi.Models.OpenApiInfo
			{
				Version = "v1",
				Title = "Biblioteca API",
				Description = "Este es un web api para trabajar con datos de autores y libros",
				Contact = new Microsoft.OpenApi.Models.OpenApiContact
				{
					Email = "felipe@hotmail.com",
					Name = "Felipe Gavilán",
					Url = new Uri("https://gavilan.blog")
				},
				License = new Microsoft.OpenApi.Models.OpenApiLicense
				{
					Name = "MIT",
					Url = new Uri("https://opensource.org/license/mit/")
				}
			});

			opciones.SwaggerDoc("v2", new Microsoft.OpenApi.Models.OpenApiInfo
			{
				Version = "v2",
				Title = "Biblioteca API",
				Description = "Este es un web api para trabajar con datos de autores y libros",
				Contact = new Microsoft.OpenApi.Models.OpenApiContact
				{
					Email = "felipe@hotmail.com",
					Name = "Felipe Gavilán",
					Url = new Uri("https://gavilan.blog")
				},
				License = new Microsoft.OpenApi.Models.OpenApiLicense
				{
					Name = "MIT",
					Url = new Uri("https://opensource.org/license/mit/")
				}
			});

			opciones.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
			{
				Name = "Authorization",
				Type = SecuritySchemeType.ApiKey,
				Scheme = "Bearer",
				BearerFormat = "JWT",
				In = ParameterLocation.Header
			});

			opciones.OperationFilter<FiltroAutorizacion>();

			//opciones.AddSecurityRequirement(new OpenApiSecurityRequirement
			//{
			//    {
			//        new OpenApiSecurityScheme
			//        {
			//            Reference = new OpenApiReference
			//            {
			//                Type = ReferenceType.SecurityScheme,
			//                Id = "Bearer"
			//            }
			//        },
			//        new string[]{ }
			//    }
			//});
		});

		var app = builder.Build();

		// área de middlewares

		app.UseExceptionHandler(exceptionHandlerApp => exceptionHandlerApp.Run(async context =>
		{
			var exceptionHandlerFeature = context.Features.Get<IExceptionHandlerFeature>();
			var excepcion = exceptionHandlerFeature?.Error!;

			var error = new Error()
			{
				MensajeDeError = excepcion.Message,
				StackTrace = excepcion.StackTrace,
				Fecha = DateTime.UtcNow
			};

			var dbContext = context.RequestServices.GetRequiredService<ApplicationDbContext>();
			dbContext.Add(error);
			await dbContext.SaveChangesAsync();
			await Results.InternalServerError(new
			{
				tipo = "error",
				mensaje = "Ha ocurrido un error inesperado",
				estatus = 500
			}).ExecuteAsync(context);
		}));
		app.UseSwagger();
		app.UseSwaggerUI(opciones =>
		{
			opciones.SwaggerEndpoint("/swagger/v1/swagger.json", "Biblioteca API V1");
			opciones.SwaggerEndpoint("/swagger/v2/swagger.json", "Biblioteca API V2");
		});

		app.UseStaticFiles();

		app.UseCors();

		app.UseOutputCache();

		app.MapControllers();

		app.Run();

		public partial class Program { }
		
		-Se ejecutan las pruebas.
	
	195. Verificando que Una Acción Está Protegida
		-Esto es útil para no mandar sin querer a PROD nuestros endpoints sin proteger.
		-Se va a probar que el método POST esté protegido.
		-Se mete una preuba más.....
		
	196. Métodos Auxiliares para Crear Usuarios en pruebas de Integración
		-Quisiera probar que un usuario que es admin pueda crea run autor y para eso necesito métodos auxiliares para crear usuarios porque a aprtir de un usuario creado,
		 voy a obtener un JSOnwebTOken y es ese JSOnWebToken lo que voy a poder mandar a traves del HTTPClient.
		-Se va a ABsePruebas y se trabaja con esos métodos auxiliares.
		-Se quiere crear un usuario y meter los Claims que se quiera para decir a mirael que voy a crear es una dmin y el email.
		-Se necesita la URL de registro. Es la ruta para registrar un usuario
		-Se crea método privado que hace la peticion HTTP, obtener el token y devolverlo.
		-Para meter claims hay que crear claims en la tabla de UsuarioClaims. Y luego se hace login de ese usuario para obtener un neuvo JSONWebToken cone sos claims.
		-Se crea tambiénj un método que no necesite claims como CrearUsuario y 
		-Se ha metido esto:
		protected readonly Claim adminClaim = new Claim("esadmin", "1");
		protected async Task<string> CrearUsuario(string nombreBD, WebApplicationFactory<Program> factory)
			=> await CrearUsuario(nombreBD, factory, [], "ejemplo@hotmail.com");

		protected async Task<string> CrearUsuario(string nombreBD, WebApplicationFactory<Program> factory, IEnumerable<Claim> claims)
			=> await CrearUsuario(nombreBD, factory, claims, "ejemplo@hotmail.com");
			
		protected async Task<string> CrearUsuario(string nombreBD, WebApplicationFactory<Program> factory,
			IEnumerable<Claim> claims, string email)
		{
			var urlRegistro = "/api/v1/usuarios/registro";
			string token = string.Empty;
			token = await ObtenerToken(email, urlRegistro, factory);

			if (claims.Any())
			{
				var context = ConstruirContext(nombreBD);
				var usuario = await context.Users.Where(x => x.Email == email).FirstAsync();
				Assert.IsNotNull(usuario);

				var userClaims = claims.Select(x => new IdentityUserClaim<string>
				{
					UserId = usuario.Id,
					ClaimType = x.Type,
					ClaimValue = x.Value
				});

				context.UserClaims.AddRange(userClaims);
				await context.SaveChangesAsync();
				var urlLogin = "/api/v1/usuarios/login";
				token = await ObtenerToken(email, urlLogin, factory);
			} 

			return token;
		}

		private async Task<string> ObtenerToken(string email, string url, WebApplicationFactory<Program> factory)
		{
			var password = "aA123456!";
			var credenciales = new CredencialesUsuarioDTO { Email = email, Password = password };
			var cliente = factory.CreateClient();
			var respuesta = await cliente.PostAsJsonAsync(url, credenciales);
			respuesta.EnsureSuccessStatusCode();

			var contenido = await respuesta.Content.ReadAsStringAsync();
			var respuestaAutenticacion = JsonSerializer.Deserialize<RespuestaAutenticacionDTO>(contenido, jsonSerializerOptions)!;

			Assert.IsNotNull(respuestaAutenticacion.Token);

			return respuestaAutenticacion.Token;
		}
		
		-Se compila y listo
		
	197. Verificando que Sólo un Admin Pueda Crear Un Recurso
		-Se va a probar que si usuario está registrado pero no es admin, recibe un 403 prohibido al intentar crear un autor y luegos e verá 
		 que un admin peude crear un autor.
		-Se usan los métodos de CrearUsuario del video anterior.
		-Se va a AutoresControllerPruebas y se copia Post_Devuelve401_CuandoUsuarioNoEstaAutenticado
		-Y se convierte a esto:
		[TestMethod]
		public async Task Post_Devuelve403_CuandoUsuarioNoEsAdmin()
		{
			// Preparación
			var factory = ConstruirWebApplicationFactory(nombreBD, ignorarSeguridad: false);
			var token = await CrearUsuario(nombreBD, factory);

			var cliente = factory.CreateClient();

			cliente.DefaultRequestHeaders.Authorization =
				new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", token);

			var autorCreacionDTO = new AutorCreacionDTO
			{
				Nombres = "Felipe",
				Apellidos = "Gavilán",
				Identificacion = "123"
			};

			// Prueba
			var respuesta = await cliente.PostAsJsonAsync(url, autorCreacionDTO);

			// Verificación
			Assert.AreEqual(expected: HttpStatusCode.Forbidden, actual: respuesta.StatusCode);
		}
		
		-Se prueba.
		
		[TestMethod]
		public async Task Post_Devuelve201_CuandoUsuarioEsAdmin()
		{
			// Preparación
			var factory = ConstruirWebApplicationFactory(nombreBD, ignorarSeguridad: false);

			var claims = new List<Claim> { adminClaim };

			var token = await CrearUsuario(nombreBD, factory, claims);

			var cliente = factory.CreateClient();

			cliente.DefaultRequestHeaders.Authorization =
				new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", token);

			var autorCreacionDTO = new AutorCreacionDTO
			{
				Nombres = "Felipe",
				Apellidos = "Gavilán",
				Identificacion = "123"
			};

			// Prueba
			var respuesta = await cliente.PostAsJsonAsync(url, autorCreacionDTO);

			// Verificación
			respuesta.EnsureSuccessStatusCode();
			Assert.AreEqual(expected: HttpStatusCode.Created, actual: respuesta.StatusCode);
		}
		
		-Se prueba.
		
	
	198. Probando Que un Usuario NO Pueda Borrar el Comentario de Otro Usuario
		-Se va a automatizar una prueba que en el pasado se tuvo que hacer manualmente.
		-En la lógica del Delete de ComentariosController se tenía que si el usuario que está intentando borrar el comentario es distinto al usuario que 
		 creó el usuario, se devuelve un 403.
		-Se va a probar quer si el usuario intenta borrar su propio comentario, se devuelve un 204.
		-En PruebaDeIntegracion > Controlelrs > V1 se mete ComentariosControllerPruebas.
		-Se crea la priemra prueba.
		[TestClass]
		public class ComentariosControllerPruebas : BasePruebas
		{
			private readonly string url = "/api/v1/libros/1/comentarios";
			private string nombreBD = Guid.NewGuid().ToString();

			private async Task CrearDataDePrueba()
			{
				var context = ConstruirContext(nombreBD);
				var autor = new Autor { Nombres = "Felipe", Apellidos = "Gavilán" };
				context.Add(autor);
				await context.SaveChangesAsync();

				var libro = new Libro { Titulo = "título" };
				libro.Autores.Add(new AutorLibro { Autor = autor });
				context.Add(libro);
				await context.SaveChangesAsync();
			}

			[TestMethod]
			public async Task Delete_Devuelve204_CuandoUsuarioBorraSuPropioComentario()
			{
				// Preparación
				await CrearDataDePrueba();

				var factory = ConstruirWebApplicationFactory(nombreBD, ignorarSeguridad: false);

				var token = await CrearUsuario(nombreBD, factory);

				var context = ConstruirContext(nombreBD);
				var usuario = await context.Users.FirstAsync();

				var comentario = new Comentario
				{ 
					Cuerpo = "contenido",
					UsuarioId = usuario!.Id,
					LibroId = 1
				};

				context.Add(comentario);
				await context.SaveChangesAsync();

				var cliente = factory.CreateClient();
				cliente.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", token);

				// Prueba
				var respuesta = await cliente.DeleteAsync($"{url}/{comentario.Id}");

				// Verificación
				Assert.AreEqual(expected: HttpStatusCode.NoContent, actual: respuesta.StatusCode);
			}
		}
		
		-Se crea la segunda prueba que se va a tener dos usuarios y vamos a intentar que un usuario borre el comentario de otro usuario.
		[TestMethod]
		public async Task Delete_Devuelve403_CuandoUsuarioIntentaBorrarElComentarioDeOtro()
		{
			// Preparación
			await CrearDataDePrueba();

			var factory = ConstruirWebApplicationFactory(nombreBD, ignorarSeguridad: false);

			var emailCreadorComentario = "creador-comentario@hotmail.com";
			await CrearUsuario(nombreBD, factory, [], emailCreadorComentario);

			var context = ConstruirContext(nombreBD);
			var usuarioCreadorComentario = await context.Users.FirstAsync();

			var comentario = new Comentario
			{
				Cuerpo = "contenido",
				UsuarioId = usuarioCreadorComentario!.Id,
				LibroId = 1
			};

			context.Add(comentario);
			await context.SaveChangesAsync();

			var tokenUsuarioDistinto = await CrearUsuario(nombreBD, factory, [], "usuario-distinto@hotmail.com"); 

			var cliente = factory.CreateClient();
			cliente.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", tokenUsuarioDistinto);

			// Prueba
			var respuesta = await cliente.DeleteAsync($"{url}/{comentario.Id}");

			// Verificación
			Assert.AreEqual(expected: HttpStatusCode.Forbidden, actual: respuesta.StatusCode);
		}
		
		-Se prueba.
		
	199. Probando que un filtro se ejecuta
		-En LibrosController se está usando un filtro a la hora de crear un libro.
		-Que es el FiltroValidacionLibro que garantizaba que autoresId de LibroCreacionDTO venga con datos.
		-Se mete en un filtro para no tener que repetir dicha validación.
		-Se va a PruebasDeIntegracion > Controllers > V1 ys e mete LibrosControllerPruebas 
		namespace BibliotecaAPITests.PruebasDeIntegracion.Controllers.V1
		{
			[TestClass]
			public class LibrosControllerPruebas : BasePruebas
			{
				private readonly string url = "/api/v1/libros";
				private string nombreBD = Guid.NewGuid().ToString();

				[TestMethod]
				public async Task Post_Devuelve400_CuandoAutoresIdsEsVacio()
				{
					// Preparación
					var factory = ConstruirWebApplicationFactory(nombreBD);
					var cliente = factory.CreateClient();
					var libroCreacionDTO = new LibroCreacionDTO { Titulo = "Título" };

					// Prueba
					var respuesta = await cliente.PostAsJsonAsync(url, libroCreacionDTO);

					// Verificación
					Assert.AreEqual(expected: HttpStatusCode.BadRequest, actual: respuesta.StatusCode);
				}
			}
		}
		
	200. Resumen
		-Aprendimos acerca de pruebas automática sy vimos que estas ayudan a comprobar el corerecto funcionamiento del software.
		-Las prueba suitarias sirven para probar una undiad de trabajo de la app.
		-Se prueban controladores usando un proveedor en meoria para poder verificar el correcto funcionamiento de nuestars implementacioens que usan EF Core.
		-Se usa una libreria para verificar el llamado de las dependencias de nuestras pruebas.
		-Con pruebas de integracion involucraban distitnos compoenntes de nuestra app como la tuberia de filtros.
	
	
Sección 10: Despliegues
	201. Introducción
		-Se va a llevar a cabo el proceso de despliegue o deployment que es el proceso de llevar nuestar app de nuestro ordenador a un servidor.
	
	202. Publicando en Azure - Managed Identity 
		-Se va a ver como desplegar nuestro webapi en un app service.
		-Es un servicio de Azure que nos eprmite hostear apps.
		-Se va a hostear nuestro webapi.
		-Hay que crear cuenta de Azure y antes hay que hacer una serie de configuraciones.
		-Se va a click derecho sobre el proyecto de BibliotecaAPI > Publicar > Azure > Azure App Service (Windows)
		-Create New.
		-Se selecciona el hosting plan que e slas caracteristicas dels ervidr que vamos a usar.
		-Creamos el gratis y creamos el appservice que aun no esta desplegando la app en Azure.
		-Crea lainstancia del lugar donde se va a encontrar/alojar el webapi
		-Se selecciona el appservice que hemos creado, siguiente, saltar paso y finalizar.
		-Hay otras dependencias cuando acaba que podemos añadir y solo dejo la de SQL Server.
		-Se selecciona SQL Server Database > Connect que es bbdd en prod. Se seleccina Azure SQl Database.
		-Crear Nuevo. Nuevo servidor de bbdd:  bibliotecaapidbserver11; User: gavilanch; password: [GitHub]....
		-Con esto se ve configurado el servidor de bbbd.
		-Se crea y se crea el sevvidor de bbdd y la bbdd perse.
		-Se selecciona la bbdd y siguiente....
		-En vez de usar usuario y passwor es mejor usar Managed Identity que otorgamos eprmiso a azure apps ervide para que se pueda conectar con nuestra bbdd
		 de tal forma que asi si nos robaran el connectionString una persona NO autorizada no podría acceder a bbdd por que la bbdd no contendria usuario y 
		 passwor. Solo Azure app service peude conectarse a bbdd.
		-Hay que meter esto: ConnectionStrings:DatefaultConnection en conectarse a BBDD de Azure SQL.
		-Se da a siguiente y se desclica paquetes nugegt.
		-Finish.
		
		-Se quiere aplicar las migraciones de EF Core en bbdd de prod.
		-Y si le pinchamos en Deployment Mode > EF Core migrations y se le clica en el checkbox de aplicar mirgaciones al publicar.
		-Asi al publicar webapi se actualiza bbdd con migraciones. Este connectionstring no tiene user y passwor sino que 
		 usa entdad manejada. Solo desde Azure app service podemos acceder a bbdd.
		-Desde Visual Studio si que no puedo acceder a ese azure app service.
		-Hay que buscar mecanismo para aplicar migracione sy solucion sencilla es ir a Program y corre migraciones al momento de correr la app.
		-Se construye un scope en el que obtenemos una instancia del applicationDbConext y Scoe es tiempo de vida del servicio.
		-Asi, la priemra vez que corramos app se corren migraciones.
		using (var scope = app.Services.CreateScope())
		{
			var dbContext = scope.ServiceProvider.GetService<ApplicationDbContext>();
			if (dbContext.Database.IsRelational())
			{
				dbContext.Database.Migrate();
			}
		}
		
		-En subsiguientes peticiones http, no se correran las migraciones.
		-En appsettings.json tenemos que tener los atributos para que se corra la la app.
		-Nos llevamos todo de development a apssetings.json.
		Antes
		{
		  "quien_soy": "appsettings.json (producción)",
		  "Logging": {
			"LogLevel": {
			  "Default": "Information",
			  "Microsoft.AspNetCore": "Warning"
			}
		  },
		  "AllowedHosts": "*"
		}
		
		DESPUES
		{
		  "ConnectionStrings": {
			"AzureStorageConnection": "DefaultEndpointsProtocol=https;AccountName=bibliotecaapiudemybortx;AccountKey=sv9b7dZjuHZeou+y0p3R0UCqffPdhoBJ7VKKEC6Rv3pL2YdNX5PRd4fdFGsJF/Bh+6NZ90/lPJK2+AStWIJpBw==;EndpointSuffix=core.windows.net",
			"redis": "redis-14763.c57.us-east-1-4.ec2.redns.redis-cloud.com:14763,password=TdsB1nOQ6PQQ7PgausYiLpGij33BZdxU"
		  },
		  "Logging": {
			"LogLevel": {
			  // "BibliotecaAPI.Controllers.AutoresController": "Trace",
			  "Default": "Information",
			  "Microsoft.AspNetCore": "Warning"
			}
		  },
		  "llavejwt": "ALSKDMALSKM3LK4M3LK43M43LAMSDLKASMDALSKDMASLKDMALK3M4LKM4L3KM5",
		  "origenesPermitidos": [ "http://127.0.0.1:5500" ]
		}
		
		-Quito el DefaultConnection porque  es el que indica que vamos a usar la entidad manejada.
		-Con esto ya le damos a Publicar WebApi hacia Azure App Service.
		-No va a funcionar porque no hemos configurado nuestro servidor de bbdd para que acepte conexion de Azure App service.
		-Vamos al portal de azure grupos de recursos > pinchamos en biblioteca api
		-Se pincha en App Service.
		-Se guarda este nombre: BibliotecaAPI20260117144241
		-En el buscador se busca Identitidad: Status On.
		-Pinchamos en el servidor: Sql Server.
		-Se busca entra en el buscador izquierda.
		-Aqui me asigno como administrador para configurar la conexion entre bbdd y azure apps ervice.
		-Establecer Admin: borja...Guardar.
		-Vamos a la BBDD.
		-Editor de consultas.
		-Se le acepta la IP.
		-Lanzamos esto:
		CREATE USER [tu-app-service-name] FROM EXTERNAL PROVIDER;
		ALTER ROLE db_owner ADD MEMBER [tu-app-service-name];
		
		-Volvemos al app-service que tenemos variables de am,bientes.
		-En configuracion.
		-Se puede usar para guardra la info del appsettings-json.
		-Asi, se puede guarda ahi la llave_jwt y asi tienes un valor secreto como variabel de ambiente en servidor.
		-Idem con DefaultConnections.
		
		-OJO!! Ha habido que hacer muchas modificaciones para que funcione....Sobre todo en Program.cs y lanzar las migracioens desde local...
	
	203. Publicando en Azure - Usuario y Password
		-Se usa una identidad manejada para permitir la comunicacion entre web api y bbdd.
		-Quizas se quiera usar user y password en el ConnectionString.
		-Si se quiere esto, se va a la bbdd de Azure > izuiqerda se busca cadenas de conexion y se coge
		ADO.NET (autenticación de SQL)
		Server=tcp:bibliotecaapidbserver11.database.windows.net,1433;Initial Catalog=BibliotecaAPI_db;Persist Security Info=False;User ID=gavilanch;Password={your_password};MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;
		
		-Esto es autenticacion de SQL y se colocaria password y lo llevas donde quieras 
		 y desde ahi peudes usarlo.
	
	204. Publicando en Azure usando VS Code
		-Lo primero cuenta en Azure.
		-Se abre al nivel de la solucion en Vs Code
		-Terminal: dotnet publish bibliotecaAPI/bibliotecaAPI.csproj -c Release -o bibliotecaAPI/bin/Publish.
		-Se instala extension: Azure App Service.
		-Se va a pestaña de Azure de las extensiones.
		-Te loggeas y te salen recuross.
		-Salen App Services y le damos a crear nuevo WebApp: biblioteca-api-vs-code
		-.NET9 (STS); Basic V1
		-En la carpeta Publish > boton derecho > deploy to web app.
		-No va a iniciar porque hay que configruar la comunicaicon entre el azure apps ervice y bbdd.
		-Se va al App Service
		-En Identidad > ManagedIdenttiy y configruamos bbdd para que sea accedida por este Azure App Service.
		-Se crea servidor de bbdd.
		-Permitr que servicios de Azure se conecten a este servidor.
		-Se crea la bbdd....
		-Parecido a VS Code todo....
	
	205. ¿Qué hacer si la app no sube?
		-Vamos a ver como visualizar un error en prod cuando app no arranca.
		-¿Cómo veo la línea de código que hace que app no arranque?
		-Se ve que falla al publicar...No me dice donde por temas de seguridad, sino revelaria info confidencial de mi app.
		-Vas al console en el appservice y se peuden ejecutar comandos.
		-Haces BibliotecaAI.exe
		
	206. Viendo errores en PROD
		-Vamos a aprender a ver error en tiempo de ejecucion mientras app funciona.
		-Para evr detalle de error 500 por ejemplo:
		-Dos opciones: Hay tabla de errores que es SQl Database > dbo.Errores.
		-Sino hay tabla de errores, otra opcion es usar Application Insights que tenemos solucion de Azure que nos permite conocer distintos
		 detalles acerca de la ejecucion de nuestra app .
		 Se van a ver errores no manejados.
		-Hay que instalarlo desde el app-service.
		-Luego Investigate > Failures.
		-Ahi puedo ver errores de la app...
		
	207. Publicando en IIS
		-Publicar webAPI en IIS.
		-Se va a instalar el hosting-bundle.
		-Esto va a eprmitir hostear aplicaciones de asp.net core en nuestra maquina.
		-Es Wizard y se instala.
		-Meterse a buscar el hosting bundle para net9: https://dotnet.microsoft.com/es-es/download/dotnet/9.0
		-Descargar e instalar.
		-Se mete en appsettings.json el DefaultConnection que está en el de Development.
		-Usamos esto:
		"DefaultConnection": "Server=DESKTOP-LATBQ6O;Database=WebAPIBibliotecaDB;Integrated Security=False;User Id=;Passwors=;TrustServerCertificate=True",
		
		-Ese Id y Password sale de SQL Server Management Studio y sale de ahí. Lo creamos desde ahí.
		-Esto es para que el usuario se peuda conectar dede mi app de asp.net core en IIS hacia una instancia de SQl Server.
		-En la conexion > Boton derecho > Propiedades > Security > Sql Server and Microsoft Authentication Mode.
		-Esto es para que podamos conectarnos con un usuario SQL a una instancia de SQl Server.
		-Se va dentro de la conexión a Security > Logins > Nuevo Login.
		-Se le llama bibliotecaapi
		-SQL Server authentication: 1234
		-Quitar checboxes de Enforce password policy.
		-User mapping para indicar que con este usuario voy a poder conectarme a una cieta BBDD. Clicamos en Db Owner.
		-Y Ok.
		-Se va a appsettings.json y se coloca el name del login en el "User Id" y en "Password" lo que toca.
		-Se podría colcoar DefaultConnection en una variable de ambiente para mayor seguridad pero bueno....
		-Ahora se da click derecho en el proyecto > Publicar > Nuevo > Folder > Siguiente > OK. Se accede a la carpeta cuando se cierra la ventana de dialogo.
		-Hay que darle a Publicar porque sino te dice que no existe la ruta que crea al darle apublicar...
		-Se coge todo el contenido, se va a C:// y se mete carpeta inetpub, se mete la carpeta bibliotecaapi y se meten los archivos.
		-Se seleccionan todos los ficheros del directorio
		-Ahora queda montar el webapi en IIS.
		-IIS no viene configurado por defecto.
		
		-Se selecciona lo mismo que tiene el en Panel de Control > Programas > Activar o Desactivar las caracteristicas de Windows. SEGUIR CURSO!!
		-Tecla Windows + IIS.
		-Sitios > Click derecho > Agregar sitio web.
		-Agregar nombre: bibliotecaapi.
		-Se busca en C:// la carpeta de bibliotecaapi en inetpub.
		-Puerto 4852.
		-Ok.
		-Abrir en navegador + /swagger...
		-Probar GET Autores.
		-CUIDADO CON EL FICHERO web.config y las migraciones que no estén en el Program.cs....Puede reventar....
		-El resto es seguir el video...
		-Tambien ejecutar dotnet BibliotecaAPI.dll. Esto da una idea del error que se monta...
		-iisreset para reiniciar servicios, reiniciar el ordenador...
	
	208. Integración Continua y Entrega Continua
		-Cuando trabajamos solos en un proyecto pequeño, click derecho > Publicar no es malo.
		-Es lo apropiado. Sobre todo cuando hacemos pruebas de concepto o trabajamos solos.
		-O donde el proyecto de vida del proyecto es corto.
		-Cuando se trabaja en un equipo de desarrolladores grande programando de manera activa, es recomendable usar Integración Continua y Entrega Continua.
		-La integración continua se refiere al proceso automático de compilación y corrida de pruebas automáticas de nuestro proyecto.
		-Así, podemos asegurar que el código de Felipe no dañe el de Claudia y viceversa.
		-CI nos ayuda a garantizar que la app funcione en un ambiente diferente al de mi computadora.
		-Puede que funcione en mi PC pero no en PROD. Para eso hay un servidor donde se puede compilar la app y verificar que pruebas automaticas funcionan correctamente.
		-Opcoionalmente, despuede de CI, hay CD.
		
		-CD se refiere al despliegue del proyecto en un ambiente determinado, ya sea este un ambiente de pruebas o PRO. 
		 Es importante porque ayuda a automatizar el proceso de despliegue y centralizar los permisos para desplegar en un servidor.
		-No vamos a tener muchas personas desplegando prod, sino que será el proceso de CI el que lo hará y a este no se le olvidará correr
		 las pruebas automaticas.
		
		-Tendremos el codigo en un repo como Github y cuando actualicemos code, se dispara proceso de CI/CD
		-Es decir, se compila la app. Si va OK, se corren las pruebas automáticas y si es exitoso, se despliega la app a un entorno
		 determinado.
		-Pudiendo ser este ambiente de QA, staging o PROD.
		-Nosotros para esto, usaremos GitHub Actions.
		
	209. Subiendo el código a GitHub
		-primero, se crea cuenta, se crea Repo.
		-Lo hacemos privado. De esta forma, con Github Actions se da 2000 mins al mes.
		-Si es publico, infinito de tiempo.
		-Se tenía ya el repo montado ys e sube todo....OJO QUE FALTA LA BBBDD....
	
	210. Breve introducción a los Github Actions
		-Con esto se va a poder hacer los procesos de CI/CD.
		-Estos permitern automatizar tareas relacionadas con nuestro repo.
		-Se va a hacer un Hola Mundo via Github Actions.
		-Se le da a GithubActions. Es un fichero de extension yml que es comun a la hora de automatizar estos procesos.
		-on: es bajo que condiciones se peude ejecutare ste fichero.
		-Se peude ejecutar con un oull request, al hacer uso de un boton, cuando haga cambios en git....
		-Los tabas y espacios también son importantes.
		-workflow_dispatch es para ejecutar de forma manual
		-push es que cuando nuestro proyecto reciba cambios, quiero ejecutar este workflow y quiero pasarle argumentos.
		-Aqui se indican las ramas que deben ser actualizadas para ejecutar este workflow. Aqui solo main.
		-Aqui tambien se puede indicar las rutas qe se quiere que sean actualizadas.
		-Puede que haya algunos cambios de ficheros que si quiero que implique que haga compilaciones en el proyecto que es de lo que tarta también la Integración Continua.
		-Le voy a decir que ante el cambio de cualquier fichero dentro de BibliotecaAPi quiero ejecutar este proceso.
		-jobs son las acciones que se van a ejecutar en este workflow. Un job es un conjunto de tareas.
		-runs-on en que am,biente quiero que se ejecute este workflow. El ams barato es ubuntu-latest. Es el mas barato porque de los 2100 minutos esos, si 
		 empleamos windows pues es mas caro.
		-steps son las tareas individuales que vamos a ejecutar.
		-Cuando hay listado de elementos se ve que se usa el guion para diferenciar una tarea de otra por ejemplo.
		-Checkout toma codigo de repositorio y descarga el codigo de proyecto para usarlo o correr las pruebas automaticas.
		-Se busca checkout en el buscador del panel de la dderecha.
		-Se coge lo de uses.
		-Para ver que se ha logrado traer el codigo del repo, se mete otra tarea despues.
		-tree es para mostrar los archivos en carpeta tipo arbol.
		name: Hola Mundo

		on:
		  workflow_dispatch: # ejecución manual
		  push:
			branches:
			  - main
			paths:
			  - 'BibliotecaAPI/**'
			  - 'BibliotecaAPiTests/**'
			  - './gihub/workflows/hola-mundo.yml'
		  pull_request:
			branches:
			- main

		jobs:
		  saludar:
			runs-on: ubuntu-latest
			steps:
			  - name: Muestra mensaje hola mundo
				run: echo "Hola mundo, Felipe"

			  - name: Checkout
				uses: actions/checkout@v6.0.2

			  - name: Listar los archivos del repositorio
				run: |
				  echo "El repositorio ${{ github.repository }} contiene los siguientes archivos":
				  tree    
	
		-Commit y se crea en el main.
		-Se va a Actions y se le da a saludar.
		-Se clica en el workflow y se va viendo que se van ejecutando los diferentes steps que configuramos.
		-Se muestra dónde se encuentra el yml en el repo.
		-Se edita de nuevo en directo y no se quiere que se ejecute siempre que se edita el proyecto.
		-Se comenta lo del push y pull request.
		-Para ejecutarlo manualmente se le da a Run Workflow...
		
	
	211. Implementando la Integración Continua
		-Se va a poder compilar el proyecto y correr las pruebas automaticas para luego emplear la entrega continua y este compilado mandar a Azure.
		-Se crea un nuevo workflow: compilar-y-desplegar.yml.
		-Se van a colocar variables de ambientes que eprmiten definir variables que se peuden usar en el workflow.
		-Esta bien para centralziar aquellas cosas que pueden cambiar como la version de .NET.
		-Aunque vamos a compilar y desplegar a maquina de Windows en Azure, se puede hacer este proceso desde ubuntu.
		-Ademas de definir una variable de ambiente a nivel del workflow completo, se puede definir variable de ambiente a nivel del job.
		-Esto es util si tengo varios jobs y tego variables que se pueden acceder en un job y no en otro.
		-Checkout para traer lo ficheros de repo, luego traer .NET...
		-with es para pasarle argumentos.
		-Luegi se obtienen dependencias de proyecto y compilar.
		-se busca setup .net core sdk en el panel de la derecha.
		name: Compilar y Desplegar

		on:
		  workflow_dispatch:
		  push:
			branches:
			  - main
			paths:
			  - 'BibliotecaAPI/**'
			  - 'BibliotecaAPITests/**'
			  - '.github/workflows/compilar-y-desplegar.yml'

		env:
		  VERSION_DOTNET: '9'

		jobs:
		  build:
			runs-on: ubuntu-latest
			env:
			  proyecto: BibliotecaAPI/BibliotecaAPI.csproj
			steps:
			  - name: Checkout
				uses: actions/checkout@v6.0.2
			   
			  - name: Instalar .NET
				uses: actions/setup-dotnet@v5.1.0
				with:
				  dotnet-version: ${{ env.VERSION_DOTNET }}

			  - name: Obteniendo las dependencias
				run: dotnet restore

			  - name: Compilar
				run: dotnet build --no-restore

			  - name: Realizar pruebas
				run: dotnet test --no-build
			   
			
    
		-Commit > Actions y le damos al build.
		
		-Ha ido OK y vamos a provocar un error a posta.
		-Le ponemos al primer metodo de Program.cs un ABC al final...
		-Se para el proceso en la compilacion y no se ejecutan las pruebas.
		-Se devuelve a como estaba y se rompe una prueba automatica. Por ejemplo, COntrollers > V1 > 
		-En el Get se añade un throw...
		[HttpGet(Name = "ObtenerAutoresV1")] // /api/autores/
        [AllowAnonymous]
        // [OutputCache(Tags = [cache])]
        // [ServiceFilter<HATEOASAutoresAttribute>()]
        public async Task<IEnumerable<AutorDTO>> Get([FromQuery] PaginacionDTO paginacionDTO)
        {
            throw new ApplicationException("Debes borrar esta línea");
            return await servicioAutoresV1.Get(paginacionDTO);
        }
		
		-Son muy importantes estas dos lineas en el proyecto de Testing.
		<Project Sdk="Microsoft.NET.Sdk">
		<IsTestProject>true</IsTestProject>
		
		-Sino en CI no tira....
		-Esta linea da mucho detalle...
		Run dotnet test BibliotecaAPITests/BibliotecaAPITests.csproj --no-build --verbosity detailed
		
		-Ojo con UseStaticFiles en program.cs para prueba sintegradas y ojo con meter el proyecto de pruebas en el sln.
		
	212. Implementando la Entrega Continua
		-Vamos a configurar GitHubActions para hacer despliegue del codigo Azure.
		-Primero hay que configruar el proyecto de Azxure del Azure App Service para que peuda recibir el compilado producido por el 
		 Github Actions.
		-Se va a App Service en Azure > Configuration
		-Se activa esta opcion: Credenciales de publicación de autenticación básica de SCM
		-Overview > Restart para que tome efecto y Download publish profile...
		-Es como descargar un string que va a permitir desde cualquier lugar hacer un despliegue hacia Azure App Service.
		-Se le da a copiar > Se va a Github dentro del repo, Settings > Secrets and Variables > Actions > Colocar secreto.
		-Este string es importante porque nos permite publicar hacia nuestro server.
		-Esto es como avriable secreta para que eprsona que tiene acceso a Workflow no peuda acceder a este secreto.
		-Se va al fichero yml de github actions del video anterior
		-AZURE_APP_SERVICE_UBICACION_PAQUETE: '.' => Esto porque cuando vaya a hacer el despliegue, los archivos de mi webapi estarán en el mismod irectorio en el que estoy, diferente 
		 que si estuviera en una carpeta, sino en el mismo directorio en el que me encuentro.
		-Voy a tener el job del build y del despliegue. Son dos procesos difernetes. Sin embargo, para yo oibtener ejecutables, ddls, apsettings.json,
		 tengo que colocarlo como un ARTIFACT. Un artefacto es aquello que produce mi proceso de Integración Continua, para que otro proceso, otro job, pueda 
		 tomarlo, descargarlo y utilziarlo.
		-Se mete otro step más.
		-Lo de publish 32 bits es porque por defecto en la config del Azure App Service aparece que se crea por defecto con 32 bits.
		- name: Publicar el Web API
		  run: dotnet publish $proyecto -c Release -o miapp --runtime win-x86
		
		-Ahora vamos a colocar los archivos finales como artifact. Upload a build artifact a buscar en el panel derecho.
		-Es util meter el path por si hay avrias carpetas con varios proyectos.
		-A traves del nombre puedo descargar los archivos que coloque en el path.
		
		-Hasta aqui se acaba con el build y se va con otro job, otor proceso distitno (deploy o despliegue).
		-Lo de los permisssions es para que ni acceda al repo, ni descargue nada.
		-Algo cehevere de tener varios jobs coo despliegue y build es que pueden correr en paralelo y es ams rapido todo.
		-Pero, ahora, se necesita que el build acabe antes que el despliegue.
		-Se indica en el needs.		
		-Se va con steps. Se va a adownload a build artifact. Ese name coincide con el name del job de build del Caragr artefacto (se descarga lo que se cargó).
		-Se busca Azure Web App para el siguiente step.
		-Vamos a version 2 porque las 3 tiene error.
		-El publish profile esta en el settings.
		name: Compilar y Desplegar

		on:
		  workflow_dispatch:
		  push:
			branches:
			  - main
			paths:
			  - 'BibliotecaAPI/**'
			  - 'BibliotecaAPITests/**'
			  - '.github/workflows/compilar-y-desplegar.yml'

		env:
		  VERSION_DOTNET: '9'
		  AZURE_APP_SERVICE_NOMBRE: BibliotecaAPI20260117144241
		  AZURE_APP_SERVICE_UBICACION_PAQUETE: '.'

		jobs:
		  build:
			runs-on: ubuntu-latest
			env:
			  proyecto: BibliotecaAPI/BibliotecaAPI.csproj
			steps:
			  - name: Checkout
				uses: actions/checkout@v6.0.2
			   
			  - name: Instalar .NET
				uses: actions/setup-dotnet@v5.1.0
				with:
				  dotnet-version: ${{ env.VERSION_DOTNET }}

			  - name: Obteniendo las dependencias
				run: dotnet restore

			  - name: Compilar
				run: dotnet build --no-restore

			  - name: Realizar pruebas
				run: dotnet test --no-build --verbosity detailed

			  - name: Publicar el Web API
				run: dotnet publish $proyecto -c Release -o miapp --runtime win-x86

			  - name: Cargar Artefacto
				uses: actions/upload-artifact@v6.0.0
				with:
				  path: ./miapp
				  name: build
		  despliegue:
			permissions:
			  contents: none
			runs-on: ubuntu-latest
			needs: build
			steps:
			  - name: Obtener los artefactos
				uses: actions/download-artifact@v7.0.0
				with:
				  name: build

			  - name: Despliegue al Azure App Service
				uses: Azure/webapps-deploy@v2.2.17
				with:
				  app-name: ${{ env.AZURE_APP_SERVICE_NOMBRE }}
				  publish-profile: ${{ secrets.AZURE_PERFIL_PUBLICO }}
				  package: ${{ env.AZURE_APP_SERVICE_UBICACION_PAQUETE }}
		
		-Antes de hacer el commit se va a Azure Web Apps > Configuracion > variables de Entorno > WEBSITE_NODE_DEFAULT_VERSION
		-Version 14.17.0.
		-Apply y Confirm para que el despliegue funcione. Es toe s porque hay u bug que no permite hacer el despliegue correcto desde GithubActions.
		-Ya se le da a Commit en GitHubActions y vemos cómo va el build y despliegue.
		-Asi todo ha ido OK.
		-vamos a ir a Azure al Overview y le damos a Browse para abrir webapi/swagger.
		-Este punto hay que hacerlo así:
			- name: Publicar el Web API
			  run: dotnet publish $proyecto -c Release -o miapp --runtime win-x86 --self-contained true
	
		
		
		
		
		

		 
		
	
		
		 
		 

		
			
		
		
		
		
		
		
		
				
		  
				
		 
		
		
		 
		

		
		
		
		
		
			
		
		
			 
		

		
		
			
		
	
		
		
		
		
		


		
		 
		
		
		
		
		
		
		
		
		

	
		
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		
			
		