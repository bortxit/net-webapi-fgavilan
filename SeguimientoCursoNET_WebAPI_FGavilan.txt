Sección 1: Fundamentos de Web API y HTTP
	1. Introducción
		-Web Api: Aplicaciones web las cuales estan supuestas a ser utilizadas de forma remota usando el protocolo HTTP. Los clientes del 
		 web api son los que hacen peticiones: desktop, movil...
	
	2. Que es un API?
		-Los programas pueden comunicarse entre si porque exponen una API o interfaz de programacion de aplicaciones.
		-Una toma de corriente. En una misma toma peudes conectar una tostadora, un cargador de mv...Es que interactuca como una interfaz que deja pasar corriente a cualquier aparato.
		-Un conjunto de aparatos pueden usar el mismo enchufe para funcionar.
		-Enchufe es API y los aparatos son clientes de API.
		-Web API: Cojunto de interfaces definidas las cuales permiten a un conjunto de aplicaciones externas consumir el software de la aplicación web.
		-Un Web API expone un conjunto de funciones de una app web los cuales consumidos por web apps, moviles....
		-Un API permite que dos aplicaciones completamente distintas puedan comunicarse entre si. Una app de android hecha en Kotlin puede comunicarse con una app web
		 de C# hecha con api.
		-Permite realizar abstracciones que es que permite facilitar el uso de un software sin necesitar saber como funciona internamente.
		 basta con usar las funciones que el API expone.
		-No hay que ser ingeniero electrico ni saber como funciona para enchufar una tostadora a un enchufe, basta con usar el api para poder consumirlas.
		-La Web API se puede evr como un conjunto de funciones de nuestra app web, las cuales pueden ser consumidas por otras apps a distancia.
	
	3. ¿Qué es REST?
		-Es Representational State Transfer.
		-Es un estilo de construir servicios web los cuales se adhieren a un conjunto de principios establecidos.
		-Hay un cnjunto de condicioens que un Web API debe tener para decir que implementa REST.Cuando un Web API respeta estas condicioens, se le llama RESTFUL.
		-Cuando se consume un web api es porque se quiere acceder a sus recursos. En este caso hace referencia a entidades que se quiere consumir de un Web API.
		-Si tenemos un web api que nos permite trabajar con el sistema de una biblioteca, un recuirso es exponer el listado de libros o empelados.
		-Una idea relacionada con rets es la de utlizar metodos http sobre una URL para ejecutar diferentes funcioens de web api: 
			-https://miWebApi.com/api/usuario => Si se hace http get se obtiene lista de usuarios. Si se hace post, se ejecuta crear un usuario.
			 A esto se le llama HTTP CRUD porque se peude crear leer, crear, borrar y actualizar información consumiendo un webapi, utilizando HTTP.
		-No es suficiente para decir que un webapi es restful.
		-Se hablara de los metodos HTTP.
		
		-Nos concentramos en las condiciones que hacen que un webapi sea restful.
		-La ventaja de respetar esas condiciones es que se tienen beneficios añadidos como un software que pueda responder a cambios de requerimientos de negocio de una forma eficiente.
		-No todos los webapis que se hagan tienen que ser restful.
		-REST es una guia para desarrollar webapis. No se tiene que seguir al pie de la letra.
		
		-Seis condiciones de REST:
			1) Arquitectura cliente-servidor.
				-Nos habla de la separacion ente un cliente y un servidor o proveedor.
				-En en caso de los webapis, el servidor es un servidor web. El cliente puede hacer cualquier software.
				-El servidor es un servidor web en el caso de los webapis.
				-El cliente cualquier software capaz de comunicarse usando HTTP con servidor web, app de celular, app de escritorio...
				-Con este pricnipio, se asegura la separacion de responsabilidades entre el servicio de webAPI y los clienets que consumen dicho servicio.
				 Asi WebAPI puede evolucionar en el servidor y eso no tiene que afcetar clientes de nuestro servicio.
			
			2) Interfaz Uniforme: La idea es tener una forma estandarizada de transmisión de la información. Asi forma universal de usar webAPIs comunes.
			   Si sabes consumir un webAPi que no cueste consumir otros.
			   Subcondiciones:
				-Identificación de recurso: Se usan URLs para identificafr recursos: listado de libros....
				-Manipulación de recursos usandorepresentacioens: Si cliente tiene forma de acceder a unr ecurso (URL), con eso se peude modificar el recurso. Se usaran para esto peticiones HTTP.
				-Mensajes autodescriptivos: Todos los mensajes son completos.Indican la informacio necesaria para ser trabajados por el servidor de forma satisfactoria. Peticiones HTTP al servidor.
				 Algo que mensaje puede indicar es el formato en el que queremos la info del servidor con media-types: son identificadores de formato para indicar la forma
				 den que queremos que se nos de la info: json, xml....
				 Cliente tiene poder de pedir info en formato que desea, es servidor responsable de satisfacer la peticion del cliente.
				 Si al peticion del cliente no es razonable, servidor no tiene porque satisfacer.
				 Si se quiere listado de libros de webapi y se quiere en formato img, no tiene sentido y webapi no tiene porque satisfacer esa demanda. 
				 Si es razonable que pida en formato json.
				-HATEOAS: Info que da web api debe incluir links para seguir explorando e4cursos de webapi.
					-Si se pide listado de libros de webapi, estaria bien que cada libro link para ver detalles.
			
			3) Protocolos en estado
				-Cada una de las peticiones realizadas a la web api tiene toda la info necesaria para que la peticion sea resuelta de forma satisfactoria.
				-Si webapi requiere que clientee ste autenticado para acceder y manipular recursos, este debe incluir en solicitud al servidor algun tipo info que lo identifique de forma unica.
				
			4) Cache
				-Las respuestas del webapi deben de indicar cuando se deben guardar en cache.
				-Cuando se habla de cache, se refiere a que cliente puede guardar el recurso dado por una url de forma local, que en subsiguientes peticiones no tenga que ser pedido al webapi sino que
				 se pueda consumir la version local ya que disminuye el tiempo de respuesta que deben esperar clientes de la app. No todo en cache porque pone en riesgo a clientes de trabajar con data desactualizada.
			
			5) Sistema de capas
				-El servicio del servidor debe tener un sistema de capas, donde su evolución sea completamente transaparente para el cliente.
				-Si el servicio usa balanceador de carga, los clienets no tienen porque tener presente este detalle.
				
			6) Codigo en demanda
				-El servicio web tiene la opcion de enviar codigo fuente el cual se va aejecutar en el cliente.
	
	4. Métodos HTTP
		-Manipulacioens a recuross una vez que tengamos URL, eso se realiza usando metodos HTTP. 
		-Los métodos HTTP son un mecanismo del protocolo HTTP los cuales nos permiten expresar la acción la cual queremos ejercer sobre un recurso.
		-Si se tiene un recurso localizado en una URL, si se quiere obtener usuarios se puede hacer una http get a esa URL y si se quiere insertar un post.
		-Los metodos permiten expresar la accion que se quiere hacer sobre un recurso.
		-Como rporgamador, definimos que sucedera en un webapi cuando cliente use un metodo http sobre un recurso.
		-Ademas, se puede definir si metodo http no es permitidosobre un recurso.
		-GET: pedir dtaos del servidor.Se coloca URL en navegador y se presiona enter, navegador manda peticion httpget para indicar a server que queremos obtener info de un recurso.
		 Las representaciones de recuros peuden ser un documento html, xml, json...
		-HEAD: no trae cuerpo de repsuesta, solo cabecera. Se tiee info de tipo de contenido, localidad, status....Es info acerca del mensaje.
		-POST. Enviar info del servodor a traves del cuerpo de la peticion HTTP. Con info que se manda a servidor este puede realizar operacion y dar repsuesta a cliente. 
		 uso comun es insertar info al webapi en BBDD.
		-PUT igual que POST pero tambien para actualizar info en bbdd. Si recurso al que se le hace PUT no existe, puede crearlo en lugar de actualziarlo. 
		 Normalemente no es asi sino, que si se quiere actualziar recurso que noe xiste, se devuelve no encontrado.
		-DELETE: Sirve para decir que se quiere borrar recurso.
		-hay uchos metodos para asociar con lectura, insercion, modificacion y borrado de info.
		-A webapis que utilizan estos metodos para reralizar estos metodos sobre bbdd, se les llama HTTP CRUD.
		-En modelo de madurez de Richardson es modelo madurez nivel 2.
		-PATCH: se usa para realziar actualziacioens parciales a un recurso.
		 Ventaja es que es rapido comparado con PUT, implementacion mas dificil.
		-Habra clase para procesar peticiones para un recurso y esa clase tendra funciones y segun el metodo http usado, se ejecuta una de las funcioens de la clase.
		
	5. Anatomía de una petición HTTP
		-Con webapis, la comunicacion entre nuestros clientes y webapi, se va a realizar usando peticiones http.
		-Una peticio http es un mensaje que manda una computadora  a otra usando protocolo http.
		 Esa peticion hacen clientes de webapihacia neustro webapi. Cuando webapi recibe peticion la procesa y retorna una respuesta que es respuesta HTTP.
		-Los clientes y webapi se comunican usando respuestas y peticioens HTTP.
		-Esos mensajes tienen una estructura:
			-Linea de peticion:
				-Se coloca el metodo HTTP as usar, la URI de la peticion y protocolo a usar. Es decir: METODO-HTTP URI PROTOCOLO-HTTP.
				-URI es direciciondonde se encuentra el recurso, PROTOCOLO-HTTP es el protocolo a usar. Hay avrias versiones del protocolo. Lo normal es el protocolo 1.1
				-Ejemplo de linea de peiticon: GET/api/autores HTTP/1.1 => metodo get, se lee recurso en api y luego protocolo a usar.
				-La segunda parte de una peticion http es la cabecera 
			
			-Cabecera de la peticiones	
				-Es donde se encuentran las cavbeceras. Son metadatos que se mandan en peticion para brindar info sobre la peticion.
				-Cada cabecera se especifica con un nomnbre, luego dos puntos y seguido por valor de una cabecera => Host: en.wikipedia.org.
				-El nombre de la cabacera es host y lo otro es su valor. La cabecera host indica dominio de servidor.
				-Otra cabecera => Cache-control: no-cache. Puede haber multiples cabeceras.
				-Ejemplo de petición http con su linea de peticion y cabecera:
					GET/api/autores HTTP/1.1
					Host: wn.wikipedia.org
					Cache-Control: no-cache
					
					Se ve que primera linea es la linea de peticion y devajo de esta se encuentra la cabecera de la peticion que se compone de varias
					cabeceras individuales: Host y cache control que son cabeceras estandar que ya tienen un proposito definido. Se tiene liberatd de usar nuestras
					propias cabeceras como cuando necesitamos expresar uestra propia metadata de nuestra peticion. Lo unico que se necesita es mandarl en la cabecera de la peticion HTTP.
			
			-Cuerpo de la peticion.
				-Es donde se coloca informacion adicional que se va a enviar al servidor. Se tieen libertad de colocar virtualmente lo que se quiera: nombre y usuario, respuestas a una encuesta....
				-El cuerpo respresenta el cntenido perse que se quiere transmitir.
				-Peticiones get no usan cuerpo porque no se tiende a enviar datos complejos a la hora de leer información del servidor.
				-En post si se suele usar cuerpo para colocar lo que se quiere enviar.
				-Ejemplo Hola: Sirve para mandar lo que sea el cuerpo, desde un saludo hasta informacion mas esttructurada.
					Aqui se tiene info en formato json que representa el cuerpo de la peticion
					{
						"Nombre": "Felipe Gavilan·,
						"Edad": 999
					}
					
		-Ejemplo: Se va a ver peticion HTTP con sus tres partes:
			POST/api/autores HTTP/1.1
			Host: miWebApi.com
			Content-Type: application/json
			Cache-Control: no-cache
			
			{
				"Nombre": "Felipe Gavilan·,
				"Edad": 999
			}
			
			La peticion es post a un recurso /apoi/autores.
			Hay una cabecera compuesta de tres cabeceras.
			Finalmente, cuerpo de peticion.
			
		-Respuesta HTTP: Cuando el cliente nos envia un peticion HTTP, el servidor debe de responder con una respuesta HTTP.
		 la respuesta tiene su propia estructura.
		 La respuesta HTTP tiene su propia estrcutura: Linea de estatus, cabecera y cuerpo.
		 
		-En la linea de estatus nos indica el estatus de la peticion, es decir, si fue exitosa, error o si se requiere accion.
		-La cebecera es un conjunto de acbeceras igual que cabecera de peticion. El servidor peude mandar tantas cabeceras como queire. 
		-El servidor puede mandar un cuerpo con data que desee. e3s opcional y es fundamental a la hora de usar paginas web, ya que es a traves del cuerpo donde se recibe el HTML 
		 de una pagina web que se quiere ver en el navegador.
		
		Ejemplo:
		HTTP/1.1 200 OK
		Date: thu, 03 Jan 2019...
		Server: gws
		Accept-ranges: bytes
		Content-Length: 68894
		Content-Type: text/html; charset=UTF-8
		
		<!doctype html></html>
		
	
	6. Códigos de status HTTP
		-Cuando se hace peticion HTTP a servidor, recibimos respuesta HTTP. 
		-Entre la informacion recibida, esta el codigo estatus de la respuesta. El codigo es un numero que indica el rdo de la oepracion.
		-Son numeros de 3 digitos y un nombre. El primer digito indica la categoria del status.
		-Existen 5 categorias:
			-1xx informacional
			-2xx exitoso
			-3xx redireccion
			-4xx error del cliente
			-5xx error del servidor
			
		-Ademas de tres digitos, tienen nombre: 404 Not Foudn de no encontrado. Asi cuandos e recibe codigo de status se recibe un nombre.
		-En conversaciones normales hablaspor cdoigo, es decir, 404.
		
		-1xx Respuestas Informativas
			-Cuando se manda una peticion HTTP al servidor, el servidor verifica si procesa la solicitud y de ser asi, devuelve resopuetsaal cliente de que va a sser procesada y que debe
			 esperar respuesta final. Quizas la respuesta llega en unos segundos, es respuesta temporal y no final (intermedi).
			-Algunos ejemplos son: 100 Continue quiere decir que cabecera ha sido recibida y que el cliente deberia enviar el cuerpo de la peticion a continuacion si aplica.
			 Es eficiente de intercambnio de paquetes porque da oportunidad al servidor de denegar una epticion http sin tener que recibir y procesar todo el cuerpo de la peticion.
			-Ademas, desde el punto de vista de la seguridad de la info del usuario, el servidor puede detectar si conexion va a ser insegura. Es decir, usa HTTP y no HTTPS y peude denegar 
			 peticion sin que el cliente envie sus datos, enviando el cuerpo de la peticion sobre una conexion insegura.
			-101 Switching protocol que es cambiando protocolos. Esta respuesta se da cuando cliente pide un cambio de protocolo y servidor esta de acuerdo con la demanda.
			 Un ejemplo de esto es cuando el cliente pide al servidor actualizar la conexion para usar websockets.
		
		-2xx Exitoso
			-Ejemplos son: 200 OK. Significa que oepracion exitosa. Por ejemplo, si se hace una peticion get sobre un recurso un 200 ok, es que el recurso ha sido devuelto en la respuesta.
			-201 Created: la peticion se ha completado. Resultado de la creacion de nuevo recurso. Es respuesta exitos, especifica que debemos retornar cuando peticion resulta en crar nuevo recurso.
			Por ejemplo, que envie nuevo libre y sea insertar en BBDD.
			-202 Accepted: Peticion ha sido aceptada para ser procesada pero el procesamiento no ha acabado. Se sua para largos procesos en los que usuario no espera un rdo inmediato, sino
			 que en el futuro se le va a indicar dicho rdo. Por ejemplo en envio de correos masivos, se peude indicar que se quiere mandar un correo a miles de sus clientes.
			 Esto no es necesariamente que se hace de una vez sino que el servidor reciba epticion, devuelva 202 y ene l futuro puede hacer envio masivo de correos.
			-204 No Content: Significa que no hay contenido. La peticion ha sido realizada con exito y no se va a retornar un cuerpo en respuesta.
			 El servidor solo debe enviar la linea de respuesta y la cabecera de la respuesta.
			
		-3xx Redirección
			-Esta categoría de codigo de status indica que el cliente toem acciones adicionales cpara completar peticion. En ocasiones, esta accion ocurre de forma automatica sin que el usuario tenga que hacer nada.
			-301 Move permanently: Se usa para indicar una redireccion permanente de la URL. Cualquier link que apunte aesta URL debe ser actualizado por la nueva URL correcta.
			 Dicha URL correcta, la devuelve el servidor en cabecera location.
			-302: Found. Indica que el recurso solicitado se encuentra en una diferente URI de forma temporal dado que nueva location es temporal se necesita que el cliente siga haciendo la peticion
			 a la URL original en elfuturo.
		
		-4xx Error del cliente
			-Esta categoria indica que el cliente ha cometido algun error a la hora de hacer la peticion. La naturaleza del errores determinada por el codigo de status.
			-Algunos ejemplos de codigos de status:
			-400 Bad request: el servidor no puede finalizar la peticion por error del cliente, es un error generico. Lo normal es que en el cuerpo de la respuesta se coloque una explicacion de que
			 fue lo que salio mal para que el cliente peuda corregirlo e intentar peticion de nuevo. Si el usuario llega a formulario y campo nombre es obligatorio y no lo llena y le da a enviar, o normal es que servidor
			 devbuelva error 400 y el cuerpo indique que campo nombre es requerido
			-401 Unauthorized: Esto quiere decir que usuario necesia loggearse en nuestro sistema para poder realizar accion que quiere.
			-403 Forbidden. Se envia cuando el usuario a pesar de estar autenticado, el mismo no tiene permisos suficientes para realziar accion que queire.
			-404 Not Found: recurso no ha podido ser encontrado.
			-405 mehtod Not Allowed: El emtodo no esta disponible para recurso solicitado: put, delete, get....
			-408 Request Timeout: A la peticion se le acabo el tiempo. El servidor tuvo timeout procesando. Esto es cuando peticion tarda mas tiempo del permitido.
		
		-5xx Error del servidor
			-Esta categoria indica que el servidor ha fallado en satisfacer la peticion. Estos errores son difernetes a errores indicados en categoria 4 porque en categoria 4 se entiende que el error
			 es del usuario pero en la 5, el problema radica en servidor.
			-500 Internal Server Error: Esto es error generico que puede ser cualquier cosa. Si codigo de api da error porque no peude conectarse a BBDD, pues error 500
			 se sirve al cliente dado que no es su culpa que nuestra api haya percdido comunicacion con bbdd.
			-503 Server Unavailable: el servidor no disponible en estos momentos. Puede ocurrir que app de error y no sube,
			
				
	7. Resumen
		-Se ha visto fundamento de webapi y http. Se ve que api es abstraccion que permite usar un sistema sin tener que entenderlo ointernamente.
		-Un webapi sirve para permitir a cleintes usar servicio web a distancia usando protocolo HTTP.
		-REST significa transferencia de estado representacional y es un estandar que declara 6 ppios que prometen tener webapi que siga buenas practicas.
		-peticion HTTP: linea de peticion, cabecera y cuerpo.
		-Los metodo http indican la accion que se quiere hacer sobre un recurso.
		-Los codigos de status HTTP permiten indicar el resultado de la peticion del cliente. Con ese codigo se peude decir si peticion exitosa, si ha habido error del cliente...
			
			
Seccion 2: Configurando el ambiente
	9. Introducción
		-Es importante conocer el stack de desarrollo que se va a usar y se debe preparar el entorno de desarrollo.
		-Se habla de .net, C#, asp.net core. Luego se instalaran herramientas.
		
	10. ¿Qué es .NET?
		-.NET es una plataforma de desarrollo que sirve para desarrollar distitnos tipos de aplicaciones. Esas apps podran correr en Linux, Windows, entre otros.
		-Se peudend esarrollar apps de escritorio, web, juegos, celulares....
		-Es improtante destacar que noe s elnguaje de programacion sino que es un entorno en el que se peuede ejecutar disittntos tipos de apps.
		-Lenguaje de prorgamacion para .NET: C#, F# y Visual basic.
		-El mas popular es C#. Es lenguaje multiparadigma y es especialmente conocido por ser orientado a objetos, igual que Visual Basic. F# es lenguaje funcional.
		-.NET creado por Microsoft en 2002 para correr en Windows. La idea era framework que asistiera a la hora de hacer apps.
		-Este framework se encarga de cosas como manejos de memoria etc.
		-Permite escribir code en disitntos lenguajes que peuden comunicarse entre si.
		-Se peude llaamr code de visual basic desde C#.
		-.NET llego hasta la version 4.8. Un cambio de vision en mcirosoft llego a conclusion que debia abrrise, no debia ser framework exclusico de Windows
		 sino que multiplataforma y mas rapido y ligero.  Por eso en 2014 aparece .NET Core.
		-A la version vieja se le llama .NET Framework y llego hasta version 4.8- .NET Core es la version nueva y salio en 2016 en version 1.
		 Año a año salieron versiones .NET Core 2 y 3. Para evitar confusiones ya que .NEt Framework llego a la version 4.8, para no confundir con .NEt Core 4, saltaron 4 y se fueron al 5.
		 Ya que .NET Framework no llego a la version 5, los genios del marketing de Microsoft dejaron de llamarle Core y simplemente le llamaron .NET 5 y salen versiones. En noviembre de cada año sale una version
		 nueva. El calendario es predecible de neuvas versiones. 
		-.NET Framework es la version vieja que solo corre en Windows. .NET Core corre en difernetes SO. A partir de version 5, se llama .NET 5 y no .NET Core 5.
		
	11. ¿Qué es C#?
		-En .NET se peuden usar varios lenguajes como C#, F# y Visual basic.
		-Es un lenguaje multiparadigma y fue creado por Microsoft en el año 2000. Aunque podemos usar diferenets lenguajes en .NET, el mas usado es este.
		-Lenguaje es parecido a Java y C++.
		-Con C# se pueden crear app web, moviles que corran en Android y IOS, se peuden crear app interactivas con Blazor, se peuden hacer app de escritorios...
		-Se peude prorgamar para un mundo de apps.
		-Que sea multiparadigma significa que permite disitntos paradigmas como lenguaje orientado a objetos y funcional.
		-Es un lenguaje fuertemente tipado. Eso queire decir que reglas de lenguaje pueden ser enforzadas en tiempo de compilacion. Si escribes codigo no valido en C# te daras cuenta en seguida.
		-En lo que respecta a la programacion orientada a objetos, C# es basado en clases. Gran parte del tiempo que se desarrollen apps basadas en C#, estaremos trabajando en clase. COn clases
		 se vana  poder encapsular partes de aplicaciones en unidades que contienen datos y comportamientos. Se va a poder modelar el comportamiento de nuestros programas en clases que inetractuan entre si.
		 Habra clases que se vana a necargar de procesar peticiones HTTP, clases que vana a trabajar con acceso a BBDD, otras se encargan de logica de negocio como calculo de impuestos.
		-Asi,  se tiene app organizada y mas facil de desarrollar.
		-En lo que respecta a paradigma funcional, C# permite trabajar con funciones de priemra clase que se refiere a que se peuden realziar operaciones como pasar funcioens como params a 
		 otras funciones, retornar funciones como rdo a otras funciones, asignar funciones a variables e incluso trabajar con funciones anonimas.
		-Un uso practico que se peude dar a la programacion funcional de C# es LINQ View y expresioens lambda. De esta forma, usando el paradigma funcional, se peuden consultar bbdd, apoyandonos en una libreria 
		 llamada Entity Framework.
		-C# es lenguaje amplio. Se usara ara desarrollar webapi y para ello se usara asp.net core.
	
	12. Introduccion a ASP.NET Core.
		-Es un framework para desarrollar aplicaciones web.
		-Este es multiplataforma lo que quiere decir que puede correr en diferentes SO como Windows, Linux o MACOS.
		-ASP significa Active Server Pages. La diea es que es tecnologia para desarrollar sitios web dinamicos y contenido variara dependiendo de factores.
		-En nuestor caso, se trabaja con webapis. la mision de ASP.NET Core es ponernoslo facil en lo que respecta a funcionalidades comunes de distintas
		 apps webs. Es decir es framework  que ofrece suficiente funcionalidad para no tener que estar reinventando la rueda con cada app que hagamos.
		 ASP.NET Core viene con sistema de ruteo que permite indicar que funcion se quiere usar ante peticion HTTP.
		-Tambien tiene sistema de usuarios que permite registrar usuarios en nuestras app.
		-Viene con sistema de inyeccion de dependencias que nos permite aplicar principios de desarrollo de software como principio de inversion de dependencias
		 donde se puede hacer que clases dependan de abstarcciones y no de tipos concretos.
		-Otra cosa importante es la velocidad. A medida que .NET va mejorando, se introducen mejoras, a veces por el simple hecho de actualizar web api a nueva version, 
		 y sin realizar cambios de codigo, obtienes webapi mas rapido.
		-Es importante separar ASP.NET de ASP.NET Core. Esto es igual que la diferencia entre .NEt Framework y .NET Core.
	
	13. Controladores y Minimal APIs
		-Para crear webapis, hay dos opciones: usar controladores o minimal APIs.
		-Se comienza hablando de controladores. 
		-Un webapi permite obtener clientes que se comuniquen con api a traves de una peticion HTTP. Al recibir dicha peticion, nuestar app, tiene que ejecutar alguna funcion.
		-A esa funcion se le llama accion. Una accion en C# es un metodo de C# que maneja peticiones HTTP.
		-Luego, la clase que contiene los metodos de accion es un controlador.
		-Por tanto, un controlador se encarga de agrupar metodos de accion. los agrupa de forma logica. En webapi de peliculas se peude tener un controlador de actores qe agrupa acciones
		 relacionadas con actores. Crear actor, borrar actor....
		-Controlador permite definir logica global que aplicara a acada accion. Por ejemplo, si es necesario que clien6te este registrado en app para acceder a las acciones del controlador,
		 pues se puede colocar esa configuracion en un solo lugar a nivel del controlador.
		-Se muestra un controlador de ejemplo, WeatherForecastController que se crea por defecto en nuevas apps de webapi.
		-Encima de este hay configuracion de rutas que indica a que ruta hay que hacerle las peticiones HTTP para ejecutarse las funciones de este controlador.
		-Hay atbto llamado API Controller que realzia serie de configuraciones por defecto en nuestro webapi.
		-Se uede evr que como cualquier clase, hay constructor en el que se esta iyectando un ILogger que basicamente nos permitehacer loggin en nuestra app.
		-Hay un metodo get() al que se le llama accion y lo que hace es responder a una peticion HTTP realizada sobre nuestro webapi.
		-Es decir, si cliente hace petoicion a webapi, en este caso hacia la ruta de ForecastController, si esa peticion es de tipo HTTP,
		 pues se espera que se ejecute esa funcion. Esa accion responde a accion GET porque se tiene atrubuto HTTPGet decorandola.
		 Se peuden Tener otras funciones y metodos.
		 Se puede tener emtodo put, delete...
		 Asi como se tiene WeatherForecastController, se podria tener un GeneroController para generos de peliculas etc.
		 En GeneroController se tendran acciones relacionadas con entidad de Genero.
		 Asi es como se organiza unwebapi basado en controladore.
		
		
		MINIMAL APIs.
		-Permiten construir webapis con menos code y mas rapido.
		-No se trabaja directamente con controladores, sino que se trabaja directamente con acciones o endpoints.
		-En el caso de minimal apis se llaman endpoints.
		-Se coloca lo que se quiera que suceda ante una peticion http a un endpoiint justo al lado.
		-Son versiones minimalistas de webapis, es decir, remueven las cosas que no son esenciales.
		-Menos poderosos que los controladores pero mas rapidos y eficientes.
		-Se ve ejemplo y se tiene funcion de mapget que permite configurar endpoint que va a responder una peticion HTTP get. La ruta de esa peticion es /weatherforecast que es el mismo caso que los controladores.
		-Al lado se tiene parametro que es expresion Lambda y tiene el cuerpo del endpoint y es lo que se va a ejecutar cuando se reciba una peticion httpget hacia la ruta.
		-No se tiene que construir una clase con su controlador y tal.
		-Es mas rapido en terminos de velocidad. Los controaldores tienen mas funcionalidades y son mas poderosos.
		
	14. Instalando .NET
		-Para trabajar con ello, hay que instalarlo.
		-Hay que ir a dotnet y descargar.
		-Se instala la version mas reciente de .NET. Se puede instalar en Windows, Linux, distitnas arquietctruas y distintos SO. Para ver opciones se pincha en All .NET 9.0 Downloads.
		-Se coge SDK *64 de Windows.
		-Windoews + R; cmd; dotnet --version.
	
	15. Instalando el EF CORE CLI
		-Se instala el Entity Framework CLI. Es decir, herramienta de linea de comandos de Entity Framework Core.
		-Independiente a usar VS o VS Code, se necesita para cuando se vaya a publicar webapi en PROD para aplicar las migraciones en ls BBDD de PROD.
		-Se busca en google EF CORE CLI, se pincha primer link y se instala herramienta para interactuiar con entity framework core desde linea de comandos.
		
		
	16. Instalando Visual Studio
		-Disponible para Windows. Se coge la version Community que es gratis y permite hacer de todo.
		-Aparece Workloads que son herramientas que vamos a tener disponible spara poder trabajar.
		-Esto hace referencia a tecnologias con las que vamos a querer trabajar: Python, Node JS....
		-Nosotros usaremos ASP.NET Core, Azure, .NET desktop para winforms etc....
		-Luego ya instalar.
	
	17. Instalando Visual Studio Code
		-Se instala version de Windows.
		
	18. Instalando SQL Server
		-Se instala SQL Server developer edition.
		-SQL Serve es el motor de BBDD que se va a usar en este curso.
		-La edicion de desarrolaldor o developer edition es una edicion completa para hacer desarrollos y aprender con esa version.
		-Con edicion competa se refiere a que trae todas las caracteristicas que tien version profesional de SQL Server solo que esta creada para ser utilizada en un entorno de desarrollo.
		-Ahora es lña version Express o Developer...
		-Se instala SQl Server Management Studio (SSMS) que sirve para voisualizar BBDD, poder hacer querys etc.
		-SQl Server hace que las bbdd funcionen, el otro lo que hace es interactuar con bbdd.
		-En la conexoin hay que darle a Trust Server Certificate por ser maquina local y confias.
		
	19. Instalando Postman
		-Es un cliente para realizar peticiones HTTP de forma sencilla. Se va a usar Postman y Swagger.
		-Se puede hacer el tipo de peticion que se quiera PUT, GET, DELETE...
		-Hay que ir a Settings y desactivado el Send no-cache header porque se quiere usar cache y descativar SSL certificate verification porque permite relajar las reglas de seguridad para no necesitar certificado SSL
		 valido para la app.
		 
	20. Creando el WebAPI con VS
		-Se le da a crear nuevo proyecto y hay que buscar empty => ASP.NET Core Empty.
		-Se le llama HolaMundoWebAPI.
		-Se selecciona .NET 9 y se crea.
		
	21. Creando el Web API con VS Code
		-Se crea carpeta donde se quiere crear proyecto.
		-Se pulsa Shift + Boton derecho para abrir una ventana de powershell.
		-Se pone el comando dotnet new list para que liste los tipos de proyecto que puedo crear con dotnet cli.
		-Se queire crear ASPN.NET Core Empty porque se quiere crear desde cero el webapi.
		-Hay un shortname que indica que hay que poner "dotnet new web".
		-Se añade -o de output para asignar nombre a mi webapi y colocar en una carpeta.
		-dotnet new web -o HolaMundoWebAPI.
		-Se hace cd a esa carpeta y se abre Visual Studio con "code .".
		-Se pueden usar extensiones que son como plugins que son aditamentos que se pueden agregar a VS Code para trabajar con una tecnologia.
		-Para trabajar con C#, extensiones de C#.
		-Se instala C# dev kit.
		
	22. Explorando el Web API - Soluciones y proyectos
		-Se va a explorar los archivos de la app.
		-Se va al Explorador de soluciones. Se va a ver el proeycto de HolaMundoWebAPi. E sun archivo de extension csproj.
		-Es un fichero de configuracion de un proyecto.
		-Un proyecto es un grupo de archivos que van a ser compilados a algo que se le va a poder dar uso.
		-Por ejemplo, proeycto es WebAPI, app de escritorio, de consola....o libreria de clases.
		-Una libreria de clases es un proyecto que sirve para compartir codigo entre difernetes proyectos.
		-En un csproj tiene configuraciones de nuestro proyecto. por ejemplo, esta hecho para .NET9.
		-Tambien dice que utilizamos tipos de referencia No Nulos.
		-Estos ayudan a evitar errores de referencia No Nulos.
		-Abajo habra paquetes nuggets instalados que son como librerias de clases es proyecto que permite compartir codigo para que sea reutilizado.
		 Es parecido. Es libreria de clases que descargamos para utilizarla en nuestro proyecto.
		 Osea es com de internet que lo descargas y reutilizas en proyecto. A traves de paquete nugget puedes descargar proyectos 
		 de Microsoft o personas individuales y usar el code que nos proveen
		-Encima de este fichero esta la solucoin que es un conjunto de proyectos relacionados entre si.
		-Se puede tener una solucion que peude tener varios proyectos: proyecto de MAUI, proyecto de webapi...Esos estaran relacionados bajo una solucion.
		-Un proyecto es un cnjunto de archivos que podemos compilar para darles uso como una app web y solucione s cjto de proeyctos.
	
	23. ¿Qué es Nullable?
		-Eso es una configuracion que se llama tipo de referencia no nulo que basicamente nos obliga a ser explicitos acerca 
		 de la naturaleza de los tipos de referencia de nuesta app. Es decir, que no se pueda asignar Nulo asi libremente, sino que
		 se tenga que indicar cuando un tipo der eferencia puede contener nulo.
		-En C# hay dos tipos de dato que son los tipos de valor y tipos de referencia.
		-Un tipo de valor es cuando la variable contiene la instancia del tipo. Es cuando se tiene una varuiable => int edad y en esa variable esta numero 99. Y eso es porque int, el tipo entero, 
		 es ejemplo de tipo de valor.
		-En un tipo de referencia es cuando la variable contiene una referencia a la instancia del tipo.
		-Por ejemplo, string nombre = "Felipe";
		-Esto es un ejemplo de tipo de referencia.
		-Los string son como tal un tipo de referencia.
		-Quiere decir que la variable no contiene el valor Felipe sino una referencia a ese valor que se encuentra en un lugar en memoria.
		-Como eso es un tipo de referencia es que apunta a un lugar en memoria. Que pasa si borro la referencia hacia donde apunta el nombre?
		 Si se pone nombre = null; no pasa nada y no apunta a ningun lugar. En un tipo de valor no se peude decir esto porque al no ser un tipo der eferencia, 
		 no puedo asignar nulo porque no es un valor, es la carencia d euna referencia. Es decir, no se le puede asignar un null porque es unn tipo de valor.
		-Se tiene advertencia y es referencia a esta configuracion del proyecto. puedo tener un nombre que es un string que es un tipo de referencia
		 lo que quiere decir que no contiene un valor en si sino una referencia a un valor en un lugar en memoria.
		 Ahora, no se ah dicho que este string en algun momento opodria contener nulo y es peligroso.
		 nombre.toUpper() da error en tiempo de ejecucion por que es nulo y nulo.toUpper() va a dar error de referencia nulo.
		 porque se esta esta intentando aplicar toUpper a la nada.
		-Lo que el tipo de referencia no nulo configura es que yo tenga que ser explicito a la hora de declarar un tipo de referencia que peude contener nulo.
		-Habriaque poner string ? nombre = "Felipe". Deja de aparecer advertencia porque estas siendo explicito a la hora de indicar que variable nombre puede conteenr nulo
		 a pesar de ser tipo de referencia podria contener nulo.
		-Los tipos de referencia no nulom obligan a ser explicitos cuando hay tiponde referencia que peude contener nulo.
		-Eso no quiere decir que no de error pero se esta siendo explicito a la hora de decir que esa variable podria ser nula.
		-Esa advertencia es para tener cuidado y programar de forma mas robusta. Es una sugerencia o una ayuda.
		-Sino gusta tener que estar poniendo ?, sencillamente se cambia <Nullable> a disable para eliminar la configuracion de referencia no nulo.
		-Es mejro enable porque ayuda a programar de forma mas responsable.
		
	24. Using Implícitos
		-permiten evitar tener ciertas directivas using en nuestros archivos de C#.
		-La clase program no tiene ninguna directiva using.
		-Funciona lo de la declaracion del builder porque los using implicitos son directivas using que estan implicitas en las clases de C#.
		-Si se pone a disable entonces aparecen errores y hay que darle a control + punto para usar el using.
		-Es mas comodo si hay using implicitos para no colocar code sin necesidad.
		-Se devuelve a enable y se ve que es parte de una configuracion que permite usar los tipos de dicho namespace de manera impiicita sin tener que usar el using de forma explicita.
		
	25. Archivo LaunchSettings
		-Es un fichero que permite colocar configuraciones respecto al lanzamiento de la app.
		-Estas configuraciones son para el entorno dev, en prod no se usa.
		-Se tienem dos perfiels: http y https.
		-En la ejecucion se tienen esos perfiles.
		-Hay un launchbrowser para lanzar el navegador.
		-Cuando se corra app, se corre el navegador.
		-Se abre una consola y un navegador. Si se pone a false, no se lanza el navegador, sale la consola.
		-La URL es 7089 y viene de un profile. Se esta configurando en apllicationUrl cual es la URL a la que vamos a poder acceder a nuestra app.
		-Si se quiere se peude poner 7090.
		-las variables de ambiente se peuden hacer configuraciones que no necesariamente estan en el codigo fuente.
		-En desarrollo se puede poner aqui sin tener que ponerlo en el codigo fuente.
		-Ahora se tiene esto: "ASPNETCORE_ENVIRONMENT": "Development".  Con esto se simula que estas en desarrollo.
	
	26. Clase Program
		-Es sencilla, pequeña y tiene minimo para correr webapi.
		-Se comienza creando una app web que en asp.net core significa que es un cnjunto de configuracioens acerca de rutas, piplines, http...Lo que se necesita para poder teenr una app web la cual pueda 
		 recibir peticiones http y dar respuesta.
		-Se coloca eso en una app builder y se hace builder.Build() para construir app web.
		-Antes de esto se tiene el area de servicio (inicio del area de servicio).
		-Entre el builder y app, se configura el servicio. Un servicio es una clase que peude reusarse en ASP.NET Core y se configura desde aqui.
		-Con ello, se permite no repetir code y tener un area donde tenemos principales configuraciones de nuestra app.
		-La clase program se divide en varias partes.
		
		-Otra es el el area de los middlewares.
		 Va despues del builder.Build().
		
		-Un middleware es el conjunto de procesos que vamos a correr cada vez que recibamos epticion HTTP en nuestra app.
		-Se tiene el mapGet que es que si recibimos una peticion get hacia root de la app, se devuelve Hola Mundo!
		-Quiere decir que cuando se hace peticion get, hacia el root de la app, se ejecuta la funcion y devuelve ese string. Eso se conoce como minimal api porque no se sua un controlador.
		-La clase program esta configurada para unproyecto de Minimal APi donde con minimo codigo podemos tener una web API funcionando.
		-Esta clase es el punto de entrada de nuestro web api donde se construye la app web se tiene area de servicios y area de middlewares dknde se construiran funciones que peudan nterceptar
		 y procesar las peticiones HTTP que vayan al Web API.
		 
	27. Archivos AppSettings
		-Son dos ficheros el normal y el development.
		-Esos ficheros tienen como proveedores de informacion.
		-Un proveedor de configuracion es una fuente de datos que nuestra app peude usar para rapido acceso a datos de configuracion.
		-Este tipo de archivos es importante porque ayudan a evitar tener datos de configuracion  hardcodeados en el codigo de C#.
		-Es un fichero json con configuraciones. Es un archivo de texto plano en formato json.
		-El de Development es igual.
		-Aqui se peuden meter configuraciones que no se quiere que esten en el codigo de C# porque es compilado y una vez compilado no puede ser editado .
		-Yo tendria que modificar code fuente, vovler a compilar y mandar ficheros a prod para poder actualizar el code. No se quiere porque ha datos que se quiere colocar en fichero de texto
		 plano de tipo json y que aplicacion simplemente tome.
		-Se va a ver ejemplo. Un ejemplo es una cadena de conexion que es un string que contiene ubicacion de BBDD, el nombre de la bbdd, credenciales para autenticarme....
		 Tiene todo para oder usar una BBDD.
		-Tipicamente se tiene BBDD para pruebas y una de PROD que es datos reales y son BBDD separadas.
		-Por eso, son conexioens distintas.Se tendra un connectioString para desarrollo y otro para PROD.
		-Por eso se tiene dos ficheros de appsettings. El appsetting.development.json, es el fichero que contiene coinfiguraciones de la app para desarrollo.
		-El otro es para prod.
		-Se mete en el de development => "cadenaDeConexion": "Esta es una cadena para mi BD de desarrollo",
		-Se mete lo mismo para el json de prod => "cadenaDeConexion": "Esta es una cadena para mi BD de prod",
		-Si se quiere obtener el valor de la cadenaDeConexion desde Program => var cadenaDeConexion = builder.Configuration.GetValue<string>("cadenaDeConexion") (para provvedores de configuracion.
		-Se puede meter esto en el code.
		-Si se quiere probar en prod lo que saldria, se usa variable de abiente en launchSettings.json:
			"https": {
			  "commandName": "Project",
			  "dotnetRunMessages": true,
			  "launchBrowser": true,
			  "applicationUrl": "https://localhost:7288;http://localhost:5139",
			  "environmentVariables": {
				"ASPNETCORE_ENVIRONMENT": "Production"
			  }
			}
			
		-Se ha visto que desde que se pone que estamos en rpod, se usa proveedor de configuracion de produccion. Sin tener que cambiar nada con respecto a program,
		 solo cambiando variable de ambiente se ha seleccionado un proveedor de config u otro. Ademas, si se cambia el string, no se ha modificado C# y se tiene nuevo valor. Se toca solo proveedores de configuracion.
		 Se puede sin tener que compilar la app, se peudan ver cambios ahi.
		 
	28. Resumen
		-Se instala .NET, Visual Studio y otras cosas para realziar ejercicios, webapi de ejemoplo y se vio que es proyecto y solucion.
		-El fichero launchSettings permite realizar configuraciones acerca del lanzamiento de nuestra app en desarrollo.
		-Los appsettings representan proveedores de configuracion y con ellos podemos obtener datos que seran consultados por app dependiendo de app donde estemos.
		-En clase program vimos que podemos configurar middlewares y servicos.
		
Sección 3: Nuestro primer Web API
	29. Introduccion
		-Se quiere vistazo de principio a fin de elementos que intervienen a la hora de desarrollar  un webapi con asp.net core.
		-No es profunidzar en ideas sino ver etapas del ciclo de vida del desarrollo de un webapi.
		
	30. Iniciando el desarrollo del Web API
		-Se crea un webapi.
		-En VS Code se usa plantilla vacia.
		-Se llama BibliotecaAPI que tendra que ver con autores y libros.
		-Lo primero es configurar el proyecto para que sea de controladores no de minimal apis.
		-Se va a program.cs, se quita el endpoint y entre var app y builder que es el area de servicio:
		builder.Services.addControllers(); => Se agregan controladores en la app.
		-Se va al area de middlewares y se pone:
		app.MapControllers(); //cuando venga peticionj http al webapi se manda al sistema de controladores para que sea un controlador el que de respuesta a la peticion.
		Un controlador es una clase que tiene un conjunto de acciones y cada accion es ua funcion que responde a una peticion http.
		-Se crea un controlador. Se crea en el proyecto por convencion la carpeta Controllers.
		-Se crea el fichero AutoresController.cs. Se genera asi por convencion. Todo controlador acaba por la palabra Controller.
		-AutoresController tiene que hacer pensar que es un controlador que tiene que ver con autores.
		-la idea es que cualquier peticion http que tenga que ver con recurso autor, va a ser manejada por funcion o accion dentro de esta clase.
		-Se hereda de ControllerBase que es clase base que tiene funcionalidad auxiliar que permite trabajar de frma sencilla con webapi.
		-[ApiController]: Es atributo que permite indicar que este controlador se refiere a controlador de webapi. Este eprmit eautomaticamente hacer validaciones sobre data que envie el usuario,
		-[Route("")]: Se controla la ruta en la que se encuentra el controlador, es decir, a que URL tiene que ser mandada la peticion HTTP para poder llamar a una de las acciones
		 de este controlador.
		-Se va a crear una accion la cual va a responder al metodo httpget, por eso se mete como atributo. asi se tiene el controlador con su accion.
		using Microsoft.AspNetCore.Mvc;

		namespace BibliotecaAPI.Controllers
		{
			[ApiController]
			[Route("")]
			public class AutoresController: ControllerBase
			{
				[HttpGet]
				public string Get()
				{
					return "autores";
				}
			}
		}
		
		-En una app real no se mete la ruta vacia, sino "api/autores".
		
		-Imagina que ahora queires retonar un solo autor o varios y se necesita clase que represente un autor.
		-Dentro de Controller se crea la carpeta entidades. Una entidad se refiere a un recurso que tiene representacion en una bbdd. Se creara bbdd con tabla de autores.
		 Un autor representa un registro de una bbdd, se pone como una entidad.
		-Se crea carpeta Entidades dentro de Controllers. Se crea el fichero Autor.cs.
		 El required del nombre indica que para poder instanciar la clase autor, tiene que haber nombre presente. Asi garantizas que todo autor tiene un nombre.
		 Se pone required por encima de la propeidad y eso indica a asp.net core que si viene un autor, si envian autor desde un cliente, tiene que tener nombre, sino tiene nombre,
		 autor no es valido y asp.net puede rechazar la peticion.
		 
		public class Autor
		{
			public string Id { get; set; }
			[Required]
			public required string Nombre { get; set; }
		}		
			
		-[Required] esto es validacion para asp.net core y esto es de C#: public required string Nombre { get; set; }
		-Una cosa es el framework de desarrollo asp.net core y otra cosa es el lenguaje.
		 Tienen propositos diferentes.
		-Se vuelve a AutoresController y se el dice que queires reotnar un IEnumerable que es una coleccion de autores.
		-Se puede meter JSOn Viewer al navegador para ver la respuesta JSON.
	
	31. Instalando Entity Framework Core
		-Ahora se tiene una accion que devuelve data hardcodeada.
		-Se trabaja con BBDD real.
		-Se usa Entity Framework Core. E suna libreria que pone sencillo para trabajar con BBDD usando C#.
		-Se peude crear BBDD usnado C#, interactuar con ella y hacer muchas oeracioens con funcionalidades a neustro favor con codigo de C#.
		-Boton derecho en proeycto > Administrar paquetes nugget > Microsoft.EntityFrameworkCore.SqlServer.Se va a usar esto para conectar a SQL Server.
		-Este peude trabajar con difernetes mtores de bbdd como oracle, maria DB.
		-Se instala. Si fuese con dtonet cli: dotnet add package Microsoft.EntityFrameworkCore.SqlServer
		-Un paquete nugget es una libreria que se peude descaragr y permite reutilizar code. 
		-Se instala un segundo paquete: Microsoft.EntityFrameworkCore.Tools => Esto para los que usan Vsual Studio. Para otros IDEs como VS Code, Rider...se instaka el design.
		-Microsoft.EntityFrameworkCore.Tools: Este paquete lo que hace es que permite usar comandos para interactuar conEntity framework core: se peude crear ase de datos, insertar datos...
		-La de design se necesita para trabajar con bbdd relacional.
		-Tools instala or defecto Design y por eso no se instala Design.
		-Se crea el ApplicationDBContext.
		-Se crea esta carpeta y se mete esa clase.
		-Que es esto? El DB Context es la peiza central de Entity Framework Core. Es a traves de esta clase donde defino cales seran las tablas de mi BBDD.
		-Se definen otras configs como ConnectionString aunque se usa bbdd de SQL Server.
		-Es peiza central donde estan cofigs fundamentales de Entity Framework Core.
		-Se hereda de DB Context.
		-Se genera un costructor con conrtrol punto.
		-Eso permite realizar ciertas configuraciones de Entity Framework Core fuera de esta clase: el connectionstring con sql server etc que se colcoa en la clase Program.
		-Basicamente tengo que indicar que estas opciones las puedo pasar a traves del constructor de esta clase.
		-otra cosa es indicar cuales seran las tablas de BBDD. para esto prop tab DbSet<Autor> Autores...: public DbSet<Autor> Autores { get; set; }
		-Esto lo que hace es que indicas que quires que se cree una tabla en bbdd a partir de las propiedades de la clase Autor.
		-Se tiene Id y nombre y tendra estas dos cols. Id sera numero y nombre string.
		-No e snulo porque se tiene required. Se tiene autores. Es el nombre de la tabla.
		-Se crea connectionString que apunta a BBDD. Para esto se usa proveedor de configuracion como appsettings developments json.
		-Esto de connectionstring es estandar y se va a usar. Se va a SQL Management Studio para copiar y pegar el server name.
		 Integrated Security indica como nos vamos a autenticar en el servidor de BBDD. A verdadero es que se usan credenciales de  windows para autenticarme en esta instancia de SQL Server.
		 -Si se quiere user y password peus false..y se pondria User id...password....
		  TrustServerCertificate a true indica que estamos ante servidor que cnfiamos.
		  Es una maquina de desarrollo asi que se relaja. Basicamente es que no hace falat certificado valido para encriptar la conexion entre la BBDD y webapi. Esto no se hace en PROD.
		  Al publicar webapi en PROD no hay necesidad de hacer esto porque estaremos ya ante servicio en nube que tendra su certificado.
		  "ConnectionStrings": {
			  "DefaultConnection": "Server:DESKTOP-LATBQ6O\\;Database=WebAPIBibliotecaDB;Integrated Security=True;Integrated Security=True;TrustServerCertificate=True"
			},
		
		-Se va a la clase Program y se va a configurar el servicio.
		-El app debe context se coinfigura como servicio para poder reutilziar en cualquier parte de la app. Se registra el Db Context como un servicio.
		builder.Services.AddDbContext<ApplicationDbContext>(opciones => opciones.UseSqlServer("name=DefaultConnection"));
		
		-Ahi se configura el applicationdb context como un servicio y estoy configurando que usaremos sql server y le indico que el nombre del connectionString es DefaultConnection.
		-Se peude crear la BBDD y para eso se usa una migracion. Esto es un paso intermedio entre mdoificacion de tu app y la modificacion en BBDD.
		 Fuiste al DbContext y dijiste que quieres crear la tabla autores pero en code quieres ver lo que pasara en bbdd, eso es migracion. No es mas que cambios que ocurriran en bbdd pero expresados en c#.
		-Se va al package manager console que esta en Tools > Nugget PAckage Manager > package manager Console.
		-En dotnet cli el comando es: dotnet ef migrations add TablaAutores
		-Aqui en VS es Add-Migration TablaAutores. Lo segundo es el nombre de la migracion
		-En el metodo up se ve que se crea una tabla autores con sus campos y hay tabla primaria, configruada para ID.
		-Si se revierte es que hace drop table que borra tabla autores. Eso es lo que hace el emtodo down, revertir cambios.
		-Se regresa al Package manager console y se ejecuta para aplciar los cambios: Update-Database. En dotnet cli: dotnet ef database update.
		-Entity Framework lo que hace es que usa connectionString para evr si existe una db con ese nombre en ese servidor, sino existe la crea, sino la actualiza.
		-Se ve que se crea la DB, la tabla y la tabla de migraciones, se ve hsitorial de migraciones.
		
	32. Leyendo y creando recursos desde el controlador
		-Se va a crear registros. Se recibe autor a webapi por parte de cleinte y se va a usar esta data para insertar esta data en la BBDD.
		-En AutoresController, accion httppost porque esperas recibir info del cliente. Se quiere que el cliente nos mande info.
		-Se va a crear un método asincrono. La programacion asincrona sirve para trabajar de forma mas eficiente cuando se tienen operaciones I/O
		 que son oepraciones que realziamos desde nuestro sistema a sistemas externos. Se habla de webapi y bbdd.
		 la buena practica es usar programacion asincrona.
		-Se tieen que devovler Task quee s un requerimiento de la programacion asincrona.
		-En esta accion para decir que voy a recibir datos del cliente, simplemente los coloco como argumentos del metodo POST.
		[HttpPost]
		public async Task<ActionResult> Post(Autor autor) { 

		}
		
		-Se sua Entity Framework Core para insertar ese autor en la tabla de autores. Para esto se usa inyeccion de dependencias.
		-Esto se refiere a que las dependencias de esta clase pueden venir de clases externas, es decir, de la clase que invoca a AutoresController.
		-Esto se hace  a traves de servicios que hemos configrurado en neustro proeycto. En clase program se configuro applicationDbContext como un servicio.
		-Ahora se usa en AutoresController como un servicio.
		-Se crea un constructor y se le pasa por parametro ApplicationDbContext y asi obtienes una instancia del ApplicationDbContext para interactuar con base de dato.
		-Se el llama context y Control . para crear create and assign field context.
		-Se pone ctor y tab para constructor.
		-Asi se permite tener la clase ApplicationDbController como campo de la clase autores controller y asi se tiene acceso al contexto 
		 en todas las acciones de mi clase AutoresController.
		 private readonly ApplicationDbContext context;

		public AutoresController(ApplicationDbContext context)
		{
			this.context = context;
		}
		
		-Ahora se va a la peticion HTTP post.
		[HttpPost]
		public async Task<ActionResult> Post(Autor autor) {
			context.Add(autor);
		}
		
		-Esto no agrega en la tabla autores, el autor, lo que hace es que marca este objeto para que sea agregado en el futuro cuando guardemos los datos.
		-Es como que se hae una modificacion a autor como que queremos insertarlo en la tabla autores pero no lo hemos guardado. Para eso, se usa saveChanges.
		-hay que usar el operador await context.saveChangesAsync
		[HttpPost]
		public async Task<ActionResult> Post(Autor autor) {
			context.Add(autor);
			await context.SaveChangesAsync();
		}
		
		-El operador await lo que permite es lanzar esta operacion de savechanges que es mandar el query de insert para insertar la data en la tabla de autores y no quedar esperando la respuesta a esa oepracion
         sino que webapi es libre de hacer otras cosas en lo que llega esa respsuesta.
		-Esto tiene que ver con la programacion asincrona. Se usa operador await. y retun Ok;
		[HttpPost]
		public async Task<ActionResult> Post(Autor autor) {
			context.Add(autor);
			await context.SaveChangesAsync();
			return Ok();
		}
		
		-Se va a usar postman para hacer la peticion POST.
		-Se mete body, raw, json. por defecto el webapi usa el formato json para enviar datos y recibirlos.
		-WebApi espera qe el autor se lo mande en formato json y listado se mostraba en formato json en el navegador.
		-Se tiene campo nombre ye s lo que se amndará. El Id se rellena automaticamente con valor unico por SQL Server. enviar. 200 Ok.
		-Si falla es porque no esta levantada la app..
		-Si se va a la bbdd, se select 1000, y se ve que se ha insertao.
		-Se mete otro registro.
		-Nueva pestaña y se hace get. El get esta hardcodeado. Se queiren traer esos datos.
		-Se convierte el metodo.
		[HttpGet]
		//public string Get()
		public IEnumerable<Autor> Get()
		{
			return new List<Autor>
			{
				new Autor{Id = 1, Nombre = "Felipe"},
				new Autor{Id = 2, Nombre = "Claudia"}
			};

		}
		
		-A esto:
			Se mete async porque vamos a comunicarnos con bbdd y es una oepracion I/O y es buena practica usar programacion asincrona. Hay que retornar Task de algo.
			Aqui se devuelve Task de Autor. return await context.Autores.ToListAsync(). Lo ultimo es para colocar en un listado todos los autores de la tabla autores.
			Y se retorna eso hacia el cliente.
			[HttpGet]
			public async Task<IEnumerable<Autor>> Get()
			{
				return await context.Autores.ToListAsync();

			}
			
		-Se hace peticion get desde postman.
	
	33. Obteniendo un registro por Id.
		-Si enautores hubiese 100K registros, no seria viable mostrar tanta data.Por eso se eprmtie obtener un registro por su id.
		-Se va a implementar esto.
		-Para ello se hace otra peticion GET pero hay que diferenciarlo con una plantilla.
		-Se le anexa el id a la URL base. Es de tipo entero.
		 El ActionResult es el rdo de una accion. Es un tipo de dato que se peude usar como tipo de dato de salida de una accion.
		 Se peude retornar 404 o cualquier otro tipo de codigo de status HTTP o un autor.
		 se hace Get(int id) que es el que viene de la URL.
		 Se hace var autor...porque se quiere buscar el autor por id. El oeprador await porque se comnica con bbdd. 
		 FirstorDefaultAsync es el primero o el por defecto. Es el primer autor que tenga la siguiente caracteristica que su id = id
		 Sino existe devuelve autor o nulo. Si es nulo, NotFound(). Viene de Controllerbase. Es clase auxiliar que da facilidades para webapi.
		
		[HttpGet("{id:int}")] // api/autores/1
		public async Task<ActionResult<Autor>> Get(int id)
		{
			var autor =  await context.Autores.FirstOrDefaultAsync(x => x.Id == id);

			if(autor is null)
			{
				return NotFound();
			}

			return Ok(autor);

		}
		
		-Se prueba en postman: GET https://localhost:7132/api/autores/1
		
	34. Actualizando recursos
		-Se tiene a Felipe y Claudia y se queire actualizar nombre de Felipe.
		-Se representa a traves del emtodo httpput.
		-Se debe meter el id en la URl. Es para ver el autor que se quiere modificar.
		 Ese autor se pone porque se va a enviar indo en el cuerpo de la solicitud que es un autor.
		[HttpPut("{id:int}")] // api/autores/1 
		public async Task<ActionResult> Put(int id, Autor autor)
		{
			if (id != autor.Id)
			{
				return BadRequest("Los IDs deben de coincidir");
			}

			context.Update(autor);
			await context.SaveChangesAsync();
			return Ok();

		}
		
		-Se manda esto en postman:
		PUT https://localhost:7132/api/autores/1
		Cuerpo:
		{
			"id": 1,
			"Nombre": "Borja Sainz - ACTUALIZADO"
		}
		
	35. Borrando recursos
		-Metes a un autor por confusion y lo queires borrar.
		-Se usa httpdelete.
		[HttpDelete("{id:int}")] // api/autores/1 
		public async Task<ActionResult> Delete(int id)
		{
			var registrosBorrados = await context.Autores.Where(x => x.Id == id).ExecuteDeleteAsync();

			if (registrosBorrados == 0)
			{
				return NotFound();
			}

			return Ok();

		}
		
		-ExecuteDeleteAsync: retorna la cantidad regs que fueron borrados.
		-Se hace oepracion con postman.
		
	36. Creando una segunda tabla
		-Se crea la entidad libros que tiene una relacion uno a muchos con autores.
		-Eso es que aun autor le corresponden varios libros, que un autor peude escribir varios libros y un libro puede ser escrit por un unico autor.
		-Se aprende a hacer bien esta relacion para que un libro tiene autor inexsitente.
		-Se crea la clase libro:
		public class Libro
		{
			public int Id { get; set; }
			[Required]
			public required string Titulo { get; set; }
		}
		
		-Se indica que un libro tiene una relacion con tabla autores: int autoor id. Sera la llave foranea. Es una columna que representa un identificador 
		 de un registro de otra tabla. Es decir, autor.id es el id de un autor, ese AutorId siempre tiene un valor que se corresponda con un autor que exista en la tabla autores.
		 public int AutorId { get; set; }
		 
		-Se mete tambien una propeidad navegacional que es propio de entity framework y nos facilita la voda a la hora de traer la dat relacionada de una entidad.
		 Por ejemplo, tengo un libro y quiero saber el autor del libro, hay que ir a tabla autores a buscar el nombre de dicho autor y una manera facil de hacerlo 
		 es a traves de esta propiedad: public Autor? Autor { get; set; }
		
		-Es una relacion uno a muchos, a un libro le correponde un autor y a un autor varios libros.
		-Se va a la clase autor y se coloca una propeidad de navegacion que es un listado de libros. Se inicializa Listado vacio para no tener error de referencia nula si intentamos utilizar esa propeidad
		public List<Libro> Libros { get; set; } = new List<Libro>();
		
		-Se va al application db context para configurar la tabla de libros: public DbSet<Libro> Libros { get; set; }
		-Se va al package manager console para añadir nueva migracion: Add-Migration TablaLibros.
		-En constraints se ve que crea clave foranea en libros y esto obliga a que auto.id de libros se corresponda con  un id de la tabla autores y se crea indice para hacer la busqueda por autorid mas rapida.
		-Se ejecuta Update-Database.
	
	37. CRUD de Libros
		-Se crea nuevo controlador de libros. Se necesita uno nuevo porque contendra las acciones que tienen que evr con el recurso Libros.
		-Se mete estructura igual que la de autores.
		[ApiController]
		[Route("api/libros")]
		public class LibrosController : ControllerBase
		{
			private readonly ApplicationDbContext context;
			
			public LibrosController(ApplicationDbContext context) {
				this.context = context;
			}
		}
		
		-Se hace peticion httpget de libros y un libro por su id.
		-Se hace también el POST y DELETE.
		//Peticiones
		[HttpGet]
		public async Task<IEnumerable<Libro>> Get()
		{
			return await context.Libros.ToListAsync();
		}


		[HttpGet("{id:int}")] // /api/libros/1
		public async Task<ActionResult<Libro>> Get(int id)
		{
			var libro = await context.Libros.FirstOrDefaultAsync(x => x.Id == id);

			if (libro is null)
			{
				return NotFound();
			}

			return Ok(libro);
		}


		[HttpPost]
		public async Task<ActionResult> Post(Libro libro)
		{
			var existeAutor = await context.Autores.AnyAsync(x => x.Id == libro.AutorId);

			if (!existeAutor)
			{
				return BadRequest($"El autor de id {libro.AutorId} no existe");
			}

			context.Add(libro);
			await context.SaveChangesAsync();
			return Ok();
		}


		[HttpPut("{id:int}")]
		public async Task<ActionResult> Put(int id, Libro libro)
		{
			if(id != libro.Id)
			{
				return BadRequest("Los IDs deben de coincidir");
			}

			var existeAutor = await context.Autores.AnyAsync(x => x.Id == libro.AutorId);

			if (!existeAutor)
			{
				return BadRequest($"El autor de id {libro.AutorId} no existe");
			}

			context.Update(libro);
			await context.SaveChangesAsync();
			return Ok();
		}

		[HttpDelete("{id:int}")] // /api/libros/1
		public async Task<ActionResult> Delete(int id)
		{
			var registrosBorrados = await context.Libros.Where(libro => libro.Id == id).ExecuteDeleteAsync();

			if(registrosBorrados == 0)
			{
				return NotFound();
			}

			return Ok();
		}
		
		-En el post se mete si existe el autor antes de insertarlo. Anyasync se usa para obtener true or false si existe un registro que cumpla con la caracteristica de que el id = Autor.Id.
		-Para actualizar un libro tengo que asegurarme de que el autor id exista. Se mete la misma validacion que en post.
		
		-Se va a Postman y empieza con la parte de crear libros etc...
		
	38. Consultando la data relacionada
		-Se quiere consultar un libro y obtener el nombre de su autor.
		-Se monta desde postman.
		https://localhost:7132/api/libros/1
		
		-Esto aparece nulo y hay que hacer query que tome la data de la tabla de libros y la de autores.
		-Invocando una funcion se consgiue.
		-Se mete en librosController.
		-Nos metemos en la peticion get de id de libro. Se consigue poniendo el include.
		var libro = await context.Libros
			.Include(x => x.Autor)
			.FirstOrDefaultAsync(x => x.Id == id);
			
		-En postman esa peticion devovleria un error. Dice que A possible object sycle was detected. Esto es un posible ciclo de objeto fue detectado.
		-Se retorna libro y se quiere el autor ya que se recoge en la clase Libro.  Si se va a Autor hacer referencia a libro, el cual a su vez hace referencia autor, el cual
         a su vez hace referencia a libro..... hay relacion ciclica que no termina y da error el sistema y se llena el stack. 
		-Para solucionar esto:
			1) Se deben usar DTOs que son data transfer object.
			2) Solucion simple: Ignorar el ciclo detectado y no des error, da respuesta.
			   Se va a clase program y en los controller se añade el serializador de json que es el que daba error.
				builder.Services.AddControllers().AddJsonOptions(opciones => 
				opciones.JsonSerializerOptions.ReferenceHandler = ReferenceHandler.IgnoreCycles);
		-Se obtiene esto en postamn:
		{
			"id": 1,
			"titulo": "Libro 1",
			"autorId": 3,
			"autor": {
				"id": 3,
				"nombre": "Borja Sainz",
				"libros": [
					null
				]
			}
		}
		
		-Ahora se quiere que cuando obtengas autor, obtener sus libros. Esto va por autores.
		-Se va a AutoresController, solicitud httpget por id.
		-Se mete el include:
		var autor =  await context.Autores
			.Include(x => x.Libros)
			.FirstOrDefaultAsync(x => x.Id == id);
		
		-Se peuden traer libros porque se configuro esa propiedad de navegacion y eso es lo que eprmite con una sola linea de codigo traer la data relacionada.
	
	39. Resumen
		-Se hizo un webapi para tener vision general de algunos de los elementos envueltos en este 
		-Se configuro entity framework core para crear la bbdd a partir de codigo de C#.
		-Se hizo crud para permitir la manipulacion de recursos. 
		-Se vio que es bien directo consultar data relacionada usando entity framework core.
	
	
	
Sección 4: Fundamentos de ASP.NET Core y Web API
	40. Introducción al Módulo 4
		-Se dio vistazo de construccion de webapi en video anterior, ahora se va a profundizar en conceptos. se ven fundametnos de asp.net core y webapi.
	
	41. Controladores y acciones
		-La idea de tener webapi es que tendremos clienets que haran peticiones http a webapi.
		-Esas epticiones se hace a un conjunto de urls de nuestro dominios. A estas urls les llamamos rutas de nuestro webapi.
		-En estas rutas se recibe un recurso: miapi.com/autores: miapi.com seria el dominio y /autores es algun recurso relacionado con autores.
		-Normalmente, Se llama ruta a los segmentos de URL posterior al dominio, sin necesidad de mencionar todo el dominio.
		-Es decir, decimos que esta ruta es /autores.
		-Cuando se hace peticion http a ruta de nuestro webapi, tipicamente se quiere que se ejecute funcion de un controlador que se le llama accion aunque
		 tambien puede llamrse endpoint. Entonces, una accion es una funcion de un controlador que se ejecuta en respuesta a peticion http realizada a nuestra webapi.
		 Mientras que un controlador es una clase que agrupa un cjto de acciones tipicamente un controlador agrupa acciones que se relacionan con un 
		 recurso. Asi en el caso de ruta /autores, es posible que se tenga unico controlador que maneja acciones relacionadas con el recurso autores.
		 Por convencion, los contrlladores senombran concatenando una palabra como nombre de un recurso cpon palabra Controller. Asi un controlador de autores se peude llamar AutoresController.
		 Estos contrladores por convencion se colocan en una carpeta llamada Controllers.
		-Como ya se vio, se pueden usar metodos http sobre un recurso para manipularlo.
		-En asp.net eso significa que podemos configurar que accion queremos que se ejecute segun la ruta y el emtodo http usado por usuario.
	
	42. Explorando nuestro controlador
		-se tiene AutoresController. Algo tipico de cualquier controlador que no es obligatorio pero si recomendado es heredar de ControllerBase.
		-ControllerBase es una clase base que tiene un conjunto de elementos auxiliares que nos hace la vida más fácil a la hora de hacer webapis.
		-Se decora controlador con atributo ROute que se define la ruta de nuestro controlador,e s decir, la ruta a la que hay que hacerle peticiones HTTP para interactuar con acciones del controlador.
		-A veces, se pone [Route("api/[controller]")]. Esto es un placeholder que se va a sustituir por autores.
		-Es una forma de poner una variable que va a ser sustituida por el nombre del prefijo del nombre del controladores, autores.
		-Si cambia el nombre del controlador, cambia la ruta y peude haber clientes que dependen de esa ruta.
		-Felipe prefiere ser explicito y poner autores mejor que eso.
		-El atributo ApiController nos ayuda a configurar el controlador como un controlador de webapi. Es importante porque cuando se hable de validaciones, este apicontroller
		 permite que una accion a la que se le intente ingresar data incorrecta, devuelve de una vez el error, es decir, devuelve un error al cliente, un error 400 indicando reglas de validacion 
		 que no ha cumplido.
		-Se tiene n acciones: [HttpGet]. Puede haber acciones que respondan al mismo método pero se diferencian en que se pasan parametros. A lo del id se le llama plantilla.
		-Se tienen otras peticiones como [HttpPut].
		-Se puede hacer otra accion que reotrne por ejemplo el primer autor de BBDD.
		-Saltara este error: AmbiguousMatchException: The request matched multiple endpoints. Matches:
		-La peticion puede ser respondida or multiples endpoints. Los dos metodos pueden responder a la misma peticion. las dos responde al mismo metodo y misma ruta.
		 Hay que usar plantilla para hacer una combinacion y que haya diferencia en ruta entre una accion y otra: api/autores/primero
	
	43. Reglas de ruteo
		-Permiten mapear una URL con una accion. Es decir, cuando hacemos peticion http a una ruta, se quiere ejecutar una accion.
		 Para hacer configuraciones de ruteo se hace desde los controladores (ruteo por atributo) o se hace desde la clase program que se hace en MVC.
		-Aqui se va a usar el ruteo por atributo que es lo que se hace en webapi.
		-Con el route se define la ruta a traves de la cual se puede interactuar con un controlador.
		-Se ve "api/autores/. Esa configuracion hecha a nivel de controlador, la heredan todas las acciones del controlador.
		-Para interactuar con una accion se hace un GET hacia una ruta, igual POST etc...
		-Se puede hacer tb una oepracion de combinacion como ya se vio. Asi permite personalizar la ruta de una accion y diferenciar una accion de otra para evitar error de antes.
		-Se puede ignorar la ruta de api/autores.
		-Si se quiere dar una ruta personalizada a la accion de HttpGet y que ignore la ruta de route del controlador, se pone: [HttpGet("listado-de-autores"). Se ignora la peticion GET a esa ruta y saldra
		 un 405. method not allowed.
		-Se puede poner /listado-de-autores y funciona
		-Se pueden definir varias rutas para una misma accion:
		[HttpGet("/lista-de-autores")]
		[HttpGet]
		
		-Se pueden definir valores en una plantilla para buscar por ejemplo un autor por un id: [HttpGet("{id:int}")]
		-Se pueden definir varios parámetros de ruta.
		
		-Se puede hacer esto para apsar una URL y que en el apremtro1 y 2 metas lo que quieras.
		[HttpGet("{parametro1}/{parametro2}")]// api/autores/felipe/gavilan
		public ActionResult Get(string parametro1, string parametro2)
		{
			return Ok(new { parametro1, parametro2 });
		}
		
		-Si se quiere que uno de los parametros sea opcional:
		[HttpGet("{parametro1}/{parametro2}")]// api/autores/felipe/gavilan
		public ActionResult Get(string parametro1, string parametro2)
		{
			return Ok(new { parametro1, parametro2 });
		}
		
	44. Restricciones de ruta
		-Los parametros de ruta permiten definir variabels a nivel de URl que permite mayor libertad a la hora de configurar las rutas de las acciones.
		-Se ha visto que se puede colocar tipos de dato a los parametros de ruta.
		-Con el tipo de dato se restricciona mas la URL.
		-Se mete ruta por nombre.String no es tipo de dato, habría que meter alpha. Esto se llama restriccion de la variable de ruta.
		[HttpGet("{nombre:alpha})"]
		public async Task<IEnumerable<Autor>> Get(string nombre)
		{
			return await context.Autores.Where(x => x.Nombre.Contains(nombre)).ToListAsync();
		}
		
		-Se meten breakpoints. Uno en este public y otro en la petición GET ([HttpGet("{id:int}")]).
		-Se va al navegador y se ejecuta el code.
		
	45. Tipos de dato de retorno
		-Desde una accion se peude retornar un tipo especifico, ActionResult<T>, ActionResult o IActionResult.
		-ActionResult es una clase que representa todos los tipos de dato que se pueden retornar desde una accion.
		-Hay clases derivadas de ActionResult las cuales se peuden usar que se quiere retornar un tipo de dato especifico. Si se tiene una accion que siempre 
		 va a retornar un CreatedAtRowResult pues ese puede ser el tipo de dato retorno de la accion.
		-Esto es un tipo de dato retorno que representa que un recurso ha sido creeado como cuandos e crea libro o autor.
		-En lugar de usar ActionResult, se peude usar ActionResult<T>
		
		Tipo Especifico
		-Se usa cuando se retorna un tipo de dato cualquier, ya sea un string, objeto complejo o lo que sea.
		-public async Task<IEnumerable<Autor>> Get()
		 {....}
		-Se usa para acciones simples se puede usar pero el problema es que las acciones pierden versatilidad.
		
		ActionResult<T>
		-Si se tiene un método o accion que recibe un id y se quiere retornar autor al que le corresponde el ID o 404 si el autor no existe.
		-De una accion como esta no se puede decir que se quiere retornar un tipo especifico. Se tiene que usar otra opcion como ActionResult<T>
		-Permite retornar tipo especifico o ActionResult: Task<ActionResult<Autor>>.
		-Retornar 404 es retorar un StatusCodeResult que ehreda de ActionResult con codigo de Status = 404.
		-Se recibe id, buscamos autor, si es nulo se devuelve Not found, sino se devuelve el autor. Para esta versatilidad el tipo de dato de respuesta es ActionResult<T>.
		-En este caso T es Autor. Por tanto se retorna ActionResult<T>.
		-Como se esta ante metodo asincrono porque se esta con operacion I/O es buena practica usar programacion asincrona, se retorna Task<ActionResult<Autor>>
		
		IActionResult
		-Es parecido a ActionResult<T>, solo que IActionResult solo permite retornar IActionResult.
		-Si quieres retornar un tipo especifico de una accion que retorne un ActionResult, debes usar funcion Ok.
		-Se podria resultar lo que sea pero hay que devovlerlo en un Ok para poder retornarlo. Es mejor usar ActionResult<T>.
		
	46. Programación Asíncrona
		-Imagina que pides pizza por tfno para que te la entreguen en casa, te dicen que tarda 30 mins.
		-Que haces en esos 30 mins? Esperas hasta que llegue o haces otras cosas? Pues haces otras cosa mientras llega pizza.
		-Algo similar pasa cuando se usa funcion asincrona.
		-Se permite que mientras esa funcion se ejecute, nuestro servidor web en vez de quedarse esperando a que termine, mejor que se ponga a hacer otras tareas mientras la funcion se eejcuta.
		-No siempre todas las tareas se quieren hacer asincronas ya que en programacion hacer accion asincrona tiene coste de rendimiento.
		-Se recomienda en general utilizar programacion asincrona cuando se vayan a hacer oepraciones I/O.
		-Estas operaciones donde I/O es input-output son operaciones en las que nuestro software se comunica con otros sistemas. por ejemplo, si invocamos un webservice estamos haciendo operacion I/O
		 o si nos comunicamos con la BBDD.
		-La razon es simple.Dado que son sistemas externos, estos no consumen nuestrosrecuross. En vez de frisar la app, mejor liberar nuestra app para que pueda hacer otras tareas mientras el sistema externo trabaja.
		-Ya cuando el sistema externo termine, pues nos avisara y entonces se atiende al llamado.
		-Para hacer metodo asincrono, hay que usar async. Esto nos habilita para usar el oeprador await que sirve para hacer una espera asincrona.
		-No cnfundir espera. No es que se frisa. La espera es para decirle a la app que puede hacer otras cosas mientras el sistema responde.
		-Cuando sistema externo responda, se continua con ejecucion del metodo. El if(autor is null) se ejecuta cuando se finaliza la llamada a BBDD.
		-Cuando se usa async es como si se pusiese en pausa la ejecucion del metodo GET.
		-Cuando se usa programacion asincrona no podemos retornar un tipo de dato cualquiera.
		-Se debe usar una de cuatro acciones: Task, Task<t>, ValueTask, ValueTask<T>.
		-La palabra task es tarea y la diea es que emtodo asincrono representa tarea que sera ejecutada y en el futuro terminara.
		 Cuando? No se sabe porque eso ya depende en cuanto tarden los sistemas externos en respondernos.
		-Se usa Task y valueTask para configurar el tipo de dato de retorno de un emtodo asincrono.
		-Hasta ahora se ha visto Task<T> donde T es cualquier tipo de dato.
		-Por ejemplo, Task<IEnumerable<Autor>>. T es lo de dentro de Task.
		-Se tiene liberatd lo que se peude devolver de un metodo asincrono: numero, string, clase....siemrpe que se diga Task de eso.
		-Task se usa cuando tenemos un metodo asincrono que no tiene valor de retorno. Es decir, cuando no se use return.
		-Es la version asincrona deu metodo void.
		-Se puede crear autor y no devolver nada.
		
		ValueTask Y ValueTask<T>
		-Son tipos de valor y se suelen usar cuando tenemos escenarios en los cuales a veces peuden ser sincronos y a veces asincronos.
		
	47. Introducción al Model Binding
		-permite mapear datos de una petición http a parametros de una accion. Esto cubre todo tipo de params: numeros, booleanos, strings, arreglos, listas, clases de proyecto....
		-Ya se ha visto forma de mandar info a los params de una accion.
		-Se hizo usando parametros de ruta: [HttpGet("{id:int}")]
		-La idea es que a traves de la URL vamos a recibir un valor y se va a colocar en el parametro de la accion que se tiene.
		-Esos valores pueden venir de diferentes fuentes, las cuales, se pueden indicar como atributos.
		-En el caso de id, ASP.NET es inteligente para ver que se tiene el id en httpget y se va a corresponde a lo que tengo de id en public async Task<ActionResult<Autor>> Get(int id)...
		-No se tiene que indicar que va a venir de una vble de ruta o de parametro de ruta.
		-Si quiero indicar que la fuente de datos es la ruta: Get([FromRo]int id)
		-Otra forma es incluir QueryStrings. Se tiene un include para incluir los libros (.Include(x => x.Libros)). Si se quiere incluir un parámetro que indique si quiero incluir o no los libros, se haria asi:
		bool incluirLibros (Cliente puede decir verdadero o falso para ver si incluir o no lo libros).
		-Ese incluirLibros se quiere que venga de un QueryString que es un conjunto de valores que se puede incluir en la URL
		 de la siguiente forma: api/autores/id?llave=valor1&llave2=valor2....Se tiene dos queryStrings llave1 y llave2
		[HttpGet("{id:int}")] // api/autores/id?incluirLibros=true|false
		public async Task<ActionResult<Autor>> Get(int id, bool incluirLibros)
		{
			var autor = await context.Autores
				.Include(x => x.Libros)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (autor is null)
			{
				return NotFound();
			}

			return Ok(autor);
		}
		
		-Para indicar que se quiere obtener ese valor de incluirLibros se hace asi: [FromQuery] bool incluirLibros.
		-Otra forma de hacer Model Binding esa traves del cuerpo de la peticion http.
		-Para crear un autor en la peticion de POST se usaba el body desde postman.
		-Se le emtia body > raw > JSON y se colocaba el nombre del usuario. Se está usando el cuerpo de la peticion para rellenar 
		-Cuando se esta en un post se usa el cuerpo de la peticion para rellenar la data del autor.
		-En un get se usa o la URL  a traves de parametro de ruta o a traves de queryStrings.
		-Asi en la petición POST se puede indicar esto: [FromBody] Autor autor
		-Otra fuente de datos que se puede usar es la cabecera de la petición.
		-Las cabeceras son metadatos que podemos enviar o recibir en el contexto de una peticion HTTP.
		-Imagina que el parametro de incluirLibros lo quieres obtener de una cabecera, pues se pone: [FromHeader] bool incluirLibros
		
		-Poniendo la URL en el navegador no devuelve nada.
		-Se va a hacer la eptición GET desde postman: https:localhost:puerto/api/autores/1
		-se va a Headers y se añade una llave y valor: incluirLibros:true.
		-Otra fuente que se verá es el FromForm para recibir ficheros de webapi: foto de una autor.
		
	48. Validaciones por defecto
		-Se va a hablar de validaciones de modelos.
		-Se tienen reglas de negocio las cuales se quiere que datos que mandan los cleintes sigan.
		-Se tiene clase autor, unautor tiene un nombre y no se quiere que se cree autor sin nombre por eso se puso el atbto required.
		-El atributo ApiController si en una accion como post se manda una peticion post y ese autor no tiene nombre, se va a retornar un 400 Bad Request indicando el error.
		-Se puede ir a postman: api/autores y se va a mandar dato de nombre vacio.
		-Devuelve esto con 400 Bad Request y el problemDetails que es un objeto que representa la respuesta de una peticion problmeatica :
		"status": 400
		"errors": {
			"Nombre": [
				"The Nombre field is required."
			]
		},
		
		-El arreglo dentro de errores > nombre representa los distintos errores que tiene dicho campo.
		-En el required del campo nombre de la clase Autor se puede poner esto: [Required(ErrorMessage = "El campo nombre es requerido")]
		-Para no hardcodear el nombre del campo, se pone un placeholder: [Required(ErrorMessage = "El campo {0} es requerido")]
		 
	49. Otras validaciones por defecto
		-Se va a colocar otro atributo para hacer otra validacion: StringLength para que el campo nombre no pase de X caracteres.
		-Se puede añadir Errormessage para personalizar el error: [StringLength(10, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")], donde 1 indica la longitud que debe cumplir el string.
		-Se va a añadir otras reglas de validación.
		-Para ello, se arreglan otras propeidades.
		public int Edad { get; set; }
		public string? TarjetaCredito { get; set; }
		public string? URL { get; set; }
		
		-Persona se pondra que estara en un rango: [Range(8,120)]
		-[CreditCard]: Esto valida el formato de una tarjeta de credito.
		-[Url]: Que tenga la estructura de URL el string que nos pasan
		
		-Se manda una peticion post a: https://localhost:7132/api/autores
		-Se manda en el body:
		{
			"Nombre": "",
			"edad": 128,
			"tarjetaCredito": "123",
			"url": "abc"
		}
		
		-Eso nos sacará error de nombre.
		-Relamente, no se pude crear una persona ya que estamos agregando unos campos que noe stan en bbdd...:habria que crear una migracion agregar esas cols para poder crear autor. Era ejemplo. se deja comentado.
		public class Autor
		{
			public int Id { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			public required string Nombre { get; set; }
			public List<Libro> Libros { get; set; } = new List<Libro>();

			//[Range(8,120)]
			//public int Edad { get; set; }

			//[CreditCard]
			//public string? TarjetaCredito { get; set; }

			//[Url]
			//public string? URL { get; set; }
		}
		
		
	50. Validaciones Personsalizadas por atributo
		-No estamos limitados a solamente usar validaciones predefinidas por el framework. Se pueden usar tambien validaciones persoanlizadas.
		-En el caso de autor que primera letra sea mayus. No hay un atributo que se pueda usar pero se puede hacer uno.
		-La idea de hacer un atributo es poder esa logica en otros lados, por ejemplo, en libros.
		-Se crea.
		-Click derecho en proyecto y se crea nueva carpeta que se llame Validaciones. Se agrega clase: PrimeraLetraMayusculaAttribute.cs.
		-En C# cuando clase va a ser usada como atributo, su nombre termine en Attribute.
		-La clase base es ValidationAttribute para usarla como atroibuto de validacion.
		-Se pone lo siguiente. El values es cualquier valor que intentemos asignarle al campo nombre de la clase Autor.
		 Se valida y se pone que si el valor es nulo o vacio como un espacio en blanco, se queire retornar exito porque la validacion verifica que la primera letra sea mayus
		 Se encarga de verificar si el valor es nulo o no.
		 Se tiene ya required en la clase y para poder mantenerme en lo mio, 
		 Es decir, digo si es nulo, lo retorno exitoso y que diga ya required si esta bien o no.
		 Ahora si se tiene un valor asignado que no es nulo,se obtiene la primera letra del value, se hace toString porque es un objeto.
		 Se pone value.toString()! porque se sabe que no va a ser nulo porque se ha hecho la validacion.
		 Luego se valida que la primera letra sea mayus.
		 Asi se retorna el error de validacion de un atributo.
		 public class PrimeraLetraMayusculaAttribute : ValidationAttribute
		{
			protected override ValidationResult? IsValid(object? value, ValidationContext validationContext)
			{
				if(value is null || string.IsNullOrEmpty(value.ToString()))
				{
					return ValidationResult.Success;
				}

				var valueString = value.ToString()!;
				var primeraLetra = valueString[0].ToString();

				if (primeraLetra != primeraLetra.ToUpper())
				{
					return new ValidationResult("La primera letra debe ser mayúsucula");
				}

				return ValidationResult.Success;

			}
		}
		
		
		-Asi se va a la clase Autor y se pone ese atributo.
		[Required(ErrorMessage = "El campo nombre es requerido")]
		[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
		[PrimeraLetraMayuscula]
		public required string Nombre { get; set; }....
		
		-Se hace una prueba desde Postman...
		-Se pueden probar las dos validaciones.
		
	51. Validaciones Personalziadas por Modelo
		-En la clase se pueden hacer validaciones personalziadas que peude ser útil si se involucra  varias propiedades
		-Por ejemplo una validacion que fuese que quieres primera letra mayus si el campo edad esta entre 30 y 40.
		-Eso puede no tener sentido pero es poderoso realziar una validacion usando la validacion por modelo.
		-Se va a reusar la validacion que habiamos hecho pero para modelo.
		-Se va a comentar  // [PrimeraLetraMayuscula]
		-Se hereda de interfaz IValidatableObject y se implementa el método Validate.
		-Se puede retornar un IEnumerable que permite retornar varios ValidationResult.
		-Sino se retorna ningun error de validaciopn es porque no ha habido errores y eso es que modelo es valido.
		-Se hace yield return que en C# permite ir construyendo linea por linea el IEnumerable que es una coleccion de ValidationResult.
		-COn el el new string se pasan los campos a los que se hace referencia que ha habido el error.
		-nameOf(Nombre), permite obtener una representacion en string de ese Nombre. Es equivalente a {"Nombre"}.
		-Es mejor poner nameof porque si te vas al string y haces control R, Control R lo puedes reemplazar facil si el dia de mañana cambia el nombre.
		public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
		{
			if (!string.IsNullOrEmpty(Nombre))
			{
				var primeraLetra = Nombre[0].ToString();

				if (primeraLetra != primeraLetra.ToUpper())
				{
					yield return new ValidationResult("La primera letra debe ser mayúscula - por modelo", new string[] { nameof(Nombre) });
				}
			}
		}
		
		-Se va a postman y se prueba.
		-Las validaciones por modelo solamente se ejecutan posterior a la ejecución de las validaciones por atributo.
		-Solamente si son exitosas.
		-Si hay error de validacion por atributo, la validacion por modelo no se ejecuta.
		-La ventaja de la validacion por modelo es que se tiene acceso al modelo completo.
		-Se puede hacer combinacion de valicaciones de varios campos de validacion if (primeraLetra != primeraLetra.ToUpper() && Edad > 40).
		-No es tan viable en caso de un atributo ya qe la idea de atributo es usar la propiedad a la que le fue asignada el atributo.
		-La ventaja de validacion por atributo es que puedo reutilziarla.
		-Se puede reusar en libro tambien por ejemeplo.
		
	52. Validando desde el Controlador - Validando contra la BD
		-Se vaa  validar en una peticion post a la hora de crear un libro, si el autor que nos mandan existe.
		-Se habia recogido una validacion pero que no gusta.
		-Un error de validacion tipico es problemDetails que es detalle de problema. Se quiere que la validacion que se retorne tenga mismo formato porque ahora se tiene simple string.
		-Para poder hacer esto, primero se va a modificar el ModelState.
		-Este permite tener uno objeto en el cual podemos colocar los errores del cliente enesta peticion http.
		-ModelState.AddModelError()
		[HttpPost]
		public async Task<ActionResult> Post(Libro libro)
		{
			var existeAutor = await context.Autores.AnyAsync(x => x.Id == libro.AutorId);

			if (!existeAutor)
			{
				ModelState.AddModelError(nameof(libro.AutorId), $"El autor de id {libro.AutorId} no existe");
				return ValidationProblem();
				// return BadRequest($"El autor de id {libro.AutorId} no existe");
			}

			context.Add(libro);
			await context.SaveChangesAsync();
			return Ok();
		}
		
		-Se prueba postman: https://localhost:7132/api/libros
		Body:
		{
			"titulo": "Libro Borrar",
			"autorId": 1123
		}
		
	53. Inyección de Dependencias y Acoplamiento
		-Las clases de nuestra app raramente son completamente autosuficientes y es normal separar responsabilidades entre diferenets clases.
		-Lo mismo sucede con controladores. Un controlador contiene conjunto de acciones por lo que responsabilidad del controlador es recibir peticiones HTTP hechas a nuestra webapi.
		 y coordinar el procesamiento de dicha solicitud.
		-Sin embargo, un controlador no debe tener la responsabilidad de mantener registros en una bbdd, ni de escribir mensajes en consola, ni calcular la inversa de una matriz...
		-Esas tareas han de ser delegadas a otras clases.
		-Cuando una clase A usa una clase B, decimos B es dependencia de la clase A. las dependencias son inevitables y han sido estudiadas en software. Se usa untermino para evaluarlas: acoplamiento.
		-Acopamiento puede ser fuerte o debil. El fuerte se caracteriza por una dependencia no flexible de otras clases.
		-No es bueno el acoplamiento fuerte.
		-En AutoresController se ve dependencia de ApplicationDbContext porque se esta usando.
		-Como clase AutoresController usa la clase ApplicationDbContext, esta dependen de AutoresController. 
		-Esta relacion no es muy flexible porque estas obligado a usar ApplicationDbContext para poder instanciar AutoresController.
		-No se puede usar otra clase.
		-Aqui hay acoplamiento fuerte. Esto es bueno o malo? Ya se vera en EF que es un caso especial.
		-Se vera ejemplo y se va a ver ejemplo de acoplamiento entre clases antes de abordar algo mas complejo como es EF Core.
		-Se va a crear un controlador temporal.
		-Se llamará ValoresController.
		-Es un controlador de pruebas.
		-Se quiere simular caso de pruebas.Se va a retornar un listado de valores.
		
		-Se crea la clase Valor dentro de Entidades. Se pone required para no tener esa advertencia de que el atributo que no acepta nulos, debe tener un valor distinto de nulo...
		public class Valor
		{
			public int Id { get; set; }
			public required string Nombre { get; set; }
		}
		
		-Controlador:
		[ApiController]
		[Route("api/valores")]
		public class ValoresController : ControllerBase
		{
			[HttpGet]
			public IEnumerable<Valor> Get()
			{
				return new List<Valor>
				{
					new Valor{Id = 1, Nombre = "Valor 1" },
					new Valor{Id = 2, Nombre = "Valor 2" }
				};
			}
			
		}
		
		-Controlador es sencillo pero tiene muchas responsabilidades como la de crear un listado de valores para luego devolverlño.
		-En AutoresController se iba a BBDD y se devolvia. Aqui algo parecido. Se debe crear clase que se encargue de obtener ese listado.
		-Se va al proyecto y se crea RepositorioValores. En software cuando se habal de una clase repostorio se encarga de abstraer la logica
		 para concetarnos a BBDD y obtener informacion.
		-Es clase que oculta detalle de implementacion que involucra comunicar con BBDD, ahcer una query, obtener data etc.
		-Asi que no se tenga todo ese codigo para conectarse a BBDD de Oracle SQl Server en controlador, sino que se mete en una clase que se pueda reutilziar y a eso se llama repositorio.
		public class RepositorioValores
		{
			public IEnumerable<Valor> ObtenerValores()
			{
				return new List<Valor>
				{
					new Valor{Id = 1, Nombre = "Valor 1" },
					new Valor{Id = 2, Nombre = "Valor 2" }
				};
			}
		}
		
		-Lo anterior del controlador, se sustituye por esto. Se delega la reponsabilidad de obtener valores en el repositorioValores y no esta harcodeada en el controlador.
		 [ApiController]
		 [Route("api/valores")]
		 public class ValoresController : ControllerBase
		 {
			 [HttpGet]
			 public IEnumerable<Valor> Get()
			 {
				 var repositorioValores = new RepositorioValores();

				 //return new List<Valor>
				 //{
				 //    new Valor{Id = 1, Nombre = "Valor 1" },
				 //    new Valor{Id = 2, Nombre = "Valor 2" }
				 //};

				 return repositorioValores.ObtenerValores();
			 }
		 }
		 
		-Aun asi hay acoplamiento fuerte porque cuando se usa valoresController estas obligado a usar RepositorioValores.
		-Si ahora te tienes que conectara  unwebapi dia de mañana:
		// var repositorioValores = new RepositorioValores();
		var repositorioValores = new RepositorioValoresWebAPI();?? No esta bien. Esa inflexibilidad, implica que para responder a un cambio de negocio,
		tenga que venir a ValoresController a modificar codigo....
		-El acoplamiento débil se da con el mecanismo de inyeccion de dependencias. Es facil cuando se pueden intercambiar depdendencias de forma sencilla.
		-La inyeccion de dependencias es un mecanismo mediante el cual las dependencias de un objeto son suministradas por otro objeto.
		-Se transforma lo anterior a esto:
		public class ValoresController : ControllerBase
		{
			private readonly RepositorioValores repositorioValores;

			public ValoresController(RepositorioValores repositorioValores)
			{
				this.repositorioValores = repositorioValores;
			}

			//Dependencia débil
			[HttpGet]
			public IEnumerable<Valor> Get()
			{   
				return repositorioValores.ObtenerValores();
			}
		}
		
		-La responsabilidad de instanciar ValoresController se le ha dado a quien esta llamando a ValoreController.
		-Se va a Program y se hace var ValoresController = new ValoresController(). Se tiene responsabilidad de pasarle RepositorioValores
		 y se puede configurar como se quiera. Ahora se peude controlar la instancia de esa dependecnai que tiene ValroesController.
		 que es RepositoriValores. Ahora para oder instanciar ValroesController, tengo que pasarle RepositorioValores pero
		 hay que configrar esa clase como un servicio. En ASP.NET Core cuando se habla de servicio se refiere a que cuando 
		 se solicita tipo, en este caso RepositorioValores, a traves de ctor, se sirva instancia de RepositorioValores.
		 Es decir, servicios se encragand e cosntruir las dependencias de nuestras clases. 
		 Para configurar servicios se va a Program y se hace esto: builder.Services.AddTransient<RepositorioValores>();
		
		-Con eso, se le dice a ASP.NET Core que el dia que haya una clase como ValoreController que tenga deendencia de RepositorioValores,
		 pues que puede inyectar instancia de dicha clase para poder usarla.
		 
	54. Utilizando el Principio de Inversión de Dependencias
		-Ya se esta usando la imnyeccion de dependencias en ValoresController porque se esta obteniendo su dependencias RepositorioValoresç
		 a traves del constructor. Esto se hace para tener mas flexibilidad. Pero parece que no se tiene gran ganancia. Parece
		 que es lo unico que se puede usar en ValoresController.
		-Por ahora, no se esta aplicando el principio de inversion de dependencias.
		-Este principio establece que nuestras clases deben depender de abstracciones y no de tipos concretos.
		-RepositorioValores es un tipo conceto.
		-Un ejemplo de abtsraccion es una clase abstracta o interfaz. Si se quiere tener la flexibilidad de querer cambiar
		 la dependencia de ValoresController, hay que depender de la abstraccion para que asi en tiempo de ejecucion se pueda hacer el intercambio.
		-En vez de depender de RepositorioValores se va a crear una interfaz de la que se va a depender.
		-En BibliotecaAPI se crea una clase IRepositorioValores.
		-Una interfaz lo que hace es establecer contrato en la que cualquer clase que imlemente dicha interfaz, tiene que implementar
		 dicho contrato. A traves de la interfaz, se colocan las signaturas que cualquier clase que implemnete la interfaz tiene que implementar.
		-La signatura es el tipo de dato de salida, nombre del metodo y parametos.
		-En la interfaz no esta la implmenetacion. Solo se indica que cualquier clase que vaya a interfaz esa iinterfaz, tiene que implementar un metodo con esa signatura.
		public interface IRepositorioValores
		{
			public IEnumerable<Valor> ObtenerValores();
		}
		
		-Para implementar interfaz, se va a la clase, : NombreInterfaz.
		-Ahora en lugar de depender de RepositorioValores, se depende de IRepositorioValores.
		private readonly RepositorioValores repositorioValores;
		Se cambia por: private readonly IRepositorioValores repositorioValores;.
		
		-Se depende de la interfaz o se establece el principio de inversion de dependencias porque asi vas a deepnder de una abstraccion
		-El tema de la interfaz es que no se sabe qué clase van a apsar por public ValoresController(IRepositorioValores repositorioValores)
		-Puede ser que sea RepositorioValores y mañana puede ser RepositorioValoresSQL, RepositorioValoresOracle.
		-Eso te da igual lo unico que interesa es que la clase que te vayan a pasar por ahi, implemente ObtenerValores.
		-Interfaz dice que cualquier clase que implmenete la interfaz IRepositorioValores, tiene que tener un metodo que tenga ObtenerValores.
		-Ahora en ValoresController es que la dependencia es una abstraccion.
		-Hay que ir a la clase program para decir que en el AddTrasient, donde dices que configruas RepositrioValores como un servicio, ahora se indica que el  servicio es 
		 IRespositorioValores, RepostorioVAlores. Es decir, se le dice a ASP.NET Core que cuando se vea que alguien necesita el servicio IrepositorioValores,
		 le sirva la instancia RepositorioValores.
		 Se cambia: builder.Services.AddTransient<RepositorioValores>();
		 Por: builder.Services.AddTransient<IRepositorioValores, RepositorioValores>();
		
		-En ValoreController, aunqque dice IRepositorioValores, en tiempo de ejecución se le va a srvir el RepositorioValores.
		-Ahora ya hay una relación de acoplamiento muy bajo, es muy flexible.
		-Ahora hay nuevo requerimiento y es que se necesita un repositoriode valores que busque los valores de una bbdd de Oracle.
		-Se crea clase RepositorioValoresOracle que implemente IRepositorioValores que obliga que la clase implmente un metodo con esa signaturaç
		-Hasta que no se hace, eso ni compila.
		-Control + Punto sobre la interfaz para implementarla.
		-Se retorna new List<Valor>. Se supone que viene de Oracle.
		public class RepositorioValoresOracle : IRepositorioValores
		{
			public IEnumerable<Valor> ObtenerValores()
			{
				return new List<Valor> {
					new Valor{Id=3, Nombre="Valor Oracle 1"},
					new Valor{Id=4, Nombre="Valor Oracle 2"},
					new Valor{Id=5, Nombre="Valor Oracle 3"},
				};
			}
		}
		
		-Se quiere que en ValoresController se utilice ese RepositorioValoresOracle.
		-No se tiene que ir a ValoreController a hacer ningun cambio.
		-Como se esta aplicando el principio de inversion de dependencias y se depende de una abstraccion y tipo concreto, se puede desde la clase Program, cambiar la implementacion
		que se esta usando y poner builder.Services.AddTransient<IRepositorioValores, RepositorioValoresOracle>();. Asi consigues que en ValoresController se use 
		la implementacion de oracle. Eso parece sencillo en proyecto pequeño como tenemos.
		En proyecto grande con decenas o cientos de clases que dependan de IRepositorioValores y con hacer cambio en simple linea de cambio se propague 
		por aplicacion y se haya hecho el cambio de 50 o 100 clases.
		-Lanzar y probar: https://localhost:7132/api/valores
	
	55. Servicios en ASP.NET Core
		-Se va a hablar de los tiempos de vida de los servicio. Hay 3: Trasnient, Scope y Singleton.
		-Transient: es el de menor tiempo de vida. Cuando un servicioe s marcado como Transient, cada vez que se solicita instancia de dicho servicio, esta instancia 
		 será totalmente nueva. Se sua cuando no hay estado compartido, es decir, cuando clase no tiene campos que se quieran compartir entre instancias
		-Scoped: Es cuando se crea instancia unica por peticion HTTP. No importa cuantas veces se solciite el servicio, siempre que sea dentro del mismo 
		 contexto http , sera entregada la misma instancia de la clase. Util cuando se queira preservar estado dentro de la solicitud HTTP.
		-Singleton: Ua unica instancia dels ervicio durante la vida de la app. No imporota cuantas veces se solitie el servicio, siempre se entrega la misma instancia aunque sea a usuarios distintos.
		 Es util cuando se quiere tener un estado global como por ejemplo una capa de chae.
	
	56. Ejemplo de Tiempo de Vida de los Servicios
		-Se va a crear un ejemplo que permita visualziar la diferencia entre cada uno de los tiempos de vida de un servicio.
		-Se crea nueva clase en la raiz de BibliotecasAPI: EjemploTiemposDeVida.
		-Se crearan 3 servicios: Transient, Scoped y Singleton.
		-Se vra como se comportan estos tres servicios.
		-Un Guid es un string aleatorio. Al momento de inicializar la clase se tendrá ese string aleatorio.
		-se pone propiedad publica para obtener el guid.
		-Cuando se instancie la clase ServicioTransient se crea string aleatorio que coloca en el campo_id pricado y para obtener esa info se usa ObtenerGuid que
		 es una propiedad publica que retorna el valor de _id.
		-Idem con Scoped y Singleton.
		public class EjemploTiemposDeVida
		{
			public class ServicioTransient
			{
				private readonly Guid _id;

				public ServicioTransient()
				{
					_id = Guid.NewGuid();
				}

				public Guid ObtenerGuid => _id;
			}

			public class ServicioScoped
			{
				private readonly Guid _id;

				public ServicioScoped()
				{
					_id = Guid.NewGuid();
				}

				public Guid ObtenerGuid => _id;
			}

			public class ServicioSingleton
			{
				private readonly Guid _id;

				public ServicioSingleton()
				{
					_id = Guid.NewGuid();
				}

				public Guid ObtenerGuid => _id;
			}

		}
		
		-Se van a crear esas tres clases como un servicio desde el area de servicios en la clase program.
		builder.Services.AddTransient<ServicioTransient>();
		builder.Services.AddScoped<ServicioScoped>();
		builder.Services.AddSingleton<ServicioSingleton>();
		
		-Ahora con servicios configurados ahi, se quiere decir que se peuden usar usando inyeccion de depednencias.
		-Se va a ValoresController. Se añade para metro mas en el constructor para obtener instancia de ServicioTransient.
		-En misma clase ValoresController se va a inyectar dos veces el mismo servicio.
		-Idem con Scoped y Singleton....
		-Control punto desde un parametro "por ejemplo, singleton" y Crear y asignar el resto de campos.
		public class ValoresController : ControllerBase
		{
			private readonly IRepositorioValores repositorioValores;
			private readonly ServicioTransient transient1;
			private readonly ServicioTransient transient2;
			private readonly ServicioScoped scoped1;
			private readonly ServicioScoped scoped2;
			private readonly ServicioSingleton singleton;

			public ValoresController(IRepositorioValores repositorioValores,
				ServicioTransient transient1,
				ServicioTransient transient2,
				ServicioScoped scoped1,
				ServicioScoped scoped2,
				ServicioSingleton singleton)
			{
				this.repositorioValores = repositorioValores;
				this.transient1 = transient1;
				this.transient2 = transient2;
				this.scoped1 = scoped1;
				this.scoped2 = scoped2;
				this.singleton = singleton;
			}......
			
		-Se crea nueva acción que será GET.
		-Se va a retorna IActionResult porque se va a retornar tipo anonimo.
		-Se esta construyendo objeto anonimo dopnde se tiene propeidad transients donde se colocan los Ids de lsos ervicios que son transient.
		-Mismo con Scoped y Singleton.
		-Se devuelve el guid de cada uno de los servicios.
		-Dado que transient significa que se va a crear una instancia de la clase cada vez que se solicita el servicio, se vera que los valores transient1 y trasient2 seran diferentes
		 porque se estan inyectando dos servicios transient y por tanto se esta instanciando dos veces la misma clase, mientras con scoped, se instancia una sola vez la clase
		 siempre que sea el mismo contexto HTTP. scoped1 y 2 no cambiaran. En Singleton se instancia una sola vez por el tiempo de vida de la app.
		 Ese valor no cambia a menos que se reinicie la app.
		[HttpGet("servicios-tiempos-de-vida")]
		public IActionResult GetServiciosTiemposDeVida()
		{
			return Ok(new
			{
				Transients = new
				{
					transient1 = transient1.ObtenerGuid,
					transient2 = transient2.ObtenerGuid,
				},
				Scopeds = new
				{
					scoped1 = scoped1.ObtenerGuid,
					scoped2 = scoped2.ObtenerGuid
				},
				Singleton = singleton.ObtenerGuid

			});

		}
		
		-Se ejecuta app en este endpoint. Se ve que trabnsient1 y 2 son difernetes. Scoped1 y 2 cambian pero son iguales entre si son iguales dentro de mismo contexto Http.
		-En singleton no cambia cada vez que se refresca.
		-En transient se tiene una instancia de la clase nueva sin importar que estemos en el mismo contexto http.
		-En scoped es misma instancia dentor de mismo conexto http. Si se tiene otro contexto, es decir, otra peticion, es optra instancia.
		-En singleton mismo valor, porque es siempre misma instancia hasta que se cierre la app y se vuelva a correr.
		
	57. Usando un Singleton para nuestro repositorio en memoria
		-Se tenía RepositorioValores que es de prueba pero se puede mejorar.
		-Se ve que se tiene un solo método para ObtenerValores.
		-Seria bueno usarlo tambien para insertar supuestos registros.
		-Si se hace se hara pequeña implementacion en memoria.
		-Se mete en el constructor listado de valores.
		-Lo que se hace es colocar como estado de la clase el listado de valores
		-Se crea el método publico que es InsertarValor.
		-Se cambia antes:
		public IEnumerable<Valor> ObtenerValores()
		{
			return new List<Valor> {
				new Valor{Id=3, Nombre="Valor Oracle 1"},
				new Valor{Id=4, Nombre="Valor Oracle 2"},
				new Valor{Id=5, Nombre="Valor Oracle 3"},
			};
		}
		
		-Por:
		private List<Valor> _valores;

		public RepositorioValoresOracle()
		{
			_valores = new List<Valor> 
			{
				new Valor{Id=3, Nombre="Valor Oracle 1"},
				new Valor{Id=4, Nombre="Valor Oracle 2"},
				new Valor{Id=5, Nombre="Valor Oracle 3"},
			};
		}

		public IEnumerable<Valor> ObtenerValores()
		{
			return _valores;
		}
		
		public void InsertarValor(Valor valor)
		{
			_valores.Add(valor);
		}
		
		-Se tiene que meter InsertarValores dentro de la interfaz IRepositorioValores. Para ello, desde InsertarValor, control punto, pull e insertar valor en IRespositorioValores...
		-RepositorioValores tiene que implementar ese contrato de InsertValor.
		-No se va a implementar ahora la logica que se puso en RepositorioValoresOracle.
		-En ValoresController se mete una nueva acción HttpPost.
		[HttpPost]
		public IActionResult Post(Valor valor)
		{
			repositorioValores.InsertarValor(valor);
			return Ok();
		}
		
		-Cuando se inserta un valor se quiere obtener el valor a traves del método ObtenerValores.
		-Se va a postman para hacer una peticion HTTP Post: 
			https://localhost:7132/api/valores
			{
				"id": "10",
				"nombre": "Valor Oracle 10"
			}
			
		-Ahora se lanza la petición GET desde el navegador y se ve que no se tiene la info.
		-En Program se ve que se ha configura els ervicio de IRepositorioValores como Transient.
		-Pero esto significa que cada vez que solicitemos una instancia del servicio IRepositorioValores se va a tener una nueva instancia de la clase RepositorioValoresOracle.
		-Esto sigmifica que cada vez que se solicite dicha nueva instancia, el campo de valores del constructir de RepositorioValoresOracle se inicialzia con lo que tiene en la clase...
		-Por eso, se tiene eso mismo. Por tanto, como se quiere compartir estado entre diferentes peticiones HTTP, pues se quiere que ese servicio sea Singleton
		 para que asi cualquier modificacion que un usuario haga pues ese listado de valores lo vea otro que es basicamente simular una BBDD porque si usuario
		 modificase la BBDD, pues otro usuario puede ver esa modificacion (insertar, updatear, borrar...).
		-Se cambia el servicio por AddSingleton para compartir estado en distintas peticiones HTTP.
		-Se da insertar y a get y ya se ve el nuevo valor...
		-Ahora ya se peude ser mas efectivo a la hora de decidir que tiempo de vida escoger.
			-Si se quiere comaprtir estado entre diferentes peticiones HTTP, pues usamos Singleton.
			-Si se quiere mantener ele stado dentro del mismo contexto HTTP, usar Scoped.
			-Sino interesa mantener el estado, pues Transient.
		
	58. ¿Y qué hacemos con Entity Framework Core?
		-Se habla de principio de inversión de dependencias y EF.
		-Este principio de inversión de dependencias dice que nuestras clases deben depender de tipos abstractos y no de concretos, es decir, depender de clases abstractas o interfaces. Esto
		 nos aydua a tener un nivel alto de flexibilidad y es recomendable para tener software que peuda evolucioanr.
		-ApliicationDBContext es un tipo concreto y recordamos que en AutoresController, se inyecta dicha clase a través del constructor.
		-Eso es que no se tiene por qué estar haciendo las cosas mal. Todo depende de las necesidades de negocio.
		-ApplicationDbContext aunque es una clase, en cierto sentido ya es de por sí una abstracción con respecto a detalles de implementación de la lógica de acceso a datos.
		-Para obtener un listado de autores se ha usado código como return await context.Autores.ToListAsync();
		-Eso nada habla acerca de SQLServer, Postgres....Se podria cambiar el motor de base de datos mañana y mi codigo de buscar listado de autores no cambairia
		-Aunque EF soporta varios motores de BBDD, no soporta todos.
		-Se sostiene el ehcho de que el DbContext ofrece flexibilidad. por tanto, no siempre es estrategico colocar 
		 detras de una interfaz. Se peuden hacer pruebas unitarias y de integración con EF Core muy facil, por lo que no es razon de peso para colcoarlo detras de una interfaz.
		-Existe una razon por la cual si deseariamos colocar nuestro ApplicationDbContext detras de una abstraccion y es cuando necesitamos soportar un motor de base de datos
		 el cual EF no soporta. Si se quiere suar SQL Server pero se quiere tambien usar Excel, pues tiene sentido usar una capa de abstraccion extra para poder soportar ambos
		 escenarios de forma simultanea.
		-ApplicationDbContext es especie de abstraccion que da flexibilidad, lo que es una escepcion a la regla y se peude depender de dicha clase sin problemas.
		-En el caso de que debamos soportar otras tecnologias no soportadas por Ef, si es aconsejable usar una interfazz 
		 para implementar el niveld e flexibilidad del sistema.
		-Rara vez lsos istemas cambian de motor de BBDD, por lo que implementar el nviel de complejidad de app por un por si acaso cambiamos de motor, no arroja beneficios.
	
	59. Loggers
		-El logging permite saber que esta ocurriendo con nuestra app cuando es eejcutada. Se peuden escribir mensajes en algun lugar para revisarlos.
		-Se peuden escribir mensajes en un archivo de texto, pero se van a escribir por consola ahora.
		-La idea del logging es que se tiene funciona  la que se llama, se pasa emnsaje de texto y se coloca en consola para evr funcion que se ejecuta, ver
		 valores que van saliendo etc.
		-El debugging no se puede usar en PROD, ni se puede epdir a un cliente de nosotros que esteusando WebAPi para que active mmodo debugging.
		-Lo que se peude hacer con un cliente es pedirle que use app y luego visualziar los logs. Esos mensajes qe han sido escritos por nuestra app, describiendo lo que está ocurriendo
		 dentro de nuestra app en tiempo de ejecucion.
		-Se peude usar ILogger. pemrite centralziar mensajes de logs. S epeude inyectar con sistema de inversion de dependencias, por ejemplo en AutoresController.
		-Es un servicio predeterminado, ya configurado por ASP.NET Core.
		-Se puede decir el nombre de la clase en la que se va a ejecutar el log.
		-basicamente, en este caso AutoresController.
		-Se pone asi.
		private readonly ILogger<AutoresController> logger;

		public AutoresController(ApplicationDbContext context, ILogger<AutoresController> logger)
		{
			this.context = context;
			this.logger = logger;
		}
		
		-Se va a la peticion hettpGET de listado-de-autores para usarlo.
		[HttpGet("/listado-de-autores")] // /listado-de-autores
		[HttpGet] // /api/autores/
		public async Task<IEnumerable<Autor>> Get()
		{
			logger.LogInformation("Obteniendo el listado de autores");
			return await context.Autores.ToListAsync();

		}
		-Se lanza una prueba en el navegador. Se ve mensaje en la consola.
		-Hay 6 niveles de mensajes: Trace, Debug, Information, Warning, Error, Critical.
		-Estos niveles permiten segmentar os mensajes segun el nivel de importancia.
		-Trace es el menor novel de importancia y critical el mayor nivel de importancia.
		-Se puede configurar a partir de que nivel se quieren procesar los mensajes de LOG. Si se elige INformation irá de ese para arriba: debug y trace no porquee stan por debajo del nivel minimo
		 del que quiero procesar los mensajes.
		 Asi funciona los nieveles en los mensajes de log.
		 Se pone idem LogTrace,  debugging.....
			[HttpGet("/listado-de-autores")] // /listado-de-autores
			[HttpGet] // /api/autores/
			public async Task<IEnumerable<Autor>> Get()
			{
				logger.LogTrace("Obteniendo el listado de autores");
				logger.LogDebug("Obteniendo el listado de autores");
				logger.LogInformation("Obteniendo el listado de autores");
				logger.LogWarning("Obteniendo el listado de autores");
				logger.LogError("Obteniendo el listado de autores");
				logger.LogCritical("Obteniendo el listado de autores");
				return await context.Autores.ToListAsync();

			}
		-Por defecto, en el expplorado de soluciones del proyecto, se ve en appsettings.development.json que se eejcuta en desarrollo, se ve el nivel de logging
		 y se ve que por defecto es Information, es decir se procesan los mensajes desde Information hacia arriba.
		-Para que no se llene la consola de mensajes de trace y debug que tiene asp.net core se puede usar una categoria que 
		 son los strings que se ponen entrecomillado como Defaukt.
		 Son los lugares en los cuales se va a aplicar el nivel de procesamiento de los logs.
		-Se tiene por ejemplo "Microsoft.AspNetCore", esto quiere decir que cualquier clase que se encuentre en este namespace,
		 le aplica ese nivel de procesamiento de log. Para yo aplicar el nivel de procesamiento Trace en AutoresControler,
		 se coloca el namespace como namespace. Si se quiere ser mas especifico se puede poner .AutoresController.
		 Asi, esto solo aplica a los mensajes de log que salgan de esta categoria.
		  "Logging": {
		   "LogLevel": {
			 "BibliotecaAPI.Controllers.AutoresController": "Trace",
			 "Default": "Information",
			 "Microsoft.AspNetCore": "Warning"
		   }
		 }
		 
		-Ahora ya si se imprimene sos mensajes en consola. Se peude hacer eso de forma temproal para miraer error y luego Information.
		-Se puede usar para investigar cosass y luego vovler a cambiarlo.
	
	60. Introducción al Middleware.
		-Hasta ahora se ha dicho que cuando WebAPI recibe una solicitud HTTP, es una accion de un controlador la que recibe la solicitud y la procesa.
		-Esta no es sdescripcion precisa de lo que realmente sucede cuando se recibe la solicitud. Una solicitud llega a WebAPI y pasa por lo que se conoce 
		 por pipeline de solicitudes HTTP.
		-Un pipe es una acdena de procesos conectados de tal manera que la salida de cada elemento de la acdena es la entarda del siguiente.
		-El pipeline es el conjunto de procesos conectados que reciben una solicitud y la procesan para dar algun tipo de Rdo.
		-Uno de esos procesos es el proceso Controlador que es donde se manejan los controladores y las acciones.
		-Ciertamente no es unico proceso del pipline. Se llama middleware a cada proceso del pipline.
		-Un middleware importante es el proceso de autorizacion que es el que permite la funcionalidad denegar el acecso de un recurso dependiendo de si
		 el usuario tiene permiso para acceder a este.
		-Es normal que se configuren permisos en el proceso de controladores donde indicamos que una accion, solo puede ser consumida por ciertos usuarios.
		-Para que esta logica de autorizacion funcione es importante haber apsado por el proceos de autorizacion priemro.
		-Esto implica que el orden de los proceoss en el pipeline es importante.
		-Los middlewares se ejecutan de la siguiente manera. Primero llega epticion, va al priemr middlware, luego al segundo, luego al tercero y se van ejecutando los
		 middlewares de atras adelante en la fase de respuesta, primero tercero, luego segundo, luego primero y luego se da respuesta al cliente.
		-Puede ser que un middleware que haga un cortocircuito. Puede que el segundo middleware recibe la peticion y verifica que no tiene que el tercer middleware la vea
		 y por tanto, hace cortocircuito y da una respuesta.
		-Si un middlware por ejemplo comprueba que un usuario no tiene permisos para continuar pues no le deja continuar.ç
		-Y no le pasa la peticion a los siguientes middlewares.
	
	61. Ejemplos de Middleware.
		-Se ve que en la clase Program esta el area de los middlewares.
		-Va desde el var app hasta app.Run.
		-Por ahora, solo 1 middleware que permite que cuando llega peticion a ruta especifica, pues un controlador peuda manejar sidcha peticion.
		-Se va a decir que se quiere crear middleware que se encarag de logegar cada peticion y cada respuesta que recibamos.
		-Es decir cuando llegue una peticion se quiere guardar en el log, el metodo y la ruta y de la respuesta se quiere usar el estado de la respuesta.
		-Se recibe el contexto y next que permite invocar el siguiente middleware. Desde dentro se quiere recibir una instancia del servicio Ilogger.
		-Se usa el cotexto htpp. Se quiere permitir tambien la invocacion del siguiente middleware y para eso se usa next.
		-Por un lado, se tiene que se quiere guardar en el log, informacion acerca de la peticion http, luego acerca de la respuesta.
		-Invoke permite invocar el resto de la tuberia de pipeline.
		-Es decir, el resto de los middlewares.
		-Primero, la epticion viene entra al middleware hace lo de la request y luego invoke y se suspende la ejecucion, se ejecuta MapControllers, va a un controlador como el de autores,
         se procesa y se devuelve informacion. Luego van middlwares hacia atras y luego ya se ejecuta lo de la respuesta.
			// área de middlewares
			app.Use(async (contexto, next) =>
			{
				// Viene la petición
				var logger = contexto.RequestServices.GetRequiredService<ILogger<Program>>();
				logger.LogInformation($"Petición: {contexto.Request.Method} {contexto.Request.Path}");

				await next.Invoke();

				//Se va la respuesta

				logger.LogInformation($"Respuesta: {contexto.Response.StatusCode}");
			});

			app.MapControllers();

			app.Run();		 
			
		-En la consola se ve la salida.
		
		-Se quiere enseñar un ejemplo en el que el orden de los Middlewares es super kmportante. Si se quiere tener una ruta que no tenga que evr con controladores,
		 que nadie pueda entrar por alguna razon. Hay una logica que se encarga de guardar el log, cualqueir peticion. La idea es guardar el log y luegi hagamos 
		 cualquier otra cosa para que asi si la eprsona incluso intenta entrar a ese sitio prohibido, pues que quede loggeado.
		 app.Use(async (contexto, next) =>
			{
				if (contexto.Request.Path == "/bloqueado")
				{
					contexto.Response.StatusCode = 403;
					await contexto.Response.WriteAsync("Acceso Denegado");
				} else
				{
					await next.Invoke();
				}
				
			});
			
		-Si se pone el de bloqueado arriba, que pasa? Se tiene acceso denegado pero no se escribe ni response ni request.
		-Esto es orque orden de middlewares es importate y este hace cortocircuito a peticion y or tanto 
		 el de abajo no se ejecuta. Si se tiene necesidad de engocio de guardar en un log las peticiones  y respuestas, pues estas provocadas por el middleware no se 
         logearian.

	62. Colocando los Middlewares en su propia clase
		-Se van a colcoar middlewares personalziados en sus propias clases, asis e mantiene program mas limpio.
		-Se crea clase, normalmente se mete en una carpeta, pero da igual por ahora.
		-Se le llama LogeuapeticionMiddleware. Se mete constructor. Se pone RequestDelegate que es el invoke.
		-Para ser middleware hay que meter metodo InvokeAsync.
		public class LogueaPeticionMiddleware
		{
			private readonly RequestDelegate next;

			public LogueaPeticionMiddleware(RequestDelegate next)
			{
				this.next = next;
			}

			public async Task InvokeAsync(HttpContext contextp)
			{

			}
		}
		
		-Se coge el cacho de code de la request del Middleware.
		public async Task InvokeAsync(HttpContext contexto)
		{
			// Viene la petición
			var logger = contexto.RequestServices.GetRequiredService<ILogger<Program>>();
			logger.LogInformation($"Petición: {contexto.Request.Method} {contexto.Request.Path}");

			await next.Invoke(contexto);

			//Se va la respuesta

			logger.LogInformation($"Respuesta: {contexto.Response.StatusCode}");
		}
		
		-Esto sirve para poder indicar que queires seguir la ejecucion del pipeline del middleware. Lo de más arriba del metodo se eejcuta en lo que la peticion viene 
		 y lo otro cuando se va la respuesta. Para sim plificar como usar el middleware, el standar es que se cree una clase estatica que exponga un metodo de extension 
		 de la siguiente forma.
		
		-Es clase auxiliar de la anterior. Va a ser estatica porque es un metodo de extension....
		public static class LogueaPeticionMiddlewareExtensions
		{
			public static IApplicationBuilder UseLogueaPeticion(this ApplicationBuilder builder)
			{
				return builder.UseMiddleware<LogueaPeticionMiddleware>();
			}
		}
		
		-La clase de arriba tiene logica de middleware y la otra tiene metodo auxiliar que permite usar el middleware de forma sencilla.
		-Donde estaba el code de antes en Program.cs, se mete asi.
		
		-El metodo de extension eprmite extender un tipo.
		-El IApplicationBuilder le pertenece a Microsoft. No hemos hecho  nosotros.
		-El emtodo de extension permite hacer como si la estuviese modifciando para agregarle ese metodo y de forma comoda
		-Cuando se hace app.UseLogueaPeticion es un webapplication y se esta agregando el metodo IApplicationBuilder que lo implementa esa parte de Microsoft y
		 al se run metodo ya lo agrega.
		-Se va a probar.
		-Se crea nueva clase para llevar el otro metodo a otra clase.
		-COn BloqueaPeticion idem logica que antes.
		
	63. Resumen
		-Se vio fundamentos de ASP.NET Core aplicados a WebAPI.
		-Los controladores sn clases que agrupan cjto de metodos que responden a peticiones http enbase a un recurso a estos metodos se llaman acciones.
		-Acciones on metodos que se ejecutan en abse a respuesta a peticion http.
		-Programacion asincrona nos aydua a ser eficientes cuando realizamos operaciones I/O.
		-Se pueden hacer validaciones de nuestros modelos para evitar tener data no valida.
		-La inyeccion de depedencias buena practica en ingenieria de software para centralizar logica de instanciacion de nuestras clases.
		-Servicio es una clase que se peude servir usando sistema de inyeccion de dependencias o contenedor de inversion de controles.
		-Los middlewares son funciones que se pueden ejecutar para procesar solciitudes http que recibe nuestra app.
		
Seccion 5: Manipulando recursos
	64. Introducción al Módulo
		-Es hora de hablar de manipulaciond e recursos que se refiere a las operaciones basicas de manipulacion como crear, actualizar, borrar y leer recursos.
	
	65. Limpiando el proyecto
		-El quiere borrar el ValoresController:
		using BibliotecaAPI.Entidades;
		using Microsoft.AspNetCore.Mvc;

		namespace BibliotecaAPI.Controllers
		{
			[ApiController]
			[Route("api/valores")]
			public class ValoresController : ControllerBase
			{
				private readonly IRepositorioValores repositorioValores;
				private readonly ServicioTransient transient1;
				private readonly ServicioTransient transient2;
				private readonly ServicioScoped scoped1;
				private readonly ServicioScoped scoped2;
				private readonly ServicioSingleton singleton;

				public ValoresController(IRepositorioValores repositorioValores,
					ServicioTransient transient1,
					ServicioTransient transient2,
					ServicioScoped scoped1,
					ServicioScoped scoped2,
					ServicioSingleton singleton)
				{
					this.repositorioValores = repositorioValores;
					this.transient1 = transient1;
					this.transient2 = transient2;
					this.scoped1 = scoped1;
					this.scoped2 = scoped2;
					this.singleton = singleton;
				}

				[HttpGet("servicios-tiempos-de-vida")]
				public IActionResult GetServiciosTiemposDeVida()
				{
					return Ok(new
					{
						Transients = new
						{
							transient1 = transient1.ObtenerGuid,
							transient2 = transient2.ObtenerGuid,
						},
						Scopeds = new
						{
							scoped1 = scoped1.ObtenerGuid,
							scoped2 = scoped2.ObtenerGuid
						},
						Singleton = singleton.ObtenerGuid

					});

				}


				//Dependencia débil
				[HttpGet]
				public IEnumerable<Valor> Get()
				{   
					return repositorioValores.ObtenerValores();
				}
				//Dependencia Fuerte
				//[HttpGet]
				//public IEnumerable<Valor> Get()
				//{
				//    var repositorioValores = new RepositorioValores();

				//    //return new List<Valor>
				//    //{
				//    //    new Valor{Id = 1, Nombre = "Valor 1" },
				//    //    new Valor{Id = 2, Nombre = "Valor 2" }
				//    //};

				//    return repositorioValores.ObtenerValores();
				//}


				[HttpPost]
				public IActionResult Post(Valor valor)
				{
					repositorioValores.InsertarValor(valor);
					return Ok();
				}

			}
		}

		-La clase Valor:
		namespace BibliotecaAPI.Entidades
		{
			public class Valor
			{
				public int Id { get; set; }
				public required string Nombre { get; set; }
			}
		}
		
		-BloqueaPeticionMiddleware:
		using BibliotecaAPI;

		public class BloqueaPeticionMiddleware
		{
			private readonly RequestDelegate next;

			public BloqueaPeticionMiddleware(RequestDelegate next)
			{
				this.next = next;
			}

			public async Task InvokeAsync(HttpContext contexto)
			{
				if (contexto.Request.Path == "/bloqueado")
				{
					contexto.Response.StatusCode = 403;
					await contexto.Response.WriteAsync("Acceso Denegado");
				}
				else
				{
					await next.Invoke(contexto);
				}
			}
		}

		public static class BloqueaPeticionMiddlewareExtensions
		{
			public static IApplicationBuilder UseBloqueaPeticion(this IApplicationBuilder builder)
			{
				return builder.UseMiddleware<BloqueaPeticionMiddleware>();
			}
		}

		-EjemploTiemposDevida:
		namespace BibliotecaAPI
		{
			public class ServicioTransient
			{
				private readonly Guid _id;

				public ServicioTransient()
				{
					_id = Guid.NewGuid();
				}

				public Guid ObtenerGuid => _id;
			}

			public class ServicioScoped
			{
				private readonly Guid _id;

				public ServicioScoped()
				{
					_id = Guid.NewGuid();
				}

				public Guid ObtenerGuid => _id;
			}

			public class ServicioSingleton
			{
				private readonly Guid _id;

				public ServicioSingleton()
				{
					_id = Guid.NewGuid();
				}

				public Guid ObtenerGuid => _id;
			}
		}

		-IRepositorioValores:
		using BibliotecaAPI.Entidades;
		namespace BibliotecaAPI
		{
			public interface IRepositorioValores
			{
				void InsertarValor(Valor valor);
				public IEnumerable<Valor> ObtenerValores();
			}
		}

		-LogueaPeticionMiddleware:
		namespace BibliotecaAPI;
		public class LogueaPeticionMiddleware
		{
			private readonly RequestDelegate next;

			public LogueaPeticionMiddleware(RequestDelegate next)
			{
				this.next = next;
			}

			public async Task InvokeAsync(HttpContext contexto)
			{
				// Viene la petición
				var logger = contexto.RequestServices.GetRequiredService<ILogger<Program>>();
				logger.LogInformation($"Petición: {contexto.Request.Method} {contexto.Request.Path}");

				await next.Invoke(contexto);

				//Se va la respuesta

				logger.LogInformation($"Respuesta: {contexto.Response.StatusCode}");
			}
		}

		public static class LogueaPeticionMiddlewareExtensions
		{
			public static IApplicationBuilder UseLogueaPeticion(this IApplicationBuilder builder)
			{
				return builder.UseMiddleware<LogueaPeticionMiddleware>();
			}
		}

		-RepositorioValores:
		using BibliotecaAPI.Entidades;

		namespace BibliotecaAPI
		{
			public class RepositorioValores : IRepositorioValores
			{
				public void InsertarValor(Valor valor)
				{
					throw new NotImplementedException();
				}

				public IEnumerable<Valor> ObtenerValores()
				{
					return new List<Valor>
					{
						new Valor{Id = 1, Nombre = "Valor 1" },
						new Valor{Id = 2, Nombre = "Valor 2" }
					};
				}
			}
		}

		-RepositorioValoresOracle:
		using BibliotecaAPI.Entidades;

		namespace BibliotecaAPI
		{
			public class RepositorioValoresOracle : IRepositorioValores
			{
				private List<Valor> _valores;

				public RepositorioValoresOracle()
				{
					_valores = new List<Valor> 
					{
						new Valor{Id=3, Nombre="Valor Oracle 1"},
						new Valor{Id=4, Nombre="Valor Oracle 2"},
						new Valor{Id=5, Nombre="Valor Oracle 3"},
					};
				}

				public IEnumerable<Valor> ObtenerValores()
				{
					return _valores;
				}

				public void InsertarValor(Valor valor)
				{
					_valores.Add(valor);
				}
			}
		}

		-AutoresController:
		using BibliotecaAPI.Datos;
		using BibliotecaAPI.Entidades;
		using Microsoft.AspNetCore.Mvc;
		using Microsoft.EntityFrameworkCore;

		namespace BibliotecaAPI.Controllers
		{
			[ApiController]
			[Route("api/autores")]
			public class AutoresController : ControllerBase
			{
				private readonly ApplicationDbContext context;
				private readonly ILogger<AutoresController> logger;

				public AutoresController(ApplicationDbContext context, ILogger<AutoresController> logger)
				{
					this.context = context;
					this.logger = logger;
				}

				//[HttpGet]
				////public string Get()
				//public IEnumerable<Autor> Get()
				//{
				//    return new List<Autor>
				//    {
				//        new Autor{Id = 1, Nombre = "Felipe"},
				//        new Autor{Id = 2, Nombre = "Claudia"}
				//    };

				//}

				[HttpGet("/listado-de-autores")] // /listado-de-autores
				[HttpGet] // /api/autores/
				public async Task<IEnumerable<Autor>> Get()
				{
					logger.LogTrace("Obteniendo el listado de autores");
					logger.LogDebug("Obteniendo el listado de autores");
					logger.LogInformation("Obteniendo el listado de autores");
					logger.LogWarning("Obteniendo el listado de autores");
					logger.LogError("Obteniendo el listado de autores");
					logger.LogCritical("Obteniendo el listado de autores");
					return await context.Autores.ToListAsync();

				}

				[HttpGet("primero")]// api/autores/primero
				public async Task<Autor> GetPrimerAutor()
				{
					return await context.Autores.FirstAsync();

				}

				[HttpGet("{id:int}")] // api/autores/id?incluirLibros=true|false
				public async Task<ActionResult<Autor>> Get(int id, [FromHeader] bool incluirLibros)
				{
					var autor = await context.Autores
						.Include(x => x.Libros)
						.FirstOrDefaultAsync(x => x.Id == id);

					if (autor is null)
					{
						return NotFound();
					}

					return Ok(autor);

				}

				[HttpGet("{nombre:alpha}")]
				public async Task<IEnumerable<Autor>> Get(string nombre)
				{
					return await context.Autores.Where(x => x.Nombre.Contains(nombre)).ToListAsync();
				}

				//[HttpGet("{parametro1}/{parametro2?}")]// api/autores/felipe/gavilan
				//public ActionResult Get(string parametro1, string parametro2 = "valor por defecto")
				//{
				//    return Ok(new { parametro1, parametro2 });
				//}


				[HttpPost]
				public async Task<ActionResult> Post([FromBody] Autor autor) {
					context.Add(autor);
					await context.SaveChangesAsync();
					return Ok();
				}

				[HttpPut("{id:int}")] // api/autores/1 
				public async Task<ActionResult> Put(int id, Autor autor)
				{
					if (id != autor.Id)
					{
						return BadRequest("Los IDs deben de coincidir");
					}

					context.Update(autor);
					await context.SaveChangesAsync();
					return Ok();

				}


				[HttpDelete("{id:int}")] // api/autores/1 
				public async Task<ActionResult> Delete(int id)
				{
					var registrosBorrados = await context.Autores.Where(x => x.Id == id).ExecuteDeleteAsync();

					if (registrosBorrados == 0)
					{
						return NotFound();
					}

					return Ok();

				}
			}
		}
		
		-De AutoreController, se quita el ILogger.
		-Se quita el httpget el de primero....
		-En resumen, dejo la nueva version de AutoresController y se puede comparar con lo que habia antes.
		using BibliotecaAPI.Datos;
		using BibliotecaAPI.Entidades;
		using Microsoft.AspNetCore.Mvc;
		using Microsoft.EntityFrameworkCore;

		namespace BibliotecaAPI.Controllers
		{
			[ApiController]
			[Route("api/autores")]
			public class AutoresController : ControllerBase
			{
				private readonly ApplicationDbContext context;

				public AutoresController(ApplicationDbContext context)
				{
					this.context = context;
				}

				[HttpGet] // /api/autores/
				public async Task<IEnumerable<Autor>> Get()
				{
					return await context.Autores.ToListAsync();

				}

				[HttpGet("{id:int}")] // api/autores/id
				public async Task<ActionResult<Autor>> Get(int id)
				{
					var autor = await context.Autores
						.Include(x => x.Libros)
						.FirstOrDefaultAsync(x => x.Id == id);

					if (autor is null)
					{
						return NotFound();
					}

					return Ok(autor);

				}

				[HttpPost]
				public async Task<ActionResult> Post([FromBody] Autor autor) {
					context.Add(autor);
					await context.SaveChangesAsync();
					return Ok();
				}

				[HttpPut("{id:int}")] // api/autores/1 
				public async Task<ActionResult> Put(int id, Autor autor)
				{
					if (id != autor.Id)
					{
						return BadRequest("Los IDs deben de coincidir");
					}

					context.Update(autor);
					await context.SaveChangesAsync();
					return Ok();

				}


				[HttpDelete("{id:int}")] // api/autores/1 
				public async Task<ActionResult> Delete(int id)
				{
					var registrosBorrados = await context.Autores.Where(x => x.Id == id).ExecuteDeleteAsync();

					if (registrosBorrados == 0)
					{
						return NotFound();
					}

					return Ok();

				}
			}
		}
		
		-En Autores se cambia esto:
		using BibliotecaAPI.NewFolder;
		using System.ComponentModel.DataAnnotations;

		namespace BibliotecaAPI.Entidades
		{
			public class Autor : IValidatableObject
			{
				public int Id { get; set; }
				[Required(ErrorMessage = "El campo nombre es requerido")]
				[StringLength(10, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
				// [PrimeraLetraMayuscula]
				public required string Nombre { get; set; }
				public List<Libro> Libros { get; set; } = new List<Libro>();

				public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
				{
					if (!string.IsNullOrEmpty(Nombre))
					{
						var primeraLetra = Nombre[0].ToString();

						if (primeraLetra != primeraLetra.ToUpper())
						{
							yield return new ValidationResult("La primera letra debe ser mayúscula - por modelo", new string[] { nameof(Nombre) });
						}
					}
				}

				//[Range(8,120)]
				//public int Edad { get; set; }

				//[CreditCard]
				//public string? TarjetaCredito { get; set; }

				//[Url]
				//public string? URL { get; set; }
			}
		}
		
		-Por esto:
		public class Autor
		{
			public int Id { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Nombre { get; set; }
			public List<Libro> Libros { get; set; } = new List<Libro>();
		}
		
		-En el development.json, comentar esto: // "BibliotecaAPI.Controllers.AutoresController": "Trace",
		-Program, esto:
		using BibliotecaAPI;
		using BibliotecaAPI.Datos;
		using Microsoft.EntityFrameworkCore;
		using System.Text.Json.Serialization;

		namespace BibliotecaAPI
		{
			public class Program
			{
				public static void Main(string[] args)
				{
					var builder = WebApplication.CreateBuilder(args);

					//área de servicios
					builder.Services.AddTransient<ServicioTransient>();
					builder.Services.AddScoped<ServicioScoped>();
					builder.Services.AddSingleton<ServicioSingleton>();

					builder.Services.AddSingleton<IRepositorioValores, RepositorioValoresOracle>();

					builder.Services.AddControllers().AddJsonOptions(opciones => 
					opciones.JsonSerializerOptions.ReferenceHandler = ReferenceHandler.IgnoreCycles);

					builder.Services.AddDbContext<ApplicationDbContext>(opciones => opciones.UseSqlServer("name=DefaultConnection"));

					var app = builder.Build();

					// área de middlewares
					//app.Use(async (contexto, next) =>
					//{
					//    // Viene la petición
					//    var logger = contexto.RequestServices.GetRequiredService<ILogger<Program>>();
					//    logger.LogInformation($"Petición: {contexto.Request.Method} {contexto.Request.Path}");

					//    await next.Invoke();

					//    //Se va la respuesta

					//    logger.LogInformation($"Respuesta: {contexto.Response.StatusCode}");
					//});

					app.UseLogueaPeticion();

					//app.Use(async (contexto, next) =>
					//{
					//    if (contexto.Request.Path == "/bloqueado")
					//    {
					//        contexto.Response.StatusCode = 403;
					//        await contexto.Response.WriteAsync("Acceso Denegado");
					//    } else
					//    {
					//        await next.Invoke();
					//    }
						
					//});

					app.BloqueaPeticion();

					app.MapControllers();

					app.Run();
				}
			}
		}
		
		-Por esto:
		using BibliotecaAPI;
		using BibliotecaAPI.Datos;
		using Microsoft.EntityFrameworkCore;
		using System.Text.Json.Serialization;

		namespace BibliotecaAPI
		{
			public class Program
			{
				public static void Main(string[] args)
				{
					var builder = WebApplication.CreateBuilder(args);

					//área de servicios

					builder.Services.AddControllers().AddJsonOptions(opciones => 
					opciones.JsonSerializerOptions.ReferenceHandler = ReferenceHandler.IgnoreCycles);

					builder.Services.AddDbContext<ApplicationDbContext>(opciones => opciones.UseSqlServer("name=DefaultConnection"));

					var app = builder.Build();

					// área de middlewares

					app.MapControllers();

					app.Run();
				}
			}
		}
		
	66. Repaso de Cómo configurar EF
		-Lo primero es instalar dos paquetes nugget: SQL Server y el de Tools porque se usa Visual Studio y es el que habilita para usar 
		 los comando de EF en el Package Manager Console.
		-Si se usa otro editor, se usa el Design.
		-Luego, se creó la carpeta datos donde se metió el ApplicationDbContext que es una clase que hereda de DBContext y a traves de 
		 esta clase se pueden inyectar las configuraciones fundamentales de EF como por ejemplo, SQL Server y las tablas
		 de Autoresy Libros que se basan en la clase Autor y Libro.
		-En la clase program, se coloca el servicio, AddDbContext y se le pasa opciones. Se mete UseSQLServer y se le pasa el ConnectionString.
		-Esta dentro de development appsettings.
		-Se puede ir a la folder de migrations que es donde estan las migraciones.
		-Una migracion es la representacion en codigo C# de los cambios que van a ocurrir en BBDD.
		-A veces se modifica una entidad que es autor y libro...Son clases que representan tablas en bbdd.
		-Tu modificas una entidad y esa modificacion peude significar una modificacion en BBDD.
		-Se quiere ver que esa modificacion es lo que realmente se quiere y no se quiere equivocar...
		-Y por ejemplo, no se quiere eliminar columna sin querer.
		-Entonces, es importante que para poder modificar la BBDD usando Entity Framework Core, se necesita una kigracion que permite observar los detalles
		 de los cambios que ocurriran en la BBDD. Se tiene  dos migracioens: TablaAutores y TablaLibros que amabas tienen un precio que es fecha en la que
		 las migraciones fueron hechas.
		-En TablaAutores se ve que se crea la tabla Autores.
		-Se ve que por defecto para el campo nombre, se ha metido esto: Nombre = table.Column<string>(type: "nvarchar(max)", nullable: false)
		-Imaginemos qu se quiere meter otra longitud com se ha hecho despues: [StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
		-Se ha hecho despues de lanzar la migracion.
		-Con libros pasa idem.
		-En libro se va a añadir esto.
		[Required]
		[StringLength(250, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
		public required string Titulo { get; set; }
		
		-Para que este cambio se refleje en mi BBDD, se lanza una migracion desde el PackageManager: Add-Migration CofiguracionLongitudColumnas.
		-Esto crea la migracion para ver los cambios que ocurriran en BBDD.
		-Ahora se lanza Update-Database
		-Se va a SQL Server Management Studio y se ven los cambios.
		-Se peuden usar anotaciones de datos para modifcar el esuqema de la tabla de SQL Server.
		-Se peuden hacer modificaciones coo esta en ApplicationDbContext.
		protected override void OnModelCreating(ModelBuilder modelBuilder)
		{
			base.OnModelCreating(modelBuilder);
			modelBuilder.Entity<Autor>().Property(x=>x.Nombre).HasMaxLength(150);
		}
		
		-Nunca boirrar lo de dentro porque puede dar un error al configrar el sistema de usuarios.
		-En el OnModelCreating se peuden hacer modificaciones.
		-Esto es mas poderoso que las anotaciones de datos porque no todo lo que se puede hacer por aqui, se puede hacer desde el otro lado.
		-Las anotaciones la ventaja es que se conectan con ASP.NET Core para hacer validaciones.
		-Si se comenta la anotacion y se deja solo lo de ApplicationDbContext nos va a dejar la columna en BBDD con esa longitud pero cuando ASp.NET Core reciba un nombre con length mayor a 150,
		 no va a auto,aticamente decirnos que habia un error y devolver un VAlidationError porque esto es configuracion de EF.
		 Lo otro es para EF y para validaciones de ASp.NET Core.
		 -Se comenta: modelBuilder.Entity<Autor>().Property(x=>x.Nombre).HasMaxLength(150);
		 
	67. Repaso de Cómo insertar registros en la BBDD
		-Se va a usar EF.
		-Para usar ApplicationDBCOntext en un controlador, se inyecta con constructor y se pone en campo de la clase para poder acceder a este en toda la clase.
		-Se va a post y para poder insertar registro en BBDD usando EF, se hace lo siguiente.
		-El FromBody que estaba en la peticion no hace falta en WebAPI porque por defecto un autor ya viene en el body. Es decir, un tipo complejo 
		 como Autor viene del cuerpo estandoe n conexto de post: [FromBody] Autor autor
		
		
		[HttpPost]
		public async Task<ActionResult> Post(Autor autor) {
			context.Add(autor);
			await context.SaveChangesAsync();
			return Ok();
		}
		
		-Como sabe EF que ese registro va en la tabla de autores?
		-Pues porque EF te permite ser esecifico....Se podria haber puesto: context.Autores.Add(autor);
		-Segun tipo de dato que se le pasa a Add ya sabe el tipo de dato que debe insertar.
		-Cuando se dice Add se marca ese objeto para que sea insertardo en la base de datos cuando se inserten cambios
		-En SaveChangesAsync es cuando guardas cambios. Recorre objetos que haya en memoria este autor y puede haber otro libro por ahi
		 y estan marcados para ser creados, borrados, actualizados y en un soo paquet,e nvio u operacion se hace eso.
		Si debajo de Add(autor) hubiese esto....
		var libro = new Libro() { Titulo= "titulo actualizado", Id = 1 };
		context.Update();
		
		-Se tendrian dos operaciones en memoria pero ninguna se va a hacer hasta que se haga ese Save.
	
	68. Creando recursos con post
		-Hasta ahora se estaba retornando un Ok(); pero el estandar manda retornar un 201 created.
		-De este modo, el cliente sabra que un recurso ha sido creado y obtendra un link a traves del cual podra obtener 
		 dicho recuros recien creado.
		-Primer cambio, desde post en AutoresController, se quiere poder hacer una referencia a le peticion GET.
		-Se le va a poner un nombre para eso a la peticion get: [HttpGet("{id:int}", Name = "ObtenerAutor")]
		-Ahora, en la peticion Post, en vez de poner return Ok(); se pone return CreatedAtRoute; asi se obtienen los datos del autor recien creado.
		-Hay que indicar en el segundo parametro los valores que se le tienen que pasar a este metodo para poder invocarlo, en este caso solo un id.
		[HttpPost]
		public async Task<ActionResult> Post(Autor autor) {
			context.Add(autor);
			await context.SaveChangesAsync();
			return CreatedAtRoute("ObtenerAutor", new { id = autor.Id });
		}
		
		-Cuando se inserta un autor al hacer SaveChangesAsync, se le coloca en la propiedad Id, el id del registro recien creado.
		-Por ultimo, se pasa el autor recien creado.
		[HttpPost]
		public async Task<ActionResult> Post(Autor autor) {
			context.Add(autor);
			await context.SaveChangesAsync();
			return CreatedAtRoute("ObtenerAutor", new { id = autor.Id }, autor);
		}
		
		-Se ejecuta la app. Desde postman se crea nuevo autor.
		https://localhost:7132/api/autores POST
		{
			"Nombre": "Felipe Reyes"
		}
		
		-Si se va a headers en la respuesta se tiene la Location que sirve para obtener el detalle del recurso recien creado.
		-En LibrosController se va a hacer Idem.
		https://localhost:7132/api/libros POST
		{
			"titulo": "Libro nuevo",
			"autorId": 5
		}
		
		-Se coge headers y se lanza GET.
		-Se coge esta peticion y se ve que se saca el autor del libro:
		https://localhost:7132/api/libros/5
		
	69. Nombre, Apellidos y Datos Sensibles
		-Igual se necesita guardar por separado nombres y apellidos de autores.
		-En el post puede que hubiese que mandar por separado nombre y apellidos.
		-Esto porque se peude querer ordenar por nombre o apellido nuestros autores.
		-Eso si, cuando se obtenga la data de los autores, quiero que me concatene nombre y apellido.
		-El nombre debe estar igual que ahora en https://localhost:7132/api/libros/5
		-Otro requerimiento es que se quiere guardar la identificacion del autor por temas legales.
		-Esta identificacion no debe ser mostrada a otros.
		-Ese dato lo puedo recibir al crear un autor pero cuando solicite la data de un autor, no puedo mostrar esa data sensible.
		-Se va a ir a Autor.
		Antes
		public class Autor
		{
			public int Id { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Nombre { get; set; }
			public List<Libro> Libros { get; set; } = new List<Libro>();
		}
		
		Despues. Identificacion sera nullable ? porque es un campo opcional.
		public class Autor
		{
			public int Id { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Nombres { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(20, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Apellidos { get; set; }
			public string? identificacion { get; set; }
			public List<Libro> Libros { get; set; } = new List<Libro>();
		}
		
		-Ahora se compila la app. ctrl + shift + B.
		-Se añade una migracion en el package Manager Console: Add-Migration NuevasColumnas.
		-Se ve lo que pasa en BBDD.
		-Se le da a Update-Database.
		-Se va a SQL Server Management Studio y en columnas se refresca y se ve que se tiene Nombres, Apellidos, Identificacion.
		-Se hace select y se que se tienen los nombres rellenos con info e identificacion y apellidos vacio.
		-Se hace DELET AUTORES; para borrar la data de la tabla.
		-Se crea un nuevo autor y en el POST se cambia el campo a "nombres".
		-Se pone ademas apellidos e identificacion.
		https://localhost:7132/api/autores
		{
			"nombres": "Felipe",
			"apellidos": "Gavilán",
			"identificacion": "123"
		}
		{
			"nombres": "Claudia",
			"apellidos": "Rodríguez",
			"identificacion": "456"
		}
		
		-Se lanza GET a esa URL https://localhost:7132/api/autores
		-Se ve ahora el campo identificacion. Uno de los requerimientos es que se quiere tener nombre y apellidos separados, pero los clientes 
		 de webapi no lo deben tener por separado y no deben ver la identificacion. 
		 
	70. DTOs y Automapper
		-Hasta ahora, siempre que retornamos recursos de webapi usamos entidades de nuestra app.
		-Cuando se habla de entidades nos referimos a esas clases que sirven para modelar una tabbla en nuestra BBDD como autor y libro.
		-Uno de los inconvenientes de esto es que en ocasiones no se quiere ostrar toda l data contenida en estas entidades.
		-Es normal querer mostrar solo un pequeño conjunto de datos y no todo
		-En otras ocasiones, se necesita transformar la data que se quiere mostrar.
		-Por ejemplo, concatenando nombres y apellidos.
		-Una manera de resolver esto es usando objetos de transferencia de datos.
		-Un objetos de transferencia de datos, DTO, Data transfer Object es un objeto que sirve para transportar datos entre procesos.
		-Nosotros usaremos DTOs para representar lso datos que nuestro webapi enviara y recibira de clientes.
		-Se va a comenzar creando DTO que resuelve el problema de lectura de Autores.
		-Se crea nueva carpeta para colocar DTOs. Se crea nueva clase.Se crea la clase AutorDTO.
		-Va a servir para representar una operacion de lectura o consulta de lectura sobre la tabla de autores.
		-Aqu se coloca lo que se quiere que los clientes del WebAPI vean de un Autor.
		-Se mete Id y NombreCompleto.
		public class AutorDTO
		{
			public int Id { get; set; }
			public required string NombreCompleto { get; set; }
		}
		
		-Se va a AutoresController y se va a l get de obtener todos.
		
		ANTES
		[HttpGet] // /api/autores/
		public async Task<IEnumerable<Autor>> Get()
		{
			return await context.Autores.ToListAsync();

		}
		
		DESPUES
		-Select permite transofrmar de un tipo de dato a otro. Se transforma de Autor a AutorDTO.
		-El resumen de lo que se hace aqui es ir a BBDD y obtener el listado de autores, luego no se quiere retornar toda la data de autores, identifica ry nombres y apellidos separados sino como se presemnta en AutorDto.
		-Se hace autores.select para transformar el listado de autores en un listado de AutorDto. autor representa un autor del listadod e autores y se transforma a AutorDTO.
		-Id = autor.ID y el NombreCompleto es la concatenacion.Se usa para ello stringInterpolation.
		[HttpGet] // /api/autores/
		public async Task<IEnumerable<AutorDTO>> Get()
		{
			var autores = await context.Autores.ToListAsync();
			var autoresDTO = autores.Select(autor => 
											new AutorDTO 
											{
												Id = autor.Id,
												NombreCompleto = $"{autor.Nombres} {autor.Apellidos}"
											});
			return autoresDTO;
		}
		
		-Se va a hacer la llamada GET ahora para comprobarlo.
		-En general, es buena practica usar DTO cuando se usan WebAPIs. Se complica cuando se tienen entidades con muchas propeidades.
		-En nuestro caso el mapeo es de dos propeidades cuando hay 20 o 50 seria tedioso y propenso a errores a hacer ese mapeo manualmente.
		-Existen herramientas que nos facilitan ese trabajo.
		-Se peude usar Automapper.
		-Click derecho en el proyecto de WebAPI Administrar paquetes nugget para instalarlo.
		-Se busca el Automapper y se instala.
		-Se va a la clase Program proque se tiene que configurar AutoMapper.
		-Se hace desde el area de servicios. Con esto se configura AutoMapper en la app y estamos indicando que los mapeos se van a configurar dentro del proyecto que se tiene ahi.
		-Eso se indica con el typeof(Program). Ahi se le dice que busque las configuraciones que se encuentren en el proyecto que contiene la clase Program.
		builder.Services.AddAutoMapper(typeof(Program));
		
		-Ahora se quiere usar y se crea una folder que se llamará utilidades y se meterá la clase AutoMapperProfiles. Se le llama profiles a este tipos de clases que tienen el mapeo de Automapper.
		-Se hereda de profile y se tiene un ctor y se colocan los mapeos.
		-Para configurar un mapeo se pone CreateMap que significa crear mapeo que va desde Autores a AutorDto.
		-Este apeo se mapea concatenando nombres y appelidos. S epone forMember. Como obtengo el NombreCompleto?
		 Se pone config.MapFrom se dice de donde sale el NombreCompleto que sale del Autor.
		public class AutoMapperProfiles: Profile
		{
			public AutoMapperProfiles()
			{
				CreateMap<Autor, AutorDTO>()
					.ForMember(dto => dto.NombreCompleto,
						config => config.MapFrom(autor => $"{autor.Nombres} {autor.Apellidos}"));
			}

		}
		
		-Se va a AutoresController y se inyecta el IMapper que e sun servicio de AutoMapper para usar ese mapeo que hemos configurado.
		private readonly ApplicationDbContext context;
		private readonly IMapper mapper;

		public AutoresController(ApplicationDbContext context, IMapper mapper)
		{
			this.context = context;
			this.mapper = mapper;
		}
		
		-Se cambia lo que se tenia antes en HTTPGet.
		[HttpGet] // /api/autores/
		public async Task<IEnumerable<AutorDTO>> Get()
		{
			var autores = await context.Autores.ToListAsync();
			var autoresDTO = autores.Select(autor => 
											new AutorDTO 
											{
												Id = autor.Id,
												NombreCompleto = $"{autor.Nombres} {autor.Apellidos}"
											});
			return autoresDTO;
		}
		
		Ahora
		[HttpGet] // /api/autores/
		public async Task<IEnumerable<AutorDTO>> Get()
		{
			var autores = await context.Autores.ToListAsync();
			var autoresDTO = mapper.Map<IEnumerable<AutorDTO>>(autores);
			return autoresDTO;
		}
				
		-Se prueba la peticion get.
		
		-Se hace lo mismo para la consulta de ObtenerAutor.
		[HttpGet("{id:int}", Name = "ObtenerAutor")] // api/autores/id
		public async Task<ActionResult<Autor>> Get(int id)
		{
			var autor = await context.Autores
				.Include(x => x.Libros)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (autor is null)
			{
				return NotFound();
			}

			return Ok(autor);

		}
		
		Despues
		[HttpGet("{id:int}", Name = "ObtenerAutor")] // api/autores/id
		public async Task<ActionResult<AutorDTO>> Get(int id)
		{
			var autor = await context.Autores
				.Include(x => x.Libros)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (autor is null)
			{
				return NotFound();
			}

			var autorDTO = mapper.Map<AutorDTO>(autor);

			return autorDTO;

		}
		
		-Se va a hacer idem con la peticion POST.
		[HttpPost]
		public async Task<ActionResult> Post(Autor autor) {
			context.Add(autor);
			await context.SaveChangesAsync();
			return CreatedAtRoute("ObtenerAutor", new { id = autor.Id }, autor);
		}
		
		DESPUES
		[HttpPost]
		public async Task<ActionResult> Post(Autor autor) {
			context.Add(autor);
			await context.SaveChangesAsync();
			var autorDTO = mapper.Map<AutorDTO>(autor);
			return CreatedAtRoute("ObtenerAutor", new { id = autor.Id }, autorDTO);
		}
		
		-Se necesita un autor para crear.
		-Se va a carpeta de DTOs y se agrega clase. llevamos todo menos el Id. Nos llevamos todo con lo que se tiene que crear el Autor.
		public class AutorCreacionDTO
		{
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Nombres { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(20, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Apellidos { get; set; }
			public string? identificacion { get; set; }
		}
		
		-Se va a AutoMapperProfiles y se crea el mapeo que va desde AutorCreacionDto a Autor.
		CreateMap<AutorCreacionDTO, Autor>();
		
		-Se va a AutoresControlelr. Se cambia el POST.
		ANTES
		[HttpPost]
		public async Task<ActionResult> Post(Autor autor) {
			context.Add(autor);
			await context.SaveChangesAsync();
			var autorDTO = mapper.Map<AutorDTO>(autor);
			return CreatedAtRoute("ObtenerAutor", new { id = autor.Id }, autorDTO);
		}
		
		DESPUES
		[HttpPost]
		public async Task<ActionResult> Post(AutorCreacionDTO autorCreacionDTO) {
			var autor = mapper.Map<Autor>(autorCreacionDTO);
			context.Add(autor);
			await context.SaveChangesAsync();
			var autorDTO = mapper.Map<AutorDTO>(autor);
			return CreatedAtRoute("ObtenerAutor", new { id = autor.Id }, autorDTO);
		}
		
		Lo mismo en PUT. Se ve que se puede reutilizar el AutoresCreacionDTO porque se tienen las mismas propiedades. Si se tuviesen diferentes propiedades, entonces es cuando
		cambia la cosa y habria que crear un DTO para la actualizacion.
		[HttpPut("{id:int}")] // api/autores/1 
		public async Task<ActionResult> Put(int id, Autor autor)
		{
			if (id != autor.Id)
			{
				return BadRequest("Los IDs deben de coincidir");
			}

			context.Update(autor);
			await context.SaveChangesAsync();
			return Ok();

		}
		
		-Se quita la validacion porque se ve que ya AutorCreacionDTO no tiene id.
		[HttpPut("{id:int}")] // api/autores/1 
		public async Task<ActionResult> Put(int id, AutorCreacionDTO autorCreacionDTO)
		{
			var autor = mapper.Map<Autor>(autorCreacionDTO);
			autor.Id = id;
			context.Update(autor);
			await context.SaveChangesAsync();
			return Ok();

		}
		
		-En delete se ve que no hay entidades utilizadas. No se hace nada.
		-Se va a Postman y se crea Felipe Reyes con el Post.
		https://localhost:7132/api/autores
		{
			"nombres": "Felipe",
			"apellidos": "Reyes",
			"identificacion": "789"
		}
		
		-Se comprueba que se ha creado el registro en BBDD y se lanza un PUT para actualizarlo. El id se saca del recien creado.
		https://localhost:7132/api/autores/8
		{
			"nombres": "Felipe",
			"apellidos": "Reyes - Actualizado",
			"identificacion": "7890"
		}
		
	71. DTOs de Libros
		-Esto es lo que ya se hizo....
		-Se va a crear LibroDTO.
		public class LibroDTO
		{
			public int Id { get; set; }
			public required string Titulo { get; set; }
		}
		
		-En autores se tiene un listado de libros por lo que hay que modificar el DTO de AutorDTO. Se  puede poner de las dos formas...
		public List<LibroDTO> Libros { get; set; } = new List<LibroDTO>();
		public List<LibroDTO> Libros { get; set; } = [];
		
		-Se configura el mapeo en AutoMapperProfiles: CreateMap<Libro, LibroDTO>();
		-Se va a LibrosController, se inyecta el servicio de AutoMapper.
		private readonly ApplicationDbContext context;
		private readonly IMapper mapper;

		public LibrosController(ApplicationDbContext context, IMapper mapper) {
			this.context = context;
			this.mapper = mapper;
		}
		
		-Se cambia el GET
		//Peticiones
		[HttpGet]
		public async Task<IEnumerable<Libro>> Get()
		{
			return await context.Libros.ToListAsync();
		}
		
		DESPUES
		[HttpGet]
		public async Task<IEnumerable<LibroDTO>> Get()
		{
			var libros =  await context.Libros.ToListAsync();
			var librosDTO = mapper.Map<IEnumerable<LibroDTO>>(libros);
			return librosDTO;
		}
		
		-Lo mismo con ObtenerLibro.
		[HttpGet("{id:int}", Name = "ObtenerLibro")] // /api/libros/1
		public async Task<ActionResult<Libro>> Get(int id)
		{
			var libro = await context.Libros
				.Include(x => x.Autor)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (libro is null)
			{
				return NotFound();
			}

			return Ok(libro);
		}
		
		DESPUES
		[HttpGet("{id:int}", Name = "ObtenerLibro")] // /api/libros/1
		public async Task<ActionResult<LibroDTO>> Get(int id)
		{
			var libro = await context.Libros
				.Include(x => x.Autor)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (libro is null)
			{
				return NotFound();
			}

			var libroDTO = mapper.Map<LibroDTO>(libro);

			return libroDTO;
		}
		
		-En el POST se mapea hacia libro.
		[HttpPost]
		public async Task<ActionResult> Post(Libro libro)
		{
			var existeAutor = await context.Autores.AnyAsync(x => x.Id == libro.AutorId);

			if (!existeAutor)
			{
				ModelState.AddModelError(nameof(libro.AutorId), $"El autor de id {libro.AutorId} no existe");
				return ValidationProblem();
				// return BadRequest($"El autor de id {libro.AutorId} no existe");
			}

			context.Add(libro);
			await context.SaveChangesAsync();
			return CreatedAtRoute("ObtenerLibro", new { id = libro.Id }, libro);
		}
		
		DESPUES
		[HttpPost]
		public async Task<ActionResult> Post(Libro libro)
		{
			var existeAutor = await context.Autores.AnyAsync(x => x.Id == libro.AutorId);

			if (!existeAutor)
			{
				ModelState.AddModelError(nameof(libro.AutorId), $"El autor de id {libro.AutorId} no existe");
				return ValidationProblem();
			}

			context.Add(libro);
			await context.SaveChangesAsync();

			var libroDTO = mapper.Map<LibroDTO>(libro);

			return CreatedAtRoute("ObtenerLibro", new { id = libro.Id }, libroDTO);
		}
		
		-Se quiere un DTO para crear un libro asi que se crea esa clase.
		public class LibroCreacionDTO
		{
			[Required]
			[StringLength(250, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			public required string Titulo { get; set; }
			public int AutorId { get; set; }
		}
		
		-Se hace el mapeo en AutoMapperprofiles.
		CreateMap<LibroCreacionDTO, Libro>();
		
		-En LibrosController se modifica el Post.
		[HttpPost]
		public async Task<ActionResult> Post(LibroCreacionDTO libroCreacionDTO)
		{
			var libro = mapper.Map<Libro>(libroCreacionDTO);
			var existeAutor = await context.Autores.AnyAsync(x => x.Id == libro.AutorId);

			if (!existeAutor)
			{
				ModelState.AddModelError(nameof(libro.AutorId), $"El autor de id {libro.AutorId} no existe");
				return ValidationProblem();
			}

			context.Add(libro);
			await context.SaveChangesAsync();

			var libroDTO = mapper.Map<LibroDTO>(libro);

			return CreatedAtRoute("ObtenerLibro", new { id = libro.Id }, libroDTO);
		}
		
		Se modifica el PUT
		[HttpPut("{id:int}")]
		public async Task<ActionResult> Put(int id, Libro libro)
		{
			if(id != libro.Id)
			{
				return BadRequest("Los IDs deben de coincidir");
			}

			var existeAutor = await context.Autores.AnyAsync(x => x.Id == libro.AutorId);

			if (!existeAutor)
			{
				return BadRequest($"El autor de id {libro.AutorId} no existe");
			}

			context.Update(libro);
			await context.SaveChangesAsync();
			return Ok();
		}
		
		DESPUES
		[HttpPut("{id:int}")]
		public async Task<ActionResult> Put(int id, LibroCreacionDTO libroCreacionDTO)
		{
			var libro = mapper.Map<Libro>(libroCreacionDTO);
			libro.Id = id;

			var existeAutor = await context.Autores.AnyAsync(x => x.Id == libro.AutorId);

			if (!existeAutor)
			{
				return BadRequest($"El autor de id {libro.AutorId} no existe");
			}

			context.Update(libro);
			await context.SaveChangesAsync();
			return Ok();
		}
		
		-Se prueba. Se va a get de un autor que tenga libros. No se han creado libros porque al borrar autores, se han borrado sus libros.
		-Se crea un libro.
		https://localhost:7132/api/libros POST
		{
			"Titulo": "Libro1",
			"autorId": 6
		}
		
		
		-Luego se hace GET del autor de ese libro.
		-Luego se hace un get al libro recien creado.
		-Luego un PUT del libro.
		https://localhost:7132/api/libros/6
		{
			"Titulo": "Libro1 - ACTUALIZADO",
			"autorId": 6
		}
		
	72. DTOs que suman
		-Se va a ir a Postman y se hacen opruebas.
		-En el listado de autores, aparecen libros vacios.
		-En el listado de libros tampoco aparece el Id y nombre de autor.
		-Distintas acciones tienen distintas necesidades.
		-Se van a crear DTOs distintos para cada caso y para no repetir code se puede usar herencia.
		
		-En el listado de Autores viene el listado de libros vacios.
		-Se crea DTO de Autor con  libros.
		-Se tieen dos versiones una con el listado de libros y otra sin el listado de libros.
		-Se llama AutorConLibrosDTO.
		public class AutorConLibrosDTO: AutorDTO
		{
			public List<LibroDTO> Libros { get; set; } = new List<LibroDTO>();
		}
		
		-AutorDTO
		public class AutorDTO
		{
			public int Id { get; set; }
			public required string NombreCompleto { get; set; }
		}
		
		-Sis e quiere AutorDTO sin libros se usa AutorDTo, si se quiere con libros AutorConLibrosDTO que hereda de esta ultima y ya tiene Id y Titulo.
		-Se va a AutoMapperProfiles y se mete esto:
		CreateMap<Autor, AutorConLibrosDTO>()
		.ForMember(dto => dto.NombreCompleto,
			config => config.MapFrom(autor => $"{autor.Nombres} {autor.Apellidos}"));
		
		-Se va a AutoresController y en el GET se devuelve el listado de autores sin los libros.
		-Pero en GET por ID, si se quiere usar AutorConLIbrosDTO.
		[HttpGet("{id:int}", Name = "ObtenerAutor")] // api/autores/id
		public async Task<ActionResult<AutorConLibrosDTO>> Get(int id)
		{
			var autor = await context.Autores
				.Include(x => x.Libros)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (autor is null)
			{
				return NotFound();
			}

			var autorDTO = mapper.Map<AutorConLibrosDTO>(autor);

			return autorDTO;
		}
		-Ahora se ve que en el listado de libros ya no se listan los libros de un autor. No se rellena un array que no se iba a rellenar...
		
		-Para el detalle del libro, se quiere que se devuelva la data con el autor.
		-Se crea DTO de libro con autor...
		public class LibroConAutorDTO: LibroDTO
		{
			public int AutorId { get; set; }
			public required string AutorNombre { get; set; }
		}
		
		-se hereda de LibroDto para usar el Id y Titulo del Libro.
		-Se va a AutoMapperporofiles.
		CreateMap<Libro, LibroConAutorDTO>()
			.ForMember(dto => dto.AutorNombre, config =>
				config.MapFrom(ent => $"{ent.Autor!.Nombres} {ent.Autor.Apellidos}"));

		-En LibroController en et por Id.
		 [HttpGet("{id:int}", Name = "ObtenerLibro")] // /api/libros/1
		 public async Task<ActionResult<LibroConAutorDTO>> Get(int id)
		 {
			 var libro = await context.Libros
				 .Include(x => x.Autor)
				 .FirstOrDefaultAsync(x => x.Id == id);

			 if (libro is null)
			 {
				 return NotFound();
			 }

			 var libroDTO = mapper.Map<LibroConAutorDTO>(libro);

			 return libroDTO;
		 }
		 
		 -En obtener LibroPorId ahora trae la data con el autor. Se hace la consulta desde PostMan.
		 
		-Como esta venga repetirse una parte del code en AutoMapper se va a colocar eso en una funcion....
		config => config.MapFrom(autor => $"{autor.Nombres} {autor.Apellidos}"));
		
		public AutoMapperProfiles()
		{
			CreateMap<Autor, AutorDTO>()
				.ForMember(dto => dto.NombreCompleto,
					config => config.MapFrom(autor => MapearNombreYApellidoAutor(autor)));

			CreateMap<Autor, AutorConLibrosDTO>()
				.ForMember(dto => dto.NombreCompleto,
					config => config.MapFrom(autor => MapearNombreYApellidoAutor(autor)));

			CreateMap<AutorCreacionDTO, Autor>();

			CreateMap<Libro, LibroDTO>();
			CreateMap<LibroCreacionDTO, Libro>();

			CreateMap<Libro, LibroConAutorDTO>()
				.ForMember(dto => dto.AutorNombre, config =>
					config.MapFrom(ent => MapearNombreYApellidoAutor(ent.Autor!)));
		}

		private string MapearNombreYApellidoAutor(Autor autor) => $"{autor.Nombres} {autor.Apellidos}";
		
	73. Leyendo Registros de EF Core
		-Vamos a AutoresController y vemos que obtenemos el listado de Autores.
		-La forma mas sencilla se ve que es autores = await context.Autores.ToListAsync();
		-Si se quiere obtener un autor por su id, se hace context.Autores y se dice include para obtener la data relacionada de libros. COn ForstOrdefaultAsync para obtener
		el primer registro o un valor por defecto y que cumpla que su id sea igual al valor que se pasa por parametro.
		Con eso se obtiene el primer autor que tenga ese id como su id o un valor por defecto que seria nulo.
		Si es nulo se retorna 404, sino el Autor.
		-Con Where tambien se pueden filtrar varios registros.
		-Si fuera alguna caracteristica que muchos autores tuvieran y se quiere obtener un listado de autores peor con una caracteristica. Para eso, se usa 
		 WHERE. Eso se hace en el delete context.Autores.Where. Se ve que se borra por Id.
	
	74. Actualizando Recursos
		-Se va a repasar la parte de editar un recurso. Para esto se usa el http PUT. 
		-Se pasa el Id porque se edita un recuros especifico y por eso se añade en la URL.
		-Se recibe el id del recurso y el recurso como tal.
		-En caso de EF se usa Update para marcar el objeto para ser actualizado y ya cuando se hace el SaveChangesAsync se actualiza el el regsitro de la bdd.
		-Algo que no es obligatorio pero si estandar es que en caso de actualizacion ya que cliente tiene el recurso que quiere actualizar. 
		 Por qpara actualizar el recurso, tienes qe tenerlo. No se suele retornar un Ok(), sino un NoContent que es un 204.
		-Esto es un estandar en Web APIs.
		-Esto retorna un 204 NotContent que es todo OK, pero no te puedo retornar nada porque tienes ya el recurso que has actualziado.
		[HttpPut("{id:int}")] // api/autores/1 
		public async Task<ActionResult> Put(int id, AutorCreacionDTO autorCreacionDTO)
		{
			var autor = mapper.Map<Autor>(autorCreacionDTO);
			autor.Id = id;
			context.Update(autor);
			await context.SaveChangesAsync();
			return Ok();

		}
		
		Por esto:
		[HttpPut("{id:int}")] // api/autores/1 
		public async Task<ActionResult> Put(int id, AutorCreacionDTO autorCreacionDTO)
		{
			var autor = mapper.Map<Autor>(autorCreacionDTO);
			autor.Id = id;
			context.Update(autor);
			await context.SaveChangesAsync();
			return NoContent();

		}
		
		-Idem se hace con el Delete.
		-Con Libros Idem.
		
	75. HTTP Patch y JSON patch
		-Se usa este para aplicar actualizaciones aprciales a un recurso. Si se tiene un recuros y solo se quieren actualizar unos pocos campos de este,
		 y no todos este el metodo HTTP a usar. El cliente enviara un cuerpo en la peticion HTTP el cual indicara los cambios que desea hacer sobre el recurso.
		 Se tiene qie saber los campos que desea modificar el cliente y cuales van a ser los nuevos valores.
		-Como indica el cliente esta info? El RFC 5789 no dice mucho acerca de como debe ser esa estructura.
		-Por suerte, existe un estandar en RFC 6902 llamado JSON Patch.
		-Este se usa para HTTP Patch. El JSON Patch indica como debe ser la estructura del cuerpo de la peticion HTTP que indica los cambios que el cliente quiere hacer sobre el recuros.
		-Este estandar define un cjto de oepraciones: agregar, remover, reemplezar, mover, copiar y pegar. A nosotros nos interesa reemplazar la cual usaremos para actualziar
		 campos de un recurso. 
		-Ejemplo de cuerpo de reemplazo:
			[
				{"op": "replace", "path": "/nombres", "value": "Felipe Gavilan"},
				{"op": "replace", "path": "/identificacion", "value": "123"},
			]
			
		-op es la oepracion. path dice el campo y el value el valor que tomara el campo.
		
	76. Actualizando solo algunos campos con HTTP Patch
		-Se instala primero un paquete Nugget: Se descarga el NewtonsoftJSON:Microsoft.AspNetCore.Mvc.NewtonsoftJson
		-Incluye el input y output del JSONPatch
		-Se configura el uso del NewtonSoft para poder usar el JSON Patch.
		-Se va a la clase Program. Ya no se necesita JsonOptions porque se esta devolviendo DTOs.
		-Ahora se usa AddNewtonSoftJSON.
		builder.Services.AddControllers().AddJsonOptions(opciones => 
		opciones.JsonSerializerOptions.ReferenceHandler = ReferenceHandler.IgnoreCycles);
		
		Por esto:
		builder.Services.AddControllers().AddNewtonsoftJson();
		
		-Se crea nuevo DTO para el patch: AutorPatchDTO. Nos llevamos lo de AutorCreacionDTO.
		public class AutorPatchDTO
		{
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Nombres { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(20, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Apellidos { get; set; }
			public string? identificacion { get; set; }
		}
		
		-Se va a AutoresController para añadir la accion correspondiente.
		-Se mete debajo de PUT. Se mete un condicional porque si el patchDoc es nulo es que el cuerpo de la peticion tiene algun error.
		-Se va a BBDD y se busca autor correspondiente. Sino se encuentra se devuelve un NotFound.
		-Se hace mapeo de autor a autorPatchDto.
		-Se valida que el campo nombr eo apellidos este relleno.
		-No hay que hacer contextUpdate por ue autorDB fue obtenido de ese contexto y EF ya sabe que hay un registro de la tabla autores que
		 se coirresponde con objeto autorDB.
		[HttpPatch("{id:int}")]
		public async Task<ActionResult> Patch(int id, JsonPatchDocument<AutorPatchDTO> patchDoc)
		{
			if (patchDoc is null)
			{
				return BadRequest();
			}

			var autorDB = await context.Autores.FirstOrDefaultAsync(x => x.Id == id);

			if (autorDB is null)
			{
				return NotFound();
			}

			var autorPatchDTO = mapper.Map<AutorPatchDTO>(autorDB);

			patchDoc.ApplyTo(autorPatchDTO, ModelState);

			var esValido = TryValidateModel(autorPatchDTO);

			if (!esValido)
			{
				return ValidationProblem();
			}

			mapper.Map(autorPatchDTO, autorDB);

			await context.SaveChangesAsync();

			return NoContent();
		}
		
		-Hay que ir a AutoMapperProfiles. Hay que mapear de autor a AutorPatchDTO.
		-Hay otro mapeo de AutorPatchDTO a Autor. Con ReverseMap va en ambos sentidos.
		CreateMap<Autor, AutorPatchDTO>().ReverseMap();
		
		-Se va a PostMan.
		-Se hace un Patch de un Autor para modificar un Autor.
		[
			{"op": "replace", "path": "/nombres", "value": "Felipe 2"}
		]
		
		[
			{"op": "replace", "path": "/nombres", "value": "Felipe"},
			{"op": "replace", "path": "/apellidos", "value": "Reyes"},
		]
		
		-Si le mando un campo de nombres vacio, tiene que devovler un Validationproblem con el campo requerido, la priemra tiene que ser mayus etc.
		
	77. Borrando Recursos
		-Se va a AutoresController. Se borra con HTTP Delete. para borrar un registro se usa ExecuteDeleteAsync que le dices tabla que contiene registros, usas filtro para indicar registros 
		 borrar y esto retorna cantidad de regs borrados.
		-Espo se guarda en vble. Si es igual a cero no ha sibdo nada borrado y ene se caso no existe autor con ese ID y se devuelve 404 Not Found. Si es disitnto de cero, se 
		retorna un 204 NoContent. Se esta borrando un reg, pero podria estar borrandose mas.....
	
	78. Relación Uno a Muchos
		-Se crea nueva relación entre libros y comentarios.
		-Se pueden escribir comentarios acerca de los libros que se han leido.
		-Se hizo entre autores y libros ya.
		-Se crea nueva Entidad. Se hace desde Entidades. El Id sera un GUID que es un string aleatorio se hace esto en comentario porque se espera tener miles, cientos de miles de comentarios
		 pues se usa un GUID para no acabarse los numeros. En enteros hay 2mil millones de comentarios y se espera tener mas....
		public class Comentario
		{
			public Guid Id { get; set; }
			public required string  Cuerpo { get; set; }
			public DateTime FechaPublicacion { get; set; }
			public int LibroId { get; set; }
			public Libro? Libro { get; set; }
		}
		
		-Se va al ApplicationDbContext y se añade el DbSet concreto.
		-public DbSet<Comentario> Comentarios { get; set; }
		
		-En Libro, se coloca el listado de Comentarios: public List<Comentario> Comentarios { get; set; } = new List<Comentario>();
		
		-Se añade la migracion: Add-Migration TablaComentarios.
		-Se mete Update-Database.
		-Se va a SQL Server Management Studio y se ve la nueva tabla.
	
	79. Controlador de un Recurso Dependiente
		-La relacion entre libros y comentarios es peculiar porque un comentario no tiene sentido sin un libro.
		-Por tanto, estamos ante relacion dependiente, donde el comentario depende del libro.
		-Esto se peude modelar en ruta de los comentarios colocando siempre el id del libro en cualquier ruta de mi controlador de comentarios.
		-Se crea controlador de comentarios.
		-Se coloca en la ruta el id del Libro al que le corresponde el comentario.
		-Para acceder al comentario de un libro, tengo que decir api/libros/id_libro/scomentarios. Asi permite ejecutar las acciones de 
		 este controlador que tenemos aqui.
		[ApiController]
		[Route("api/libros/{libroId:int}/comentarios")]
		public class ComentariosController: ControllerBase
		{
			private readonly ApplicationDbContext context;
			private readonly IMapper mapper;

			public ComentariosController(ApplicationDbContext context, IMapper mapper)
			{
				this.context = context;
				this.mapper = mapper;
			}
		}
		
		-Se crean los DTOs correspondientes.
		-Se cambia esto en comentario porque no tiene sentido un comentario sin cuerpo.
		[Required]
		public required string  Cuerpo { get; set; }
		
		public class ComentarioCreacionDTO
		{
			[Required]
			public required string Cuerpo { get; set; }
		}
		
		-No se incluye el Id del libro porque se incluye en la URL.
		
		-Este es el de lecyura y por eso no se pone Required.
		public class ComentarioDTO
		{
			public Guid Id { get; set; }
			public required string Cuerpo { get; set; }
			public DateTime FechaPublicacion { get; set; }
		}
		
		-Se va a AutoMapperProfiles.
		CreateMap<ComentarioCreacionDTO, Comentario>();
		CreateMap<Comentario, ComentarioDTO>();
		
		-Se crea ComentariopatchDTO. Se hereda de ComentarioCreacionDTO para no estar repticiendo code.
		public class ComentarioPatchDTO: ComentarioCreacionDTO
		{
		}
		
		-Se mappea.
		CreateMap<ComentarioPatchDTO, Comentario>().ReverseMap();
		
		-Se hace el get en ComentariosController. Se obtienen comentarios de un libro.
		-libroId proviene de la ruta.
		-Se comprueba existencia del libro para no estar buscando comentarios de un libro inexistente.
		[HttpGet]
		public async Task<ActionResult<List<ComentarioDTO>>> Get(int libroId)
		{
			var existeLibro = await context.Libros.AnyAsync(x => x.Id == libroId);

			if (!existeLibro)
			{
				return NotFound();
			}

			var comentarios = await context.Comentarios
				.Where(x => x.LibroId == libroId)
				.OrderByDescending(x => x.FechaPublicacion)
				.ToListAsync();

			return mapper.Map<List<ComentarioDTO>>(comentarios);
		}
		
		-Se otiene comentario por su id. 
		[HttpGet("{id}", Name ="ObtenerComentario")]
		public async Task<ActionResult<ComentarioDTO>> Get(Guid id)
		{
			var comentario = await context.Comentarios.FirstOrDefaultAsync(x => x.Id == id);

			if(comentario is null)
			{
				return NotFound();
			}

			return mapper.Map<ComentarioDTO>(comentario);
		}
		
		-Se hace un POST.
		[HttpPost]
		public async Task<ActionResult<ComentarioDTO>> Post(int libroId, ComentarioCreacionDTO comentarioCreacionDTO)
		{
			var existeLibro = await context.Libros.AnyAsync(x => x.Id == libroId);

			if (!existeLibro)
			{
				return NotFound();
			}

			var comentario = mapper.Map<Comentario>(comentarioCreacionDTO);
			comentario.LibroId = libroId;
			comentario.FechaPublicacion = DateTime.Now;
			context.Add(comentario);
			await context.SaveChangesAsync();

			var comentarioDTO = mapper.Map<ComentarioDTO>(comentario);

			return CreatedAtRoute("ObtenerComentario", new { id = comentario.Id, libroId }, comentarioDTO);
		}
		
		-En el comentario no se usa PUT, sino PATCh porque tenemos campos como FechaPublicacion que nunca se vana a recibir a traves de ComentarioCreacionDTO.
		-Es idem a HttpPatch de AutoresController. Se copia de ahi.
		[HttpPatch("{id}")]
		public async Task<ActionResult> Patch(Guid id, int libroId, JsonPatchDocument<ComentarioPatchDTO> patchDoc)
		{
			if (patchDoc is null)
			{
				return BadRequest();
			}

			var existeLibro = await context.Libros.AnyAsync(x => x.Id == libroId);

			if (!existeLibro)
			{
				return NotFound();
			}

			var comentarioDB = await context.Comentarios.FirstOrDefaultAsync(x => x.Id == id);

			if (comentarioDB is null)
			{
				return NotFound();
			}

			var comentarioPatchDTO = mapper.Map<ComentarioPatchDTO>(comentarioDB);

			patchDoc.ApplyTo(comentarioPatchDTO, ModelState);

			var esValido = TryValidateModel(comentarioPatchDTO);

			if (!esValido)
			{
				return ValidationProblem();
			}

			mapper.Map(comentarioPatchDTO, comentarioDB);

			await context.SaveChangesAsync();

			return NoContent();
		}
		
		-Se mete el Delete.
		[HttpDelete("{id}")]
		public async Task<ActionResult> Delete(Guid id, int libroId)
		{
			var existeLibro = await context.Libros.AnyAsync(x => x.Id == libroId);

			if (!existeLibro)
			{
				return NotFound();
			}

			var registrosBorrados = await context.Comentarios.Where(x => x.Id == id).ExecuteDeleteAsync();

			if (registrosBorrados == 0)
			{
				return NotFound();
			}

			return NoContent();
		}
		
		-Se busca el id de un libro en Sql Server Management Studio y se va a postMan.
		GET https://localhost:7132/api/libros/6/comentarios Vacio porque no hay comentarios.
		POST https://localhost:7132/api/libros/6/comentarios
		
		
		-Por headers, se coge URl: https://localhost:7132/api/libros/6/comentarios/9714303a-4ada-4d51-0f13-08dd59b9b19c
		Se hace GET
		Se duplica y se hace Patch.
		[
			{
				"op": "replace",
				"path": "cuerpo",
				"value": "Muy buen Libro - ACTUALIZADO"
			}
		]
		
		-Se vuelve a hacer GET y se ve RDO. Se podria hacer DELETE.
		
	80. Relación Muchos a Muchos
		-Es tiempo de que exploremso esto.
		-Es la relación natural entre autores y libros, porque un autor puede escribirmuchos libros, mientras que un libro puede ser escrito por varios autores.
		-Es como tener dos relaciones uno a muchos combinadas. Uno a muchos de autores a libros y uno a muchos de libros a autores.
		-Esta relacion recibe el nombre de muchos a muchos.
		-Al principio, se puso la relacion de 1 a N para mantener esto simple.
		-Se va a crear una relacion mas realista.
		-La relacion muchos a muchos se modela con tabla intermedia. Es decir, se creara una tabla que contendra las distintas relacioens entre autores y libros.
		-Se crea nueva Entidad.
		public class AutorLibro
		{
			public int AutorId { get; set; }
			public int LibroId { get; set; }
		}
		
		-Se quiere campo orden porque se quiere poder ordenar el listado de autores de un libro.
		-Tipicamente, el primer autor que sale es el que mas contribuyó al libro.
		-Se necesitan props de navegacion.
		-No se tiene propiedad Id porque la propiedad primaria de AutorLibro es composicion de AutorId y LibroId, como son dos se pone lo de Primarykey.
		-Asi se garantiza la unicdad, es decir que no va a haber dos regs que tengan mismo autor y mismo libro
		[PrimaryKey(nameof(AutorId), nameof(LibroId))]
		public class AutorLibro
		{
			public int AutorId { get; set; }
			public int LibroId { get; set; }
			public int Orden { get; set; }
			public Autor? Autor { get; set; }
			public Libro? Libro { get; set; }
		}
		
		-Se cambia Libro.
		public class Libro
		{
			public int Id { get; set; }
			[Required]
			[StringLength(250, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			public required string Titulo { get; set; }
			public int AutorId { get; set; }
			public Autor? Autor { get; set; }

		}
		
		public class Libro
		{
			public int Id { get; set; }
			[Required]
			[StringLength(250, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			public required string Titulo { get; set; }
			public List<AutorLibro> Autores { get; set; } = [];
			public List<Comentario> Comentarios { get; set; } = [];

		}
		
		-Se cambia Autor.
		public class Autor
		{
			public int Id { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Nombres { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(20, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Apellidos { get; set; }
			public string? identificacion { get; set; }
			public List<Libro> Libros { get; set; } = new List<Libro>();
		}
		
		public class Autor
		{
			public int Id { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Nombres { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(20, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Apellidos { get; set; }
			public string? identificacion { get; set; }
			public List<AutorLibro> Libros { get; set; } = [];
		}
		
		-Se va a ApplicationDbContext y se hace esto:
		public DbSet<AutorLibro> AutoresLibros { get; set; }
		
		-Se comenta el HttpPost y el HttpPut de LibrosController porque sino hay errores.
		-En el ObtenerLibro, se cambia esto.
		[HttpGet("{id:int}", Name = "ObtenerLibro")] // /api/libros/1
		public async Task<ActionResult<LibroConAutorDTO>> Get(int id)
		{
			var libro = await context.Libros
				.Include(x => x.Autor)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (libro is null)
			{
				return NotFound();
			}

			var libroDTO = mapper.Map<LibroConAutorDTO>(libro);

			return libroDTO;
		}
		
		[HttpGet("{id:int}", Name = "ObtenerLibro")] // /api/libros/1
		public async Task<ActionResult<LibroConAutorDTO>> Get(int id)
		{
			var libro = await context.Libros
				.Include(x => x.Autores)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (libro is null)
			{
				return NotFound();
			}

			var libroDTO = mapper.Map<LibroConAutorDTO>(libro);

			return libroDTO;
		}
		
		-Se comenta esto en mapeos:
		//CreateMap<Libro, LibroConAutorDTO>()
		//    .ForMember(dto => dto.AutorNombre, config =>
		//        config.MapFrom(ent => MapearNombreYApellidoAutor(ent.Autor!)));
		
		-Se compila el proyecto y se le da a Add-Migration.
		Add-Migration TablaAutoresLibros
		
		-Se da advertencia porque se va a eliminar columna AutorId en Libros. ya nos e tiene porque la tabla intermedia AutoresLibros es la que va a modela esta relacion.
		-Update-Database
		-Se va a SQL Server Management Studio y se ve que ya no se tiene la columna AutorId y se tiene la doble primary key con AutorId y LibroId.
	
	81. Insertando Datos en una Relación Muchos a Muchos
		-Para crear uun libro no se envia solo un autor, sino varios.
		-Se va a LibroCreacionDTO y se cambia la ultima propiedad.
		public class LibroCreacionDTO
		{
			[Required]
			[StringLength(250, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			public required string Titulo { get; set; }
			public int AutorId { get; set; }
		}
		
		Despues
		public class LibroCreacionDTO
		{
			[Required]
			[StringLength(250, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			public required string Titulo { get; set; }
			public List<int> AutoresIds { get; set; } = [];
		}
		
		-Se va a AutoMapperProfiles y se busca ese fichero con Ctrl + Coma.
		-Se busca el mapeo de LibroCreacionDto a Libro y se añade ForMember porque se quiere mapear LibroCreacionDto, esos AutoresIds a esa lista de AutorLibro dentro de Libro.
		-Se mapea de listado de enteros a AutorLibro.
		-Se crea un AutorLibro por cada enterp que haya en ese listado.
		-Cada Id es un Id de Autor.
		-Asi se apea hacia Autores, nuestros AutoresIds.
		CreateMap<LibroCreacionDTO, Libro>();
		
		Despues
		CreateMap<LibroCreacionDTO, Libro>()
			.ForMember(ent => ent.Autores, config =>
			config.MapFrom(dto => dto.AutoresIds.Select(id => new AutorLibro { AutorId = id })));
		
		-Se descomenta el HttpPost de LibrosController.
		-Se hacen dos validaciones en la segunda validacion se le dice que traiga todos los autores que se encuentren en esa lista de AutoresIds.
		-Se valida que ese listado de autores que se obtiene es igual a los AutoresIds. Sino, se estarian mandando autores que no existen.
		-Se buscarian los autores que no existen.
		Antes
		[HttpPost]
		public async Task<ActionResult> Post(LibroCreacionDTO libroCreacionDTO)
		{
			var libro = mapper.Map<Libro>(libroCreacionDTO);
			var existeAutor = await context.Autores.AnyAsync(x => x.Id == libro.AutorId);

			if (!existeAutor)
			{
				ModelState.AddModelError(nameof(libro.AutorId), $"El autor de id {libro.AutorId} no existe");
				return ValidationProblem();
			}

			context.Add(libro);
			await context.SaveChangesAsync();

			var libroDTO = mapper.Map<LibroDTO>(libro);

			return CreatedAtRoute("ObtenerLibro", new { id = libro.Id }, libroDTO);
		}
		
		Se tiene el tema del orden de los autores asi que se añade un metodo privado.
		private void AsignarOrdenAutores(Libro libro)
		{
			if (libro.Autores is not null)
			{
				for (int i = 0; i < libro.Autores.Count; i++) {
					libro.Autores[i].Orden = i;
				}
			}
		}
		
		DESPUES
		[HttpPost]
		public async Task<ActionResult> Post(LibroCreacionDTO libroCreacionDTO)
		{
			if(libroCreacionDTO.AutoresIds is null || libroCreacionDTO.AutoresIds.Count == 0)
			{
				ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds),
					"No se puede crear un libro sin autores");
				return ValidationProblem();
			}

			var autoresIdsExisten = await context.Autores
									.Where(x => libroCreacionDTO.AutoresIds.Contains(x.Id))
									.Select(x => x.Id).ToListAsync();

			if (autoresIdsExisten.Count != libroCreacionDTO.AutoresIds.Count)
			{
				var autoresNoExisten = libroCreacionDTO.AutoresIds.Except(autoresIdsExisten); ;
				var autoresNoExistenString = string.Join(",", autoresNoExisten);
				var mensajeError = $"Los siguientes autores no existen: {autoresNoExistenString}";
				ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds), mensajeError);
				return ValidationProblem();
			}

			var libro = mapper.Map<Libro>(libroCreacionDTO);
			AsignarOrdenAutores(libro);

			context.Add(libro);
			await context.SaveChangesAsync();

			var libroDTO = mapper.Map<LibroDTO>(libro);

			return CreatedAtRoute("ObtenerLibro", new { id = libro.Id }, libroDTO);
		}
		
		-Aqui se han validado los AutoresIds tanto de que vengan como que existan.
		-Se compila.
		-Se levanta la app
		-Se va a postman y se crea la peticion POST.
		POST https://localhost:7132/api/libros/
		{
			"titulo": "Programando en C#",
			"autoresIds": []
		}
		
		-Dara error y dira que faltan los autores. Dira que los dos primeros no existen.
		POST https://localhost:7132/api/libros/
		{
			"titulo": "Programando en C#",
			"autoresIds": [125, 250, 7]
		}
		
		-Se envia para dos que existan:
		POST https://localhost:7132/api/libros/
		{
			"titulo": "Programando en C#",
			"autoresIds": [7, 8]
		}
		
		-En la tabla AutoresLibros se ve esa relacion de qie para el id 7 se ha metido autor 7 y 8 y el orden va por orden ascendente de Ids.
		
	82. Actualziando Registros de Relaciones Muchos a Muchos
		-Quizas se quiera agregar autores a un libros, remover autores o cambiar orden de autores. Se usa tecnica con Automapper.
		-Se va a LibrosController y se descomenta el Put.
		-Se copia validacion del Post.
		Antes
		[HttpPut("{id:int}")]
		public async Task<ActionResult> Put(int id, LibroCreacionDTO libroCreacionDTO)
		{
			var libro = mapper.Map<Libro>(libroCreacionDTO);
			libro.Id = id;

			var existeAutor = await context.Autores.AnyAsync(x => x.Id == libro.AutorId);

			if (!existeAutor)
			{
				return BadRequest($"El autor de id {libro.AutorId} no existe");
			}

			context.Update(libro);
			await context.SaveChangesAsync();
			return NoContent();
		}
		
		-Se trae la dat del libro de la BBDD.
		-Con esto se tiene la logica que actualiza la dat de libros comotitulos y autores, si se quieren agregar o borrar auotres de un libro...
		[HttpPut("{id:int}")]
		public async Task<ActionResult> Put(int id, LibroCreacionDTO libroCreacionDTO)
		{
			if (libroCreacionDTO.AutoresIds is null || libroCreacionDTO.AutoresIds.Count == 0)
			{
				ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds),
					"No se puede crear un libro sin autores");
				return ValidationProblem();
			}

			var autoresIdsExisten = await context.Autores
									.Where(x => libroCreacionDTO.AutoresIds.Contains(x.Id))
									.Select(x => x.Id).ToListAsync();

			if (autoresIdsExisten.Count != libroCreacionDTO.AutoresIds.Count)
			{
				var autoresNoExisten = libroCreacionDTO.AutoresIds.Except(autoresIdsExisten); ;
				var autoresNoExistenString = string.Join(",", autoresNoExisten);
				var mensajeError = $"Los siguientes autores no existen: {autoresNoExistenString}";
				ModelState.AddModelError(nameof(libroCreacionDTO.AutoresIds), mensajeError);
				return ValidationProblem();
			}

			var libroDB = await context.Libros
						  .Include(x => x.Autores)
						  .FirstOrDefaultAsync(x => x.Id == id);

			if(libroDB is null)
			{
				return NotFound();
			}

			libroDB = mapper.Map(libroCreacionDTO, libroDB);
			AsignarOrdenAutores(libroDB);

			await context.SaveChangesAsync();
			return NoContent();
		}
		
		-Se va a DB y se trae la data del libro cona autores. AutoMapper se encarag de hacer mapeo de tal forma que no solamente actualice libro, sino data relacionada con lo del Include.
		-Cuando AutoMapper haga mapeo, se hace mapeo de los autores. Con AuitoresIds se actualiza el listado de AuotrLibro.
		-Como libroDB es un objeto el cual vino de EF, al hacerle modificaciones AutoMapper y hacerle SaveChangesAsync...se guarda en BBDD, tanto modificaciones de libro como data relacionada.
		-Se guarda, se ejecuta y se levanta Postman.
		-Se hace peticion PUT.
		PUT https://localhost:7132/api/libros/7
		{
			"titulo": "Programando en C# - Edicion 2",
			"autoresIds": [6, 8]
		}
		
		-Se ve que se ha cambiado la data en Libros y AutoresLIbros. Se ve que segun el orden en que se pongan los AutoresIds, en BBDD se ve que cambia ese orden.
	
	83. Obteniendo Data Relacionada en una Relación Muchos a Muchos
		-Se prueba en PostMan una ruta: 
		https://localhost:7132/api/autores/8 Da error.
		https://localhost:7132/api/libros/ Da error.
		
		-Lo que ocurre es que se deben arreglar los mapeos para que puedan funcionar las relaciones Muchos a Muchos.
		-Primero, se va a trabajar con Autores.
		-Por ejemplo, ha habido error al mapear desde Autor -> AutorConLibrosDTO. Especificamente, con la propiedad Libros.
		AutoMapper.AutoMapperMappingException: Error mapping types.

		Mapping types:
		Autor -> AutorConLibrosDTO
		BibliotecaAPI.Entidades.Autor -> BibliotecaAPI.DTOs.AutorConLibrosDTO

		Type Map configuration:
		Autor -> AutorConLibrosDTO
		BibliotecaAPI.Entidades.Autor -> BibliotecaAPI.DTOs.AutorConLibrosDTO

		Destination Member:
		Libros
		
		-Se va a Autor y se tiene public List<AutorLibro> Libros { get; set; } = [];
		-En AutorConLibrosDTOhay esto public List<LibroDTO> Libros { get; set; } = new List<LibroDTO>();
		-Se va a AutoMapperprofiles y se ve que no hay mapeos de AutorLibro a AlibroDTO.
		-El LibroDTO se tiene Id y Titulo, mientras que en AutorLibro se tiene LibroId y como no se llama asi, hay que decirle a AutoMapper que haga este mapeo y en el caso
		 del Libro de AutorLibro hay que ir al Titulo del Libro.
		 CreateMap<AutorLibro, LibroDTO>()
			.ForMember(dto => dto.Id, config => config.MapFrom(ent => ent.LibroId))
			.ForMember(dto => dto.Titulo, config => config.MapFrom(ent => ent.Libro!.Titulo));
			
		-Ahora, se devuelve esto https://localhost:7132/api/autores/8 pero nos falta el titulo porque es una relacion muchos a muchos y si se va a AutoresController
		 se ve que en el ObtenerPorId.
		 [HttpGet("{id:int}", Name = "ObtenerAutor")] // api/autores/id
			public async Task<ActionResult<AutorConLibrosDTO>> Get(int id)
			{
				var autor = await context.Autores
					.Include(x => x.Libros)
					.FirstOrDefaultAsync(x => x.Id == id);

				if (autor is null)
				{
					return NotFound();
				}

				var autorDTO = mapper.Map<AutorConLibrosDTO>(autor);

				return autorDTO;

			}
			
		-Ahi se va Autores y se obtiene la data de los libros.
		-Ese libros trae AutorLibro que no tiene ningun titulo.
		-Para obtener el titulo, hay que ir a la tabla de libros.
		-Se mete ahi el .ThenInclude
		[HttpGet("{id:int}", Name = "ObtenerAutor")] // api/autores/id
		public async Task<ActionResult<AutorConLibrosDTO>> Get(int id)
		{
			var autor = await context.Autores
				.Include(x => x.Libros)
					.ThenInclude(x => x.Libro)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (autor is null)
			{
				return NotFound();
			}

			var autorDTO = mapper.Map<AutorConLibrosDTO>(autor);

			return autorDTO;

		}
		
		-esto ya funcionaria en Postman: https://localhost:7132/api/autores/8
		
		
		https://localhost:7132/api/libros/6
		Da problemas con System.InvalidCastException: Unable to cast object of type 'BibliotecaAPI.DTOs.LibroDTO' to type 'BibliotecaAPI.DTOs.LibroConAutorDTO'.
		
		-En AutoMapperProfiles se tuvo que comentar esto porque se tenian ahora varios autores.
		//CreateMap<Libro, LibroConAutorDTO>()
		//    .ForMember(dto => dto.AutorNombre, config =>
		//        config.MapFrom(ent => MapearNombreYApellidoAutor(ent.Autor!)));
		
		-Se va hacia LibroConAutorDTO. Se cambia esto:
		public class LibroConAutorDTO: LibroDTO
		{
			public int AutorId { get; set; }
			public required string AutorNombre { get; set; }
		}
		
		-Por esto:
		public class LibroConAutoresDTO: LibroDTO
		{
			public List<AutorDTO> Autores { get; set; } = [];
		}
		
		-Se va a AutoMapperProfiles: CreateMap<Libro, LibroConAutoresDTO>();
		-En Libro, se mapea Id y Titulo y eso ya esta en librosConAutores porque viene de LibroDTO.
		
		-Se tiene que pensar como se va a mapear de AutorLibro a AutorDTO. Se va a mapear del libro que tiene Autores que es List<AutorLibro>.
		-Se va a mapear hacia LibroConAutoresDTO que tiene Autores (List<AutorDTO>)
		-Es lo mismo que se hizo de AutorLibro a LibroDto.
		CreateMap<AutorLibro, AutorDTO>()
			.ForMember(dto => dto.Id, config => config.MapFrom(ent => ent.AutorId))
			.ForMember(dto => dto.NombreCompleto,
				config => config.MapFrom(ent => MapearNombreYApellidoAutor(ent.Autor!)));
				
		-Se necesita obtener la data relacionada del autor.
		-Se va a LibroSController. Donde poner LibroConAutorDTO, se sustituye por LibroConAutoresDTO.
		-Se mete el ThenInclude porque se necesita la data del Autor.
		-Eso de Autores es un AutorLibro que tiene Id de autor pero no el nombre del autor.
		-Ahora esta URL si que funciona:
		https://localhost:7132/api/libros/6
		
	84. Creando un recurso con sus recursos relacionados
		-Que un cliente pueda crear el autor y sus libros de forma simultanea.
		-Haciendo dos cambios, se puede lograr esto.
		-Se añade una propeidad en AutorCreacionDTO.
		Antes
		public class AutorCreacionDTO
		{
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Nombres { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(20, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Apellidos { get; set; }
			public string? identificacion { get; set; }
		}
		
		Despues
		public class AutorCreacionDTO
		{
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(150, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Nombres { get; set; }
			[Required(ErrorMessage = "El campo nombre es requerido")]
			[StringLength(20, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
			[PrimeraLetraMayuscula]
			public required string Apellidos { get; set; }
			public string? identificacion { get; set; }
			public List<LibroCreacionDTO> Libros { get; set; } = [];
		}
		
		-En el post de AutoresController se mapea de AutorCreacionDto a Autor, asi que se mapea de LibroCreacionDTO hacia AutorLibro que se tiene dentro de Autor.
		-Se configura el mapeo en AutoMapperProfiles.
		CreateMap<LibroCreacionDTO, AutorLibro>()
			.ForMember(ent => ent.Libro, 
				config => config.MapFrom(dto => new Libro { Titulo = dto.Titulo }));
		
		-Ahora, hay que verificar que cuando se obtenga un AutorCreacionDTO en el POST de AutoresController, ese mapeo se encargue no soo de tener el Autor, sino tambien
		 los libors y cuando se haga el context.Add se va a agregar el autor con sus libros.
		 Asi el SaveChangesAsync, crea el autor con sus libros.
		 [HttpPost]
			public async Task<ActionResult> Post(AutorCreacionDTO autorCreacionDTO) {
				var autor = mapper.Map<Autor>(autorCreacionDTO);
				context.Add(autor);
				await context.SaveChangesAsync();
				var autorDTO = mapper.Map<AutorDTO>(autor);
				return CreatedAtRoute("ObtenerAutor", new { id = autor.Id }, autorDTO);
			}
			
		-Se va a Postman.
		-Se hace esta peticion.
		POST https://localhost:7132/api/autores/
		{
			"nombres": "Roberto",
			"apellidos": "Martínez",
			"identificacion": 135,
			"libros": [
				{"titulo": "Libro 1 - Roberto"},
				{"titulo": "Libro 2 - Roberto"}
			]
		}
		
		-Este get me devuelve la info creada:
		GET https://localhost:7132/api/autores/9
	
	85. Creando una colección de recursos
		-En ocasiones, vamos a tener la necesidad de permitirle a nuestros clientes no crear un solo recuros, sino varios al mismo tiempo.
		-Se vio esto en el anterior video permitiendo crea run autor con sus libros.
		-Si se quiere crear varios autores con sus respectivos lirbos, pues un listado de autores con sus libros.
		-Se peude considerar una coleccion de recursos como un recuros aparte.
		-Hasta ahora hemos tenido que cada recuros tiene un controladopr, lo que se av a crear es que se crea un controlador para colecciones autores.
		-AddRange sirve para agregar un listado de Entidades.
		-De un post donde se han cread recursos, yo tengo que retornar un 201.
		-Se deja con reutnr Ok() ya que es diferente proque se estan creando varios Autores.
		-Se tiene que devovler una accion que me permita obtener esos dos autores y solo esos dos.
		[HttpPost]
		public async Task<ActionResult> Post(IEnumerable<AutorCreacionDTO> autoresCreacionDTO)
		{
			var autores = mapper.Map<IEnumerable<Autor>>(autoresCreacionDTO);
			context.AddRange(autores);
			await context.SaveChangesAsync();
			return Ok();
		}
		
		-Se va a Postman.
		POST https://localhost:7132/api/autores-coleccion
		[
			{
				"nombres": "María",
				"apellidos": "Rosario",
				"identificacion": "757",
				"libros": [
					{"titulo": "Libro 1 - Maria Rosario"},
					{"titulo": "Libro 2 - Maria Rosario"},
					{"titulo": "Libro 3 - Maria Rosario"} 
				]
			},
			{
				"nombres": "Clemente",
				"apellidos": "Baez",
				"identificacion": "111" 
			},
			{
				"nombres": "Santiago",
				"apellidos": "Ulloa",
				"identificacion": "222",
				"libros": [
					{"titulo": "Libro 1 - Santiago Ulloa"}
				]
			}
		]
		
		-Se comprueba datos en Autores, Libros y AutoresLibros.
	
	86. Obteniendo una colección de recursos
		-Ahora que estamos creando una coleccion de Autores, debemos permitir alos cleintes, obtenr un listado de autores, no uno total sino por ejemplo,
		 quiero los autores, 10, 8 y 9. Es importante porque de nuestro webAPI queremos devovler un 201 a la hroa de crear una coleccion de Autores.
		 y debemos indicar la URL en la que se peuden obtener los Autores recien creados.  Se crea accion GET en AutoresController.
		 Se pasa por parametro un string ids porque van a ir separados por comas: /api/autores/1,2,3...
		 se convierten los strings en enteros.
		 Si el count de ids es diferente es que alguno no fue encontrado.
		
		[HttpGet("{ids}", Name = "ObtenerAutoresPorIds")]
		public async Task<ActionResult<List<AutorConLibrosDTO>>> Get(string ids)
		{
			var idsColeccion = new List<int>();

			foreach (var id in ids.Split(","))
			{
				if (int.TryParse(id, out int idInt))
				{
					idsColeccion.Add(idInt);
				}
			}

			if (!idsColeccion.Any())
			{
				ModelState.AddModelError(nameof(ids), "Ningún Id fue encontrado");
				return ValidationProblem();
			}

			var autores = await context.Autores
							.Include(x => x.Libros)
								.ThenInclude(x => x.Libro)
							.Where(x => idsColeccion.Contains(x.Id))
							.ToListAsync();

			if(autores.Count != idsColeccion.Count)
			{
				return NotFound();
			}

			var autoresDTO = mapper.Map<List<AutorConLibrosDTO>>(autores);
			return autoresDTO;
		}
		
		-Se levanta la app y se mete esa URL: https://localhost:7132/api/autores-coleccion/9,10,12
		-En el HTTPOST se necesita devolver un CreatedAtResult.
		Antes
		[HttpPost]
		public async Task<ActionResult> Post(IEnumerable<AutorCreacionDTO> autoresCreacionDTO)
		{
			var autores = mapper.Map<IEnumerable<Autor>>(autoresCreacionDTO);
			context.AddRange(autores);
			await context.SaveChangesAsync();
			return Ok();
		}
		
		DESPUES
		[HttpPost]
		public async Task<ActionResult> Post(IEnumerable<AutorCreacionDTO> autoresCreacionDTO)
		{
			var autores = mapper.Map<IEnumerable<Autor>>(autoresCreacionDTO);
			context.AddRange(autores);
			await context.SaveChangesAsync();

			var autoresDTO = mapper.Map<IEnumerable<AutorDTO>>(autores);
			var ids = autores.Select(x => x.Id);
			var idsString = string.Join(",", ids);
			return CreatedAtRoute("ObtenerAutoresPorIds", new { ids = idsString }, autoresDTO);
		}
		
		-Se va a postman.
		POST https://localhost:7132/api/autores-coleccion
		[
			{
				"nombres": "María",
				"apellidos": "Rosario 2",
				"identificacion": "757",
				"libros": [
					{"titulo": "Libro 1 - Maria Rosario"},
					{"titulo": "Libro 2 - Maria Rosario"},
					{"titulo": "Libro 3 - Maria Rosario"} 
				]
			},
			{
				"nombres": "Clemente",
				"apellidos": "Baez 2",
				"identificacion": "111" 
			},
			{
				"nombres": "Santiago",
				"apellidos": "Ulloa 2",
				"identificacion": "222",
				"libros": [
					{"titulo": "Libro 1 - Santiago Ulloa"}
				]
			}
		]
		
		-En Headers, Location, se tiene la URL de los autores recien creados.
		GET https://localhost:7132/api/autores-coleccion/13,14,15
		
	87. Resumen
		-En este modulo, se han explorado diferentes escenarios a la hora de manipular recuross en un webAPI.
		-Peude haber endpoints que manipulen recuross individuales o en coleccion.
		-Se ha aprendido acerca de entidades dependientes y de como modelar esa relacion en las rutas de WebAPI.
		-Los DTOS ayudan con separacion de responsavbildiades ya que con estos se peuden ocultar nuestra entidades del mundo extern, consiguiendo mas flexibilidad.
		-La relacion 1-N es que una entidad se relaciona con un conjunto de entidades como un libro puede relacionarse con varios comentarios.
		-Las relaciones muchos a muchos es cuando se tienen dos relaciones 1:N de forma simultanea entre dos entidades. Ejemplo entre libros y auotres. Un libro puede ser escrito por varios autores
		 y varios auotres peuden escribir varios libros.


Sección 6: Configuraciones
	
	88. Introducción
		-Se hablara de Congfigruaciones en ASP.NET CORE. La idea de las configuraciones es que nuestra app va a tener la necesidad de consumir info que se encontrara en poroveedores externos como
		 un archivo de configuracion. Es mala practica estar colocando ciertas configuraciones dentro de nuestra app por temas de seguridad o de que se tendria que recompilar 
		 cada vez que se quieran cambiar ciertas configuraciones como servidor donde sen encuentra la BBDD.
	
	89. Introducción a las configuraciones
		-Cuando hablamos de configuraciones nos referimos a datois que ayudan a nuestra app a funcionar de forma correcta.
		-Estos datos tienden a variar de un ambiente a otro.
		-O, al menos, son datos que no tienen sentido que formen parte del codigo fuente.
		-Un ejemplo de estos datos es la cadena de conexion o ConnectionString que indica la info del servidor de BBDD.
		-No es algo que se quiera tener en el codigo fuente pues se tendria que editar el codigo fuente por ambiente.
		-Es mejor tener esta y otras informaciones en fuentes externas.
		-Para comunicarnos con estas fuentes externas se usan los provvedores de configuracion,.
		-Los proveedores de configuracion permten conectarnos con difernetes tipos de fuenets externas de nuestra app, ya queramos comunciarnos con ficheros json, variables en memoria, argumentos en lienas de comandos...
		-Se deben usar proveedores de confguracion para poder consumir esas fuentes externas de datos.
		-La idea es que el framework de .NET nos permite tener un servicio a traves del cual podemos acceder a estos datos de forma directa 
		 y uniforme. Este servicio es el IConfiguration con el que se puede entrar a los datos de configuracion de nuestra app.
		-Se peude ver que se tienen varias opciones de cinfiguracion para controlar el ciclo de vida de las configuraciones.
		-Se peude configurar que si unos datos son actualziados, se ejecute una funcion de C#, o que se quiere que unos datos se mantenagan staticos durante el tiempo de vida de la app.
		
	90. Ejemplo de IConfiguration
		-Una ap de asp.net cre viene preparada para trabajar con difernetes fuentes de configuracion. De hecho ya hemos usado cofiguraciones ne nuestra app.
		 cuando colocamos el connectionString en el appsettings.development.json.
		-ConnectionStrings representa una seccion y dentro de ella esta la propeidad DefaultConnection.
		-Un proveedor de configuracion es una coleccion de llaves y valores. Para acceder a los valores a partir de las llaves, se peude usar el servicio IConfiguration.
		-Se crea Controlador de prueba.
		-Se va a usar el sistema JSON de dependencias para poder obtener una instancia del servicio IConfiguration.
		-IConfiguration permite obtener el valor a partir de cualquier proveedor de configuracion.
		-Se evra mas adelante como se interactua con varios proveedores al mismo tiempo.
		[ApiController]
		[Route("api/configuraciones")]
		public class ConfiguracionesController : Controller
		{
			private readonly IConfiguration configuration;

			public ConfiguracionesController(IConfiguration configuration)
			{
				this.configuration = configuration;
			}
			[HttpGet]
			public ActionResult<string> Get()
			{
				var opcion1 = configuration["apellido"];
				var opcion2 = configuration.GetValue<string>("apellido");
				return opcion2;
			}
		}
		
		-Se levanta app, va a postman y se prueba el endpoint. https://localhost:7132/api/configuraciones/
		
		-Se puede tener un simle valor o una seccion que e sun cojunto de llaves y valores...
		-Las secciones permiten agrupar ciertas llaves en una misma estructura.
		-Por ejemplo en ConnectionStrings se peuden colocar ConnectionStrings diferneets de mi app.
		-Se va a intentar obtener el valor del connectionString usando la sintaxis aprendida.
		
		-Añadir esto para indicar que peude ser nulo  y quitar advertencia: var opcion2 = configuration.GetValue<string>("apellidos")!;
		-Se hace porque puede ser que el valor no exista...
		-Se va a intentar acceder al valor de ConnectionStrings.
		[HttpGet("secciones")]
		public ActionResult<string> GetSeccion()
		{
			var opcion1 = configuration["ConnectionStrings:DefaultConnection"];
			var opcion2 = configuration.GetValue<string>("ConnectionStrings:DefaultConnection");
			var seccion = configuration.GetSection("ConnectionStrings");
			var opcion3 = seccion["DefaultConnection"];
			return opcion3!;
		}
		
		-POSTMAN: EJEMPLO => https://localhost:7132/api/configuraciones/secciones
		
	91. Secciones - GetChildren
		-Esto de als secciones permite tener secciones de codigo las cuales pueden incluso tener 
		 las mismas llaves pero con difernetes valores.
		-Se añade esto:
		"seccion_1": {
		  "nombre": "Felipe",
		  "edad": 999
		},
		"seccion_2": {
		  "nombre": "Claudia",
		  "edad": 111
		},
		
		-Se quiere acceder a estos valores desde el controlador.
		-Se quiere tener acceso a la seccion completa pero se va a hacer desde um campo de la clase.
		private readonly IConfiguration configuration;
		private readonly IConfigurationSection seccion_01;
		private readonly IConfigurationSection seccion_02;

		public ConfiguracionesController(IConfiguration configuration)
		{
			this.configuration = configuration;
			seccion_01 = configuration.GetSection("seccion_1");
			seccion_02 = configuration.GetSection("seccion_2");
		}
		
		-Se mete la peticion HttpGET
		[HttpGet("seccion_01")]
		public ActionResult GetSeccion01()
		{
			var nombre = seccion_01.GetValue<string>("nombre");
			var edad = seccion_01.GetValue<string>("edad");

			return Ok(new { nombre, edad });
		}

		[HttpGet("seccion_02")]
		public ActionResult GetSeccion02()
		{
			var nombre = seccion_02.GetValue<string>("nombre");
			var edad = seccion_02.GetValue<string>("edad");

			return Ok(new { nombre, edad });
		}
		
		-Se accede desde PostMan.
		https://localhost:7132/api/configuraciones/seccion_01
		https://localhost:7132/api/configuraciones/seccion_02
		
		-Se coloca en una variable aparte para que asi no tengamos accidentalmente acceso a otros valores que no quisieramos acceder.
		-Se peuden obtener todos lo valores de un proveedor de configuracion.
		-Peude ser util para debuggear.
		-Se mete una peticion httpget.
		[HttpGet("obtenertodos")]
		public ActionResult GetObtenerTodos()
		{
			var hijos = seccion_02.GetChildren().Select(x => $"{x.Key}: {x.Value}");
			return Ok(new { hijos });
		}
		
		-Se mete Postman: https://localhost:7132/api/configuraciones/obtenertodos
		
	92. Usando el AppSettings
		-Se va a habalr de los difernetes proveedores de configuracion. Basicamente, cuando se habla de proveedores de configuracion se refiere a los difernetes lugares
		 donde se peuden configurar datos como estos: cjtos de llaves y valroes.
		-Se hablara de appsettings.json.
		-Cuandos e creo el proyecto, se creo el appsettings.json y el appsettings.development.json.
		-appsettings.json es una configuracion base para prod, mientras que el development.json es una configuracion especifica para DESA.
		-En el development.json se puede tener un ConnectionString que apunte a mi bbdd de dev y en el appsettings.json un connectionString que apunte a BBDD de prod.
		-Cuando este correindo la webapi, si esta en modo dev, se usa el appsettings de dev, sino prod si estamos en prod.
		-El ver si estamos en modo desarrollo o modo dev de manera local es usando el launchSettings.json, usando una variable de ambiente.
		
		-Se va a ir appsetting.development.json y se va a meter una llave: "quien_soy":  "appsettings.Development.json (desarrollo)",
		-Idem en prod: "quien_soy": "appsettings.json (producción)",
		-Se va a ConfigurationController y se mete nueva peticion HTTP,.
		[HttpGet("proveedores")]
		public ActionResult GetProveedor()
		{
			var valor = configuration.GetValue<string>("quien_soy");
			return Ok(new { valor });
		}
		
		-Se va a postman.
		https://localhost:7132/api/configuraciones/proveedores
		
		-Si se cambia el valor, se configura una opcion en los proveedores de config como appsettings.development.json una funcionalidad que se llama ReloadOnChange,
		 para que cuando sean editados, automaticamente ASP.NET Core se peuda tomar ese valor editado.
		-Soi se comenta el valor en appsettings.development.json y ejecutamos la peticion de postman saca el valor de prod.
		-En dev primero se va a buscar al fichero de appsettings.development.json. Sino se encuentra ahi, se va a buscar a appsettings.json.
		-En dev se da preferencia al appsettings especifico del ambiete en el que estoy.
		
		-Se hace el cambio en el https del launchsettings.json para que se apunte a PROD.
		"https": {
		  "commandName": "Project",
		  "dotnetRunMessages": true,
		  "launchBrowser": true,
		  "applicationUrl": "https://localhost:7132;http://localhost:5065",
		  "environmentVariables": {
			"ASPNETCORE_ENVIRONMENT": "Production"
		  }
		}
		
		-Si se va a postman y se ejecuta el https, se ve que ya estamos modo prod y se va a bucar las config a appsettings.json.
	
	93. Variables de ambiente
		-Son valores que se configuran a nivel del ambiente como a nivel del SO.
		-No estan en ningunaa parte del code de la app.
		-Son utiles para tener valores sensibles como el tema de acceder a una cadena de conexion de PROD de modo que nadie pueda acceder a esa cadena de conexion.
		-Incluso existen servicios de solo escritura en los que ni tan siquiera la persona que creo la variable de ambiente puede ver su valor. Es util por temas de seguridad.
		-Se pueden configurar variables de ambiente en Windows, Linux, MACOS....
		-Se sigue trabajando con la vble quien_soy.
		-Se usa el launcSttings.json para definir una vble de ambiente.
		-Se mete en environmentvariables que es una seccion con llave sy valores.
		"environmentVariables": {
		  "ASPNETCORE_ENVIRONMENT": "Production",
		  "quien_soy": "una variable de ambiente"
		}
		
		-Se va a postman y se ejecuta: https://localhost:7132/api/configuraciones/proveedores
		-Se ve que saca la vble de ambiente. Porque se le da prioridad? Se ve en el siguiente video.
	
	94. Orden de declaración de proveedores de configuración
		-Se habia visto que al intentar sacar el valor de quien_soy se obtuvo el valor configurado en la vble de ambiente, esto a pesar de que esta configurado en 
		 diferentes proveedores de configuracion como appsettings.development.json y appsettings.json.
		-La razon es que existe un sistema de preferencia de los proveedores de configuracion.
		-Los proveedores que se configuran primero, tienen menor preferencia.
		-Es decir, los que se configuran al final tienen mas preferencia y sobreescriben a los anteriores.
		-Donde se ve el orden? Se va a Program.cs y ahi se ve el metodo CreateBUilder donde por defecto se configura la app de .NET.
		-Entre esas configuracioens está la configuración de preferencia de los proevedores de configuracion.
		-Se puede abrir source.dot.net y se ve el codigo fuente en HostingHostBuilderExtensions.cs y dentro de el, en ApplyDeafultAppConfiguration.
		-Lo primero que se configura es el appsetting.json, es el que menos preferencia tiene. Se ve que hay una parte que dice appsettings.{env.EnvironmentName}.json y eso
		 permite crear un appsettings por ambiente....
		-El development tiene mayor preferencia que el de prod porque se configrua despues. Si se esta en desarrollo se configrua otro proveedor
		 que es el UserSecrets.
		-Permite tener un archivo json que es privado de nuestra maquina, solo se encuentra ahi.
		-No se sube a GitHub etc.
		-Luego se tiene la configuracion de las variables de ambiente y tienen preferencia y sobreescriben a las variables de otros proveedores de configuracion.
		-Luego esta el AddCommandLineConfig porque la linea de comandso es otro proveedor de configruacion. Este peude sobrrescribir las vbles de ambiente. 
		-Hay otros proveedores de configuracion y cuando se configuran en Program posterior a CreateBuilder, va a sobreescribir a lo que tengamos a CreateBuilder.
		-No se sobreescribe el proevedor en si, sino lo que haya en las llaves.
		-Se recuerda que sino se encuentra una variable en un proveedor, lo va a buscar al siguiente de menos preferencia.
	
	95. User Secrets
		-Es otro proveedor de configuracion. Es para tener configuraciones personales que no se quiere que andie vea.
		-Es como appsettings pero esta garantrizado a no estar presente en nuestra app.
		-De esta manera, no corres riesgo de revelar datos sensibles a terceros.
		-En Visual Studio, boton derecho en el proyecto > "Administrar secretors de usuario" y crea un fichero json.
		-Hay una seccion en la que se pueden colcoar llaves y valores.
		-En el caso de dotnet-cli pueden usar el comando dotnet user-secrets init.
		-Se puede ver en la configuracion del proyecto el ID del UserSecrets que lo identifica de forma unica.
		-Donde esta ese fichero?? Se pulsa Windows + R y se mete: %APPDATA%\Microsoft\UserSecrets\
		-Se tienen muchas carpetas con muchos IDs. Se busca el ultimo por fecha y se ve que tengo el que he acabado de crear.
		-Ficheroe sta lejos del proyecto y es dificl que lo subamos sin querer a GitHub para darle seguimiento a nuestro proyecto usando Git.
		-Se puede evitar asi por accidnete revelar secretos nuestros.
		-Aqui claro se puede meter un connectionString con usuario y password o credenciales para conectar a WebAPI por el que pago.
		-Esto es para tener claves secretas sin correr peligro de revelarselo a otros.
		-Se mete quien_soy: 
		{
		  "quien_soy":  "secrets.json";
		}
		
		-Se imprime antes la vble de ambiente por el tema del orden de preferencia....
		
	96. Linea de Comandos
		-Sobreescribe el resto de proveedores porque se coloca al final. La idea es que se pueda ejecutar la app desde linea de comandos
		 y desde aqui se peuden pasarle argumentos, los cuales pueden ser transformados en valores de un proveedor de configuracion
		-Se abre el proyecto en una terminal de powershell.
		-Se pone dotnet run -- "quien_soy=linea de comandos".
		-Es algo que se sule usar en herramientas automaticas como por ejemplo si quieres tener archivo de Docker, un yaml, githubactions etc...
		-Haces dotnet run y le puedes pasar cualquier valor que sobreescribe cualquier proevedor de configuracion como appsettings.json
		-Se coge la URL que se levanta y se va a Postman:  http://localhost:5065/api/configuraciones/proveedores
	
	97. Diccionario en memoria como proveedor
		-Este sirve cuando tenemos valores que queremos centralziar en una parte del code de nuestra app.
		-Se va hacia la clase Program y se quiere poner un diccionario.
		-Se le llama diccionarioConfiguraciones.
		-Se mete en Program.cs.
		-Se agrega un nuevo proveedor de configuracion.
		-El orden en que se agregan los proveedores de configuracion es importante.
		-El proveedor AddInMemoryCollection tendra preferencia sobre CreateBuilder porque se ejecuta despues.
		var diccionarioConfiguraciones = new Dictionary<string, string>
		{
			{ "quien_soy", "un diccionario en memoria" }
		};

		builder.Configuration.AddInMemoryCollection(diccionarioConfiguraciones!);
		
		-Se ve que si se va a Postman y se vuelve a ejecutar y se copia la URL que se levanta, se ve que 
		 se enseña lo que se ha configurado en el diccionario en memoria.
		
		-Se ejecuta la app y se le vuelve a pasar por comando: dotnet run -- "quien_soy=linea de comandos"
		-Esto es para configurar como del proveedor de configuracion de linea de comandos  este valor.
		-Se ve que a pesar de que este es uno de los de mayor preferencia, ya que el de en memoria fue configurado posterior a la configuracion 
		 del proveedor del codigo fuente el de en mmeoria tiene preferencia.
		-Si por alguna razon se quiere tenr valores centralziados, se peude llevar a una clase y eso tiene preferencia sobre cualquier valor que se coloque en cualquier proveedor de configuraciones
		 de todos los vistos.
		 
	98. Patron con Opciones
		-Cada vez que se queire obtener l valor d eun proveedor de configuracion, estamos usando el IConfiguration.
		-En ConfiguracionesController se esta inyectando el IConfiguration y de ahi obtienes el valor deseado del proveedor de configuracion.
		-Exosten otras opciones. Quizas no guste ese string magico que se pone como "quien_soy".
		-Igual quizas ahora no se esta validando que exista ese valor.
		-Se quiere que se valide al momento de ejecutar la app por si escribes otra variable etc.
		-Se trabajara con el patron de Opciones. Se trata de tener un mecanismo lo suficentemente tipado
		 para obtener los valores de un proveedor de configuracion.
		-En ConfiguracionesController quizas en lugar de tener que hardcodear el tema de seccion_1, nombre, edad....
		 Igual se quiere algo fuertemente tipado para no escribir mal.
		-Se crea clase cuyas propiedadess erán nombre y edad.
		-Se crea una clase. Section no sera una propiedad, sino un campo de la clase.
		-Se accede a nombre y edad por medio de la clase, en vez de por medio de IConfiguration.
		public class PersonaOpciones
		{
			public const string Seccion = "seccion_1";

			public required string Nombre { get; set; }
			public int Edad { get; set; }
		}
		
		-Se va a la clase Program, area de Servicios, 
		-Se coloca la seccion como campo de clase para no hardcodear nada. Asi obtiene valores de la seccion para mapearlos hacia PersonasOpcioens.
		builder.Services.AddOptions<PersonaOpciones>()
			.Bind(builder.Configuration.GetSection(PersonaOpciones.Seccion));
			
		-Se cambia ConfiguracionesController.
		Antes
		[ApiController]
		[Route("api/configuraciones")]
		public class ConfiguracionesController : Controller
		{
			private readonly IConfiguration configuration;
			private readonly IConfigurationSection seccion_01;
			private readonly IConfigurationSection seccion_02;

			public ConfiguracionesController(IConfiguration configuration)
			{
				this.configuration = configuration;
				seccion_01 = configuration.GetSection("seccion_1");
				seccion_02 = configuration.GetSection("seccion_2");
			}

			[HttpGet("proveedores")]
			public ActionResult GetProveedor()
			{
				var valor = configuration.GetValue<string>("quien_soy");
				return Ok(new { valor });
			}

			[HttpGet("obtenertodos")]
			public ActionResult GetObtenerTodos()
			{
				var hijos = seccion_02.GetChildren().Select(x => $"{x.Key}: {x.Value}");
				return Ok(new { hijos });
			}

			[HttpGet("seccion_01")]
			public ActionResult GetSeccion01()
			{
				var nombre = seccion_01.GetValue<string>("nombre");
				var edad = seccion_01.GetValue<string>("edad");

				return Ok(new { nombre, edad });
			}

			[HttpGet("seccion_02")]
			public ActionResult GetSeccion02()
			{
				var nombre = seccion_02.GetValue<string>("nombre");
				var edad = seccion_02.GetValue<string>("edad");

				return Ok(new { nombre, edad });
			}

			[HttpGet]
			public ActionResult<string> Get()
			{
				var opcion1 = configuration["apellidos"];
				var opcion2 = configuration.GetValue<string>("apellidos")!;
				return opcion2;
			}

			[HttpGet("secciones")]
			public ActionResult<string> GetSeccion()
			{
				var opcion1 = configuration["ConnectionStrings:DefaultConnection"];
				var opcion2 = configuration.GetValue<string>("ConnectionStrings:DefaultConnection");
				var seccion = configuration.GetSection("ConnectionStrings");
				var opcion3 = seccion["DefaultConnection"];
				return opcion3!;
			}
		}
		
		Despues
		[ApiController]
		[Route("api/configuraciones")]
		public class ConfiguracionesController : Controller
		{
			private readonly IConfiguration configuration;    
			private readonly IConfigurationSection seccion_01;
			private readonly IConfigurationSection seccion_02;
			private readonly PersonaOpciones _opcionesPersona;

			public ConfiguracionesController(IConfiguration configuration, IOptions<PersonaOpciones> opcionesPersona)
			{
				this.configuration = configuration;
				seccion_01 = configuration.GetSection("seccion_1");
				seccion_02 = configuration.GetSection("seccion_2");
				_opcionesPersona = opcionesPersona.Value;
			}

			[HttpGet("seccion_1_opciones")]
			public ActionResult GetSeccion1Opciones()
			{
				return Ok(_opcionesPersona);
			}


			[HttpGet("proveedores")]
			public ActionResult GetProveedor()
			{
				var valor = configuration.GetValue<string>("quien_soy");
				return Ok(new { valor });
			}

			[HttpGet("obtenertodos")]
			public ActionResult GetObtenerTodos()
			{
				var hijos = seccion_02.GetChildren().Select(x => $"{x.Key}: {x.Value}");
				return Ok(new { hijos });
			}

			[HttpGet("seccion_01")]
			public ActionResult GetSeccion01()
			{
				var nombre = seccion_01.GetValue<string>("nombre");
				var edad = seccion_01.GetValue<string>("edad");

				return Ok(new { nombre, edad });
			}

			[HttpGet("seccion_02")]
			public ActionResult GetSeccion02()
			{
				var nombre = seccion_02.GetValue<string>("nombre");
				var edad = seccion_02.GetValue<string>("edad");

				return Ok(new { nombre, edad });
			}

			[HttpGet]
			public ActionResult<string> Get()
			{
				var opcion1 = configuration["apellidos"];
				var opcion2 = configuration.GetValue<string>("apellidos")!;
				return opcion2;
			}

			[HttpGet("secciones")]
			public ActionResult<string> GetSeccion()
			{
				var opcion1 = configuration["ConnectionStrings:DefaultConnection"];
				var opcion2 = configuration.GetValue<string>("ConnectionStrings:DefaultConnection");
				var seccion = configuration.GetSection("ConnectionStrings");
				var opcion3 = seccion["DefaultConnection"];
				return opcion3!;
			}
		}
	
		-Se puede validar que nombre y edad se esten llenando.
		public class PersonaOpciones
		{
			public const string Seccion = "seccion_1";

			[Required]
			public required string Nombre { get; set; }
			[Required]
			public int Edad { get; set; }
		}
		
		-Aqui tambien hay que añadir las validaciones en program.cs
		builder.Services.AddOptions<PersonaOpciones>()
		.Bind(builder.Configuration.GetSection(PersonaOpciones.Seccion))
		.ValidateDataAnnotations()
		.ValidateOnStart();
		
		-Si meto nombre2 en el appsettings, pues da error.
		-Cuando se usaba el IConfiguration, si se cambiaba una key o un value del appsettings, se hacia en tiemo de ejecucion. Con IOptions no. IOPtions toma esa data y guarda en cache.
		-Cada vez que se ejecute, hay que usar IOptionsSnapshot.
	
	99. Utilizando IOptionsSnapshot
		-Cada vez que se reciba una peticion HTTP a nuestro webAPI, van a ser llenadas los vaores de las opcioens.
		-Si se quiere que se cuando se actualice el appsettings development en tiempo de ejecucion y se develva valor actualziado hay que usar IOptionsSnapshot.
		-Cada vez que se realzia una peticion HTTP, se van a refrescar los valores de personasOpciones ye s algo mas lento pero no mas por esto vaya.
		-Para app en la que velocidad sea fundamental etc pues es importante.
		-Esto puede ser opcion no muys estartegica.
		-Se cambia esto en ConfiguracionesCOntroller:
		public ConfiguracionesController(IConfiguration configuration, IOptions<PersonaOpciones> opcionesPersona)
		
		public ConfiguracionesController(IConfiguration configuration, IOptionsSnapshot<PersonaOpciones> opcionesPersona)
		
		-IOptionsSnapshot funciona bien para controladores y otro tipo de servicios que son de tipo Scope porque el IOptionSnapshot se actualzia con cada peticion.
		-Funciona bien con controladores por ser de tipo Scope.
		-IOptions es bueno para ConnectionString.
		
	100. Utilizando IOptionsMonitor
		-permite ejecutar una funcion de C# al momento de cambio de los valores en un proveedor e configuracion.
		-Se usa en servicio Singleton.
		-El patron es que tenemos unos datos que queremos suar de forma frecuente como tarifa de un servicio pero por tema de velocidad no queremos colcoarlos en una bbdd esos valores y los colocamos
		 en un lugar de rapido acceso como el appsettings.json.
		-Se va a guardar la tarifa en un camppo de la clase y cuando el proveedor de configuracion se aactualizado 
		 pues se actualziara el campo de la clase
		-Se ava  Appsetiings y se meten tarifas.
		"tarifas": {
		  "dia": 10,
		  "noche":  12
		},
		
		-Se va a crear la clase en la cual, vamos a colcoar estos datos y nos asguramos de que dia y noche esten presentes. Es parecido a PersonasOpciones.
		-Se le llama a la clase TarifasOpciones.
		public class TarifaOpciones
		{
			public const string Seccion = "tarifas";

			[Required]
			public decimal Dia { get; set; }
			[Required]
			public decimal Noche { get; set; }
		}
		
		-Se añade el servicio en Program.cs.
		
		
		-Como se quiere usar IOptionsMonitor se necesita usar un servicio Singleton. Es un servicio que se reinicia en el momento de rieniciar la app.
		-Se añade clase que se llame Pagosprocesamiento Se añade OptionsMonitor.OnChange que se ejecuta cuando se vaya a buscar la variable a appsettings.json.
		public class ProcesamientoPago
		{
			private TarifaOpciones _tarifaOpciones;

			public ProcesamientoPago(IOptionsMonitor<TarifaOpciones> optionsMonitor)
			{
				_tarifaOpciones = optionsMonitor.CurrentValue;

				optionsMonitor.OnChange(nuevaTarifa =>
				{
					Console.WriteLine("tarifa actualizada");
					_tarifaOpciones = nuevaTarifa;
				});
			}

			public void ProcesarPago()
			{
				//Aqui usamos las tarifas
			}

			public TarifaOpciones ObtenerTarifas()
			{
				return _tarifaOpciones;
			}
		}
		
		-PagosProcesamiento lo tengo que configruar como Singleton.
		builder.Services.AddOptions<TarifaOpciones>()
		.Bind(builder.Configuration.GetSection(TarifaOpciones.Seccion))
		.ValidateDataAnnotations()
		.ValidateOnStart();
		
		builder.Services.AddSingleton<ProcesamientoPago>();
		
		-Ahora se puede utilizar este Singleton por ejemplo desde nuestro Controlador.
		-En la vida real, posiblemente ese servicio de procesamiento de pago, sería utilizado desde un job que sea recurrente, es decir una pieza de codigo que sea recurrente.
		-Se inyecta Pagosprocesamiento
		Antes
		private readonly IConfiguration configuration;    
		private readonly IConfigurationSection seccion_01;
		private readonly IConfigurationSection seccion_02;
		private readonly PersonaOpciones _opcionesPersona;

		public ConfiguracionesController(IConfiguration configuration, IOptionsSnapshot<PersonaOpciones> opcionesPersona)
		{
			this.configuration = configuration;
			seccion_01 = configuration.GetSection("seccion_1");
			seccion_02 = configuration.GetSection("seccion_2");
			_opcionesPersona = opcionesPersona.Value;
		}
		
		Despues
		private readonly IConfiguration configuration;
		private readonly ProcesamientoPago procesamientoPagos;
		private readonly IConfigurationSection seccion_01;
		private readonly IConfigurationSection seccion_02;
		private readonly PersonaOpciones _opcionesPersona;

		public ConfiguracionesController(IConfiguration configuration, IOptionsSnapshot<PersonaOpciones> opcionesPersona, ProcesamientoPago procesamientoPagos)
		{
			this.configuration = configuration;
			this.procesamientoPagos = procesamientoPagos;
			seccion_01 = configuration.GetSection("seccion_1");
			seccion_02 = configuration.GetSection("seccion_2");
			_opcionesPersona = opcionesPersona.Value;
		}
		
		-Se añade peticion HTTPGET.
		[HttpGet("options-monitor")]
		public ActionResult GetTarifas()
		{
			return Ok(procesamientoPagos.ObtenerTarifas());
		}
		
		-Se ejecuta la peticion en Postman: http://localhost:5065/api/configuraciones/options-monitor
		-Si se cambia el valor de la tarifa sin cerrar la ejecucion del programa, podra "tarifa actualizada" en la consola.
		-Sale dos veces y corre por ciertos eventos que ocurren al momento de salvar el fichero. Lo importante es ver que se ejecuta la funcion de C#.
		-Somos capaces de ejecutar una funcion de C# al momento de actualizar un valor de un proveedor de configuracion y somos capaces de usar una opcion interesante cuando tenemos servicio Singleton.
	
	101. Consideraciones de seguridad
		-No se debe eprmitir que algunas informaciones vivan en un archivo el cual es accesible a traves de un miembro de mi equipo.
		-El appsettings. jjson es accesible por cualquier eprsona que tenga acceso a codigos fuentes del proyecto.
		-pero sabemos que datos confidenciales como crdenciales, deben guardarse en algun proveedor de configuracion pero es importante que ese fichero no se esté guardando en GitHub o
		 en cualquier repo de control de versioens, ni tampoco que sea un fichero que cualquiera puede acceder.
		 Es importanter mantener ciertas configuraciones fuera del alcance de eprsonas no autorizadas a visualziar dichas configruacioens.
		 El ejemplo es el ConnectionString. la info de bbdd de prod, puede conteenr info sensible acerca de como autenticarse en el servidor de prod de bbdd
		 Es algo que no todos deben conocer.
		 para el caso de prod se suelen suar variables de ambiente para proteger configuraciones.
		 Cuando se publique la app en prod, se pone el connectionString de la bbdd de prod en una vble de ambiente a nivel de Azure. Asi ni siquiera persona
		 que tenga acceso tenga al codigo fuente, tendra acceso a ese connectionString.
		 Existen ifnormacioens que peuden no ser de prod que se quiere proteger.
		 Por ejemplo, un sistema que manda correos y acad desarrolador tiene user y password, es info sensible que no debe ir en el appsettings.json.
		 No es necesario usar vble de ambiente.
		 En este caso, es mejor usar los User Secrets. Asi, cada eprsona puede usar sus credenciales sin tener que exponerlas a mundo externo.
		 Otras informacioens como configuracion del logger y asi, se puede poner en appsettings.json sin peligro.
	
	102. Resumen
		-Se ha aprendido a usar configruaciones en ASP.NET Core.
		-Configuraciones son datos que necesitamos para que la app funcione.
		-Con IConfiguration se pueden obtener lso datos de diferentes proveedores de configuracion.
		-Los proveedores de configuracion son las fuentes de configuracion de nuestra aplicacion: ficheros json, bvariables de ambiente, secretos de usuario, lineas de comando o un simple diccionario en memoria.
		-Con el patron de opciones podemos usar mecanismos fuertemente tipados para acceder a nuestros datos de configuracion.
		
		
Seccion 7: Seguridad
	103. Introduccion a Modulo 7
		-Casi cualquier app no trivial tiene que lidiar con temas de seguridad (autenticacion, encriptacion, cors....).
	
	104. Limpiando la app
		-El borra todo lo relacionado con configuraciones. Lo dejamos porque si qie nos sirve de ejemplo...
	
	105. Autenticacion y Autorizacion
		Autenticacion
		-Hasta ahora todas las rutas de nuestro webapi han estado al aire libre donde cualquiera puede acceder a estas.
		-Esto no es bueno porque existen acciones, las cuales queremos que solo ciertos usuarios puedan acceder.
		-Para eso podemos usar autenticacion y autorizacion.
		-Autenticacion trata de que un usuario muestre credenciales para verificar su identidad.
		-Estas credenciales suelen ser user y password. 
		-En ASP.NEt Core es facil para implemetar un sistema de usuarios, usando Identity.
		-Cone sto se tiene las tablas de SQLServer necesarias para nuestro sistema de usuarios, ademas de meotdoos auxiliares para manejar
		 diferenets escensarios.
		-Una vez autenticado, webapi devuelve un JsonWebToken (JWT) es un string seguro que cntiene info confiable del user.. Es seguro porque esta firmado con llave secreta 
		 y peudes estar seguro de laveracidad de lo que contiene el JWT.
		-JWT contiene claims que son iformaciones acerca del usuario como su nombre, email, etc.
		-Cuando se quieren usar endpoints protegidos en webapi, se debe enviar JWT a traves de una cabeecra de la peticion HTTP y asi podra valdiarse como un usuario autenticado.
		-Untoken se divide en tres partes: cabecera, datos y firma.
		-La separacion de JWT va con puntos. Hay tres partes: cabecera, data y firma.
		-En cabecera aprece el algoritmo usado y tipo que es JWT.
		-La firma sirve para verificar si los datos del token no han sido alterados, para eso hay que ingresar la llave secreta con la que fue firmado el JWT.
		
		Autorizacion
		-Es lo que un usuario tiene permitido hacer
		-No basta con que solo se autentique. No es lo mismo un cliente de empresa que un empleado.
		-El empleado tendrá permsios extra.
		-Quizas solo usuarios especiales puedan borrar recursos.
		-A nivel de WebAPI se usará un código en el que se indicará que sólo un usuario admin pueda realziar esa operacion.
	
	106. Configurando Identity
		-Asi se tiene un conjunto de librerias que lo van a hacer mas facil para crear un sistema de usuarios. Se va a permitir a  
		 un conjunto de personas loggearse y registrarse. S epermitira renovar webToken, usar claims para crear usuarios que son admin a diferencia de otros 
		 que no son para dar eprmsisos especiales a admn. Es facil con Identity.
		
		-Se hace click derecho en proyecto, administracion de nugegts. Seinstala 
		Microsoft.AspNetCore.Identity.EntityFrameworkCore: permite usar identity con EntityFramework Core.
		Microsoft.AspNetCore.Authentication.JwtBearer: Para poder utilizar ese JWT que contiene claims del usuario.
		
		-Se a a ir a Datos > ApllicationDbContext. Para poder usar Identity con EF Core, en vez de hereadar de DbContexto, vaos a heredar de IdentityDbContext.
		 Esto no va apermitir de manera sencilla configurar tablas de un sistema de usuarios bien sencillo que funciona por defecto con Identity
		 Se va a tener tabalas de usuarios, claims...
		
		-Se cambia, esto
		public class ApplicationDbContext : DbContext
		
		-Por esto
		public class ApplicationDbContext : IdentityDbContext
		
		-Si se usa OnModelCreating, hay que asegurarse de tener esto porque sino no se puede crear la migracion: base.OnModelCreating(modelBuilder);
		-Se añade un amigracion: Add-Migration SistemaDeUsuarios.
		-Se ve que hay tabla de roles como vendedor, administrador...No se usa roles porque usaremos Claims.
		-Roles es como  Claims pero especificamente diseñado para categorizar usduarios.
		-Se tiene tabla usuarios: AspNetusers
		-Esta tabla de RoleClaims. A cada claim se peuden asignar roles especiales recordando que los claims es info acerca de algo.
		-Se pueden asignar claims a un rol para que todo usuario que tenga ese rol tenga dichos claims.
		-AspNetUserClaims para asignar claims especificos a un usuario.
		-AspNetuserLogins para autentificacion con proveedores de terceros como por ejemplo si se quiere
		 que nuestros usuarios puedan autenticar con cuenta de Google.
		-AspNetuserRoles que es una tabla intermedia que permite que haya relacion muchos a muchos entre usuarios y roles
		 Un usuario puede tener varios roles y un rol se puede asignar a muchos usuarios.
		-AspNetUserTokens que permite guardar tokens si se necesita.
		-Se hace Update-Database y se arregla 
		The Entity Framework tools version '9.0.1' is older than that of the runtime '9.0.3'. Update the tools for the latest features and bug fixes. See https://aka.ms/AAc1fbw for more information.
		
		-Se le da a nugget packages desde el administrador y se pincha sobre ellos y actualizar. Se va a la pestaña Updates y se actualiza.
		-Se va a program para configurar en el area de servicio, Identity. IdentityUser es clase que representa a un usuario.Se pasa
		 ApplicationDbContext para que servicios de Identity usen applicationDbContext y se conecten con las tablas de usuarios.
		 Luego, se configura un servicio que se llama Usermanager que es el manejador de usuarios que permite registrar usuarios.
		 Se añade idem SignInManager que permite autenticar usuarios.
		 Idem con AddHttpContextAccessor que permite acceder al conexto HTTP de cualqueir clase.
		 Se configura tambien la autenticacion. Lo de bearer es como el que tiene el token o carga algo. La persona que tenga el JWT demuestra ser el user en cuestion.
		 opciones.MapInboundClaims = false; es para que ASPN.NET Core no me cambie el numero de un calim por otro de forma automatica.
		 Igual tienes un claim que se llama Email y te cambian ese valor por otro.
		 Eso es confuso. Si se llama email prefiero que se quede como email.
		 Se añade la configuracion de un token. En concreto, que es lo que se va a tener en cuenta a la hora de valdiar un token porque no todo token es valido.
		 No se valida ni emisor ni audiencia del token. Si se valida el tiempo de expiracion del token y la llave secreta porque permite firmar token para que si alguien altera y no tiene llave secreta,
		 me lo mande y lo pueda rechazar. Tambien se configura la llave secreta.
		 Llave es clave y se va a extraer de un proveedor de configuracion.
		 Esto es para que asi en produccion yo peuda tener una llave que se va a encontrar con una variable de ambiente en mi servidor de PROD para que no todo el mundo tenga acceso a esta llave secreta.
		 Es con la que se firman los JWT.
		 ClockSkew es para que no se tenga problemas de discrepancia de tiempo cuando validemos la expiracion del token.
		 builder.Services.AddDbContext<ApplicationDbContext>(opciones => opciones.UseSqlServer("name=DefaultConnection"));

		builder.Services.AddIdentityCore<IdentityUser>()
			.AddEntityFrameworkStores<ApplicationDbContext>()
			.AddDefaultTokenProviders();

		builder.Services.AddScoped<UserManager<IdentityUser>>();
		builder.Services.AddScoped<SignInManager<IdentityUser>>();
		builder.Services.AddHttpContextAccessor();

		builder.Services.AddAuthentication().AddJwtBearer(opciones =>
		{
			opciones.MapInboundClaims = false;
			opciones.TokenValidationParameters = new TokenValidationParameters
			{
				ValidateIssuer = false,
				ValidateAudience = false,
				ValidateLifetime = true,
				ValidateIssuerSigningKey = true,
				IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["llavejwt"]!)),
				ClockSkew = TimeSpan.Zero
			};
		});
		
		-Ahora se va al development json para esta llave. Es fuera del logging.
		"llavejwt":  "ALSKDMALSKM3LK4M3LK43M43LAMSDLKASMDALSKDMASLKDMALK3M4LKM4L3KM5";
		
	
	107. Authorize y AllowAnonymous
		-Se van a proteger nuestras accione sy para eso se va a usar el atbto Authorize.
		-Con este se peude indicar que solo ciertas personas con ciertas credenciales pueden consumir una accion.
		-Esas credenciales pueden ser algo tan simple como ser logeado o incluso podria ser que el usuario fuese admin.
		-Se protege nuestras acciones y para eso se coloca el atbto de Authorize a nivel de clase en todos nuestros controladores.
		-Se va  AutoresColeccionController y se mete esto.
		[ApiController]
		[Route("api/autores-coleccion")]
		[Authorize]
		public class AutoresColeccionController : ControllerBase
		
		-Con este authorize no se peuden consumir las acciones que estan en ese controlador.
		-Si se quiere proteger una sola accion se pone el Authorize en la accion y listo.
		-pero, se van a proteger todas las acciones de un controlador.
		-Se añade idem en AutoresController, ComentariosController Y lIBROScONTROLLER.
		-si se hace una peticion desde postman a cvualquier ruta, da 401 que da unauthorized
		-Que pasa si tenemos una accion para la que se quiere hacer una excepcion? 
		-Si se quiere que un usuario no autenticado pueda obtener el listado de autores, pues para eso se peude usar AllowAnonymous,
		-Esto significa que cualquier persona peude usar este endpoint.
		-Se añade AllowAnonymous en el GET de Autores de AutoresController.
		[HttpGet] // /api/autores/
		[AllowAnonymous]
		public async Task<IEnumerable<AutorDTO>> Get()
		
	108. Registrando usuarios
		-Se va a crear Controlador de usuarios que nos va a permitir entre otras cosas registranos y logearnos en nuestra app.
		-Se van a crear unos pocos DTOs.
		CredencialesUsuarioDTO: valor de entrada que vamosa  recibir para registranos y autenticarnos. Se recibe email y password. El password se hace opcional porque quiero poder istanciar un 
		usuarioDTO sin password. En lo que se respecta a recibir las credenciales de UsuarioDTO desde un cliente debe venir con un password y por eso se mete un Required.
		public class CredencialesUsuarioDTO
		{
			[Required]
			[EmailAddress]
			public required string Email { get; set; }
			[Required]
			public string? Password { get; set; }
		}
		
		-Ahora se va a crear DTO que representa el valor de salid del WebAPI cuando el usuario se logea o registra.
		public class RespuestaAutenticacionDTO
		{
			public required string Token { get; set; }
			public DateTime Expiracion { get; set; }
		}
		
		-Se agrega el UsuariosController.
		-Se añade el Authorized porque habrá rutas que se quieren proteger.
		-UserManager para crear un usuario.
		-El IConfiguration es para obtener valores de un proveedor de configuracion.
		-NO se quiere asociar los errores a un campo especifico, por eso se pone string.Empty para coocar error vacio.
		-Se construye tambien un metodo privado para construir un token, el jwt. primero se crean los claims que es ingo acerca del usuario Un claim es una llave y un valor.
		-Se quiere tambien ir a la bbdd a buscar los claims del usuario: se usa userManager para buscar un user.
		-Se busca por Email. Se trabaja con llave secreta que estara en un proveedor de cofiguracion
		-Se usa un algoritmo que nos va a permitir firmar el JWT para que nadie pueda editar de forma fraudulenta sus valores.
		-Nosotros ponemos un año de vigencia para el token para no complicarnos.
		[HttpPost("registro")]
		public async Task<ActionResult<RespuestaAutenticacionDTO>> Registrar(CredencialesUsuarioDTO credencialesUsuarioDTO)
		{
			var usuario = new IdentityUser
			{
				UserName = credencialesUsuarioDTO.Email,
				Email = credencialesUsuarioDTO.Email
			};

			var resultado = await userManager.CreateAsync(usuario, credencialesUsuarioDTO.Password!);

			if (resultado.Succeeded)
			{
				var respuestaAutenticacion = await ConstruirToken(credencialesUsuarioDTO);
				return respuestaAutenticacion;
			}
			else
			{
				foreach (var error in resultado.Errors)
				{
					ModelState.AddModelError(string.Empty, error.Description);
				}

				return ValidationProblem();
			}
		}

		private async Task<RespuestaAutenticacionDTO> ConstruirToken(CredencialesUsuarioDTO credencialesUsuarioDTO)
		{
			var claims = new List<Claim>
			{
				new Claim("email", credencialesUsuarioDTO.Email),
				new Claim("lo que yo quiera", "cualqueir valor")
			};

			var usuario = await userManager.FindByEmailAsync(credencialesUsuarioDTO.Email);
			var claimsDB = await userManager.GetClaimsAsync(usuario!);

			claims.AddRange(claimsDB);

			var llave = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(configuration["llavesjwt"]!));
			var credenciales = new SigningCredentials(llave, SecurityAlgorithms.HmacSha256);

			var expiracion = DateTime.UtcNow.AddYears(1);

			var tokenDeSeguridad = new JwtSecurityToken(issuer: null, audience: null, claims: claims, expires: expiracion, signingCredentials: credenciales);

			var token = new JwtSecurityTokenHandler().WriteToken(tokenDeSeguridad);

			return new RespuestaAutenticacionDTO
			{
				Token = token,
				Expiracion = expiracion
			};
		}
		
		-Se va a postman para hacer un registro. La password tiene que cumplir unas reglas por defecto.
		POST http://localhost:5065/api/usuarios/registro
		{
			"email": "felipe@gmail.com",
			"password": "aA123456!"
		}
		
		-Se le mete esto al metodo: [AllowAnonymous]
		
	109. Login de usuarios
		-Se crea peticion POST. En lugar de usar userManager, se usa SignInManger que se inyecta en el ctor.
		private readonly UserManager<IdentityUser> userManager;
		private readonly IConfiguration configuration;
		private readonly SignInManager<IdentityUser> signInmanager;

		public UsuariosController(UserManager<IdentityUser> userManager, IConfiguration configuration, SignInManager<IdentityUser> signInmanager)
		{
			this.userManager = userManager;
			this.configuration = configuration;
			this.signInmanager = signInmanager;
		}
		
		-Si el usuario e snulo, queire decir que no existe un usuario con ese email. Sin embargo, en cuestiones de ciberseguridad existen ocasiones en las que
		 se quiere ser lo menos especifico posible caundo el usuario se intenta loggear porque no se le peude decir que no existe un usuario con ese email
		 porque entonces se esta revelando info acerca de quien está o no registrado en nuestra app. Para proteger la privacidad de nuestros users,
		 tengo que decir un mensaje vago o generico como Login Incorrecto.
		 Como se va a usar eso de login incorrecto en varios lugares se crea una funcion.
		 lockOutOnFailure es que el usuario aunque se equivoque varias veces al colocar password, no le vamos a bloquear la cuenta.
		[HttpPost("login")]
		public async Task<ActionResult<RespuestaAutenticacionDTO>> Login(CredencialesUsuarioDTO credencialesUsuarioDTO)
		{
			var usuario = await userManager.FindByEmailAsync(credencialesUsuarioDTO.Email);

			if (usuario == null)
			{
				return RetornarLoginIncorrecto(); 
			}

			var resultado = await signInManager.CheckPasswordSignInAsync(usuario, credencialesUsuarioDTO.Password!, lockoutOnFailure: false);

			if (resultado.Succeeded)
			{
				return await ConstruirToken(credencialesUsuarioDTO);
			}
			else
			{
				return RetornarLoginIncorrecto();
			}
		}

		private ActionResult RetornarLoginIncorrecto()
		{
			ModelState.AddModelError(string.Empty, "Login Incorrecto");
			return ValidationProblem();
		}
		
		-Se vuelve a probar la peticion de Postman.
		POST http://localhost:5065/api/usuarios/registro
		{
			"email": "felipe@hotmail.com",
			"password": "aA123456!"
		}
		Debe sacar error
		{
			"errors": {
				"": [
					"Username 'felipe@hotmail.com' is already taken."
				]
			},
			"type": "https://tools.ietf.org/html/rfc9110#section-15.5.1",
			"title": "One or more validation errors occurred.",
			"status": 400,
			"traceId": "00-f052455a4f8071acf2822f5fd4a994f8-954c4b28e287a5c1-00"
		}
		
		-Se añade esto: [AllowAnonymous] a login POST.
		
		-Se lanza desde postman la colicitud POST al login:
		POST http://localhost:5065/api/usuarios/login
		{
			"email": "felipe@hotmail.com",
			"password": "aA123456!"
		}
		
		-Si se coloca password incorrecto, saca Login incorrecto.
		
	110. Enviando el JWT
		-Se aprende a enviar el JWT para poder autenticarnos en la app y consumir los endpoints de la app, los cuales estan protegidos.
		-Si estoy logeado no signfica, en el caso de una herramienta como Postman, que automaticamente  se va a mandar el JWT
		-Se tiene api/libros y me retorna en postman un 401 Unauthorized porque no estoy mandando el JWT
		-Se coge desde la peticion del login el token y se copia desde postman.
		GET http://localhost:5065/api/usuarios/login
		Pestaña authorization > Bearer Token y se mete el token que hemos copiado.
		
		-Se le ha pasado una cabecera que se llama Authorization al WebAPI a traves de la peticion HTTP
		-Igual en un cliente de .net se tiene que construir con el httpClient con Angular o Android  para mandar el toke hace cabecera Authorization = ....
		
	111. Relacion entre Usuarios y Comentarios
		-Un usuario crea un comentario y por lo tanto quiero poder colocar la ID del usuario en el registro del comentario y se quiere que 
		 ese ID se corresponda con un usuario real
		-Se av hacia la entidad comentario 
		-Se vaa  recordar que el Id del usuario. En AspNetusers, el Id es un string.
		-Por tanto, esto se debe colcoar en Comentario.
		-Se pone required porque es obligatorio colcoar el id de un usuario.
		-Se coloca tb una propeidad de navegacion recordadon que es identityuser la clase que representa a un usuario.
		-Se coloca Nullable porque no siempre qie se tenga comentario voy a tener data relacionada.
		-hay un campo como obligatorio (UsuarioId), antes de crearlo, yo voy a tener que borrar la data que está en Comentarios, porque si agrego esta columna,
		 pues valor por defecto es nulo y dara error.
		-Si agrego esta columna, su valor por defecto va a ser nulo, pero no puede ser y dara error.
		-Si hago Add-Migration ComentarioUsuario y luego Update-Database pues se ve que falla.
		-Aunque el valor que se le da es un string vacio no nos vale para el id de un usuario. El error consiste en que no existe un usuario con el Id string vacio.
		-Como se esta configurando el UserId como llave foranea, el valor que coloque en dicho campo tiene que corresponderse con el Id de un usuario.
		-Se va a SQL Server Management Studio y se borra el contenido de la tabla de Comentarios: Delete Comentarios y se repite el comando de migracion.
		-Se actualizan idem los DTOs.
		Antes
		public class Comentario
		{
			public Guid Id { get; set; }
			[Required]
			public required string  Cuerpo { get; set; }
			public DateTime FechaPublicacion { get; set; }
			public int LibroId { get; set; }
			public Libro? Libro { get; set; }
			public List<Comentario> Comentarios { get; set; } = new List<Comentario>();
		}
		
		Despues => Nota: No se cuando se ha borrado esto: public List<Comentario> Comentarios { get; set; } = new List<Comentario>();
		public class Comentario
		{
			public Guid Id { get; set; }
			[Required]
			public required string  Cuerpo { get; set; }
			public DateTime FechaPublicacion { get; set; }
			public int LibroId { get; set; }
			public Libro? Libro { get; set; }
			// public List<Comentario> Comentarios { get; set; } = new List<Comentario>();
			public required string UsuarioId { get; set; }
			public IdentityUser? Usuario { get; set; }
		}
		
		-ComentarioDTO:
		ANTES
		public class ComentarioDTO
		{
			public Guid Id { get; set; }
			public required string Cuerpo { get; set; }
			public DateTime FechaPublicacion { get; set; }

		}
		
		DESPUES
		public class ComentarioDTO
		{
			public Guid Id { get; set; }
			public required string Cuerpo { get; set; }
			public DateTime FechaPublicacion { get; set; }
			public required string UsuarioId { get; set; }
			public required string UsuarioEmail { get; set; }
		}
		
		-Se va a ComentarioController. Se trae data relacionada del usuario.
		ANTES
		 [HttpGet]
		 public async Task<ActionResult<List<ComentarioDTO>>> Get(int libroId)
		 {
			 var existeLibro = await context.Libros.AnyAsync(x => x.Id == libroId);

			 if (!existeLibro)
			 {
				 return NotFound();
			 }

			 var comentarios = await context.Comentarios
				 .Where(x => x.LibroId == libroId)
				 .OrderByDescending(x => x.FechaPublicacion)
				 .ToListAsync();

			 return mapper.Map<List<ComentarioDTO>>(comentarios);
		 }
		 
		DESPUES
		[HttpGet]
		public async Task<ActionResult<List<ComentarioDTO>>> Get(int libroId)
		{
			var existeLibro = await context.Libros.AnyAsync(x => x.Id == libroId);

			if (!existeLibro)
			{
				return NotFound();
			}

			var comentarios = await context.Comentarios
				.Include(x => x.Usuario)
				.Where(x => x.LibroId == libroId)
				.OrderByDescending(x => x.FechaPublicacion)
				.ToListAsync();

			return mapper.Map<List<ComentarioDTO>>(comentarios);
		}
		
		-Esto tb se cambia.
		ANTES
		[HttpGet("{id}", Name ="ObtenerComentario")]
		public async Task<ActionResult<ComentarioDTO>> Get(Guid id)
		{
			var comentario = await context.Comentarios.FirstOrDefaultAsync(x => x.Id == id);

			if (comentario is null)
			{
				return NotFound();
			}

			return mapper.Map<ComentarioDTO>(comentario);
		}
		
		DESPUES
		[HttpGet("{id}", Name ="ObtenerComentario")]
		public async Task<ActionResult<ComentarioDTO>> Get(Guid id)
		{
			var comentario = await context.Comentarios
				.Include(x => x.Usuario)
				.FirstOrDefaultAsync(x => x.Id == id);

			if (comentario is null)
			{
				return NotFound();
			}

			return mapper.Map<ComentarioDTO>(comentario);
		}
		
		-Se va a AutomapperProfiles y se busca el mapeo de Comentario a ComentarioDTO y se configura el mapeo de usuarioEmail. Se mapea de email a usuarioEmail.
		CreateMap<Comentario, ComentarioDTO>();
		CreateMap<Comentario, ComentarioDTO>()
			.ForMember(dto => dto.UsuarioEmail, config => config.MapFrom(ent => ent.Usuario!.Email));		
			
		-Esto consigue mapear la relacion entre usuario y comentario
		-No se tienen ahora comentarios. Lo que se quiere hacer es que cuando cree un comentario, quiero asignarle el id del usuario loggeado a ese comentario.
	
	112. Obteniendo al usuario loggeado
		-En ComnetarioCreacionDTO no se puede meter public required string usuarioId {get; set;}
		-No se puede hacer eso para obtener el Id del usuario loggeado porque cualquier puede mandar cualquier Id por ahi....
		-Se puede mandar el id de cualquiera y eso no puede ser.
		-Para obtener el id del usuario, se busca mecanismo.
		-Esto se va a hacer a traves del JSON Web Token que recibimos.
		-El JSOn Web Token contiene Claims y uno de los claims que le pusimos es el claim del email.
		-Esto se ve en el metodo ConstruirToken de UsuariosController.
		-A partir de ese email, voy a poder obtener el ID del usuario a traves del UserManager
		-Se toma el email del claim del json web token y de ahi buscas en la bbdd a que usuario le corresponde ese email.
		-Porque se puede confiar ene el email del token y no en el de ComentarioCreacionDTO? No se peude confiar porque cualquier puede
		 poner cualquier valor. En el claim no se peude poner cualquier valor porque ese jsonwebtoken es firmado con llave secreta.
		-Como es firmado con llave secreta, pues significa que se peude confiar en su contenido porque aquellos que tengan acceso a la llave secreta 
		 van a poder generar json web token valido para nuestra app, por eso se peude confiar en el email que se recibe por el claim.
		-Se crea un servicio que permite obtener el Id del usuario a partir de json web token.
		-Se crea una folder que se llame Servicios y dentro ServiciosUsuarios. Se mete nullable a lo que devuelve porque peude que usuario no exista.
		 que es tipico si el usuario no está loggeado.
		 public async Task<IdentityUser?> ObtenerUsuario()
		{
			var emailClaim = contextAccessor.HttpContext!.User.Claims.Where(x => x.Type == "email").FirstOrDefault();

			if (emailClaim is null)
			{
				return null;
			}
			var email = emailClaim.Value;
			return await userManager.FindByEmailAsync(email);
		}
		
		-Se crea una interfaz a partir de esta clase para poder usar el principio de inversion de dependencias para que asi dependamos de tipos abstractos y no de tipos concretos.
		-Se mete ctrl + . + k. Se crea una nueva interfaz y fuera.
		-Se va a Program y se coloca el servicio nuevo:
		-Se mete transient porque no se necesita compartir estado: builder.Services.AddTransient<IServiciosUsuarios, ServiciosUsuarios>();
		
		-Asi, se puede obtener el usuario loggeado en nuestra app pero de forma segura para que no se peuda su Id de usuario.
		
	113. Utilizando el servicio de usuarios.
		
		
		
		
		
		
		
			
		
		
			 
		

		
		
			
		
	
		
		
		
		
		


		
		 
		
		
		
		
		
		
		
		
		

	
		
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		
			
		